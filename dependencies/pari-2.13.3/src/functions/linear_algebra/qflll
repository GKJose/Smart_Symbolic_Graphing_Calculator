Function: qflll
Section: linear_algebra
C-Name: qflll0
Prototype: GD0,L,
Help: qflll(x,{flag=0}): LLL reduction of the vectors forming the matrix x
 (gives the unimodular transformation matrix T such that x*T is LLL-reduced). flag is
 optional, and can be 0: default, 1: assumes x is integral, 2: assumes x is
 integral, returns a partially reduced basis,
 4: assumes x is integral, returns [K,T] where K is the integer kernel of x
 and T the LLL reduced image, 5: same as 4 but x may have polynomial
 coefficients, 8: same as 0 but x may have polynomial coefficients.
Description:
 (vec, ?0):vec       lll($1)
 (vec, 1):vec        lllint($1)
 (vec, 2):vec        lllintpartial($1)
 (vec, 4):vec        lllkerim($1)
 (vec, 5):vec        lllkerimgen($1)
 (vec, 8):vec        lllgen($1)
 (vec, #small):vec   $"Bad flag in qflll"
 (vec, small):vec    qflll0($1, $2)
Doc: \idx{LLL} algorithm applied to the
 \emph{columns} of the matrix $x$. The columns of $x$ may be linearly
 dependent. The result is by default a unimodular transformation matrix $T$
 such that $x \cdot T$ is an LLL-reduced basis of the lattice generated by
 the column vectors of $x$. Note that if $x$ is not of maximal rank $T$ will
 not be square. The LLL parameters are $(0.51,0.99)$, meaning that the
 Gram-Schmidt coefficients for the final basis satisfy $|\mu_{i,j}| \leq
 0.51$, and the Lov\'{a}sz's constant is $0.99$.

 If $\fl=0$ (default), assume that $x$ has either exact (integral or
 rational) or real floating point entries. The matrix is rescaled, converted
 to integers and the behavior is then as in $\fl = 1$.

 If $\fl=1$, assume that $x$ is integral. Computations involving Gram-Schmidt
 vectors are approximate, with precision varying as needed (Lehmer's trick,
 as generalized by Schnorr). Adapted from Nguyen and Stehl\'e's algorithm
 and Stehl\'e's code (\kbd{fplll-1.3}).

 If $\fl=2$, $x$ should be an integer matrix whose columns are linearly
 independent. Returns a partially reduced basis for $x$, using an unpublished
 algorithm by Peter Montgomery: a basis is said to be \emph{partially reduced}
 if $|v_i \pm v_j| \geq |v_i|$ for any two distinct basis vectors $v_i, \,
 v_j$. This is faster than $\fl=1$, esp. when one row is huge compared
 to the other rows (knapsack-style), and should quickly produce relatively
 short vectors. The resulting basis is \emph{not} LLL-reduced in general.
 If LLL reduction is eventually desired, avoid this partial reduction:
 applying LLL to the partially reduced matrix is significantly \emph{slower}
 than starting from a knapsack-type lattice.

 If $\fl=3$, as $\fl=1$, but the reduction is performed in place: the
 routine returns $x \cdot T$. This is usually faster for knapsack-type
 lattices.

 If $\fl=4$, as $\fl=1$, returning a vector $[K, T]$ of matrices: the
 columns of $K$ represent a basis of the integer kernel of $x$
 (not LLL-reduced in general) and $T$ is the transformation
 matrix such that $x\cdot T$ is an LLL-reduced $\Z$-basis of the image
 of the matrix $x$.

 If $\fl=5$, case as case $4$, but $x$ may have polynomial coefficients.

 If $\fl=8$, same as case $0$, but $x$ may have polynomial coefficients.

 \bprog
 ? \p500
   realprecision = 500 significant digits
 ? a = 2*cos(2*Pi/97);
 ? C = 10^450;
 ? v = powers(a,48); b = round(matconcat([matid(48),C*v]~));
 ? p = b * qflll(b)[,1]; \\ tiny linear combination of powers of 'a'
    time = 4,470 ms.
 ? exponent(v * p / C)
 %5 = -1418
 ? p3 = qflll(b,3)[,1]; \\ compute in place, faster
    time = 3,790 ms.
 ? p3 == p \\ same result
 %7 = 1
 ? p2 = b * qflll(b,2)[,1]; \\ partial reduction: faster, not as good
    time = 343 ms.
 ? exponent(v * p2 / C)
 %9 = -1190
 @eprog

Variant: Also available are \fun{GEN}{lll}{GEN x} ($\fl=0$),
 \fun{GEN}{lllint}{GEN x} ($\fl=1$), and \fun{GEN}{lllkerim}{GEN x} ($\fl=4$).
