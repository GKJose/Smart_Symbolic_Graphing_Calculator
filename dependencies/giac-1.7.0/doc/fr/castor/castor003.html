<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="castor.css">
<TITLE>Les instructions de programmation</TITLE>
</HEAD>
<BODY >
<A HREF="castor002.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="castor004.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc47">Chapitre 2</A>  Les instructions de programmation</H1><H3 CLASS="subsection"><A NAME="htoc48">2.0.3</A>  Généralités</H3><P><A NAME="@default28"></A><A NAME="@default29"></A><A NAME="@default30"></A><A NAME="@default31"></A><A NAME="@default32"></A><A NAME="@default33"></A><A NAME="@default34"></A><A NAME="@default35"></A><A NAME="@default36"></A><A NAME="@default37"></A><A NAME="@default38"></A>
Il faut savoir que :<BR>
<TT>;</TT> termine une instruction,<BR>
<TT>:=</TT> permet d’affecter une variable ou de définir une fonction ou une 
procédure.<BR>
On tape pour affecter une variable:
</P><DIV CLASS="center"><TT>a:=1</TT></DIV><P>
On tape pour définir la fonction <TT><I>f</I>(<I>x</I>)=2*<I>x</I>+√</TT><TT><SPAN style="text-decoration:overline"><I>x</I></SPAN></TT> :
</P><DIV CLASS="center"><TT>f(x):=2*x+sqrt(x)</TT></DIV><P>
On tape pour définir la procédure <TT>Carre</TT> :
</P><DIV CLASS="center"><TT>Carre(x):={repete(4,avance(x),tourne_gauche)}</TT></DIV><P>Un booléen a comme valeur 0 (faux) ou 1 (vrai),<BR>
les booléens (ie les conditions) peuvent être obtenus avec les signes 
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>•</B></DT><DD CLASS="dd-description"> <TT>==</TT> qui teste l’égalité (toutefois on admet <TT>=</TT> pour tester 
l’égalité dans les instructions <TT>si</TT> et <TT>tantque</TT>),
</DD><DT CLASS="dt-description"><B>•</B></DT><DD CLASS="dd-description"> <TT>&lt; &gt; &lt;= &gt;=</TT> qui testent les inégalités,
</DD><DT CLASS="dt-description"><B>•</B></DT><DD CLASS="dd-description"> <TT>!=</TT> qui teste la différence.
</DD></DL><P>
Les opérateurs sur les booléens sont <TT>ou, et, non</TT>.<BR>
On tape :
</P><DIV CLASS="center"><TT>0 et 1</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>0 and 1</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>0</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>0 ou 1</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>0 or 1</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>1</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>0 &gt; 1</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>0</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>non(0 &lt;1)</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>not(0 &lt;1)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>1</TT></DIV><H3 CLASS="subsection"><A NAME="htoc49">2.0.4</A>  Pour choisir : <TT>si...alors...sinon...fsi</TT></H3><P><A NAME="@default39"></A><A NAME="@default40"></A><A NAME="@default41"></A><A NAME="@default42"></A>
<TT>si &lt;condition&gt; alors &lt;instructions1;&gt; sinon &lt;instructions2;&gt; fsi</TT>
permet d’effectuer les <TT>&lt;instructions1;&gt;</TT> lorsque la condition est 
satisfaite et d’effectuer les <TT>&lt;instructions2;&gt;</TT> lorsque la condition n’est
pas satisfaite.<BR>
On tape :
</P><DIV CLASS="center"><TT>a:=3; si a==3 alors avance 10*a; sinon avance; fsi </TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>a:=3; if (a==3) {avance(10*a);} else {avance;}</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>La tortue avance de 30 pas</TT></DIV><H3 CLASS="subsection"><A NAME="htoc50">2.0.5</A>  Pour répéter les mêmes instructions: <TT>repete</TT></H3><P><A NAME="@default43"></A>
Pour faire plusieurs fois de suite plusieurs instructions on utilise 
<TT>repete</TT>.<BR>
<TT>repete</TT> a comme argument un entier (le nombre de fois) et la suite 
d’instructions séparées par une virgule.<BR>
On tape :
</P><DIV CLASS="center"><TT>repete 3,avance 40,tourne_droite 120 </TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>repete 3,avance(30),tourne_droite(120)</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>repete(3,avance 30,tourne_droite 120)</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>repete(3,avance(30),tourne_droite(120))</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Un triangle équilatéral de cotés 30</TT></DIV><P>
<B>Attention</B>
Si on veut utiliser un <TT>repete</TT> dans un autre <TT>repete</TT> il faut le 
parenthéser c’est à dire mettre à l’extérieur de <TT>repete</TT> soit 
<TT>()</TT> soit <TT>[]</TT> : <TT>(repete....)</TT> ou <TT>[repete....]</TT>.<BR>
On tape par exemple :<BR>
<TT>repete(2,(repete(3,avance(20),tourne_gauche(30))),tourne_droite)</TT><BR>
ou<BR>
<TT>repete(2,[repete(3,avance(20),tourne_gauche(30))],tourne_droite)</TT><BR>
qui dessine 2 arcs "hexagonaux", ce qui est différent de :<BR>
<TT>repete(2,repete(3,avance(20),tourne_gauche(30)),tourne_droite)</TT><BR>
qui équivaut à :<BR>
<TT>repete(2,repete(3,avance(20),tourne_gauche(30),tourne_droite))</TT><BR>
et qui dessine l’hexagone :<BR>
<TT>repete(6,avance(20),tourne_droite(60))</TT></P><H3 CLASS="subsection"><A NAME="htoc51">2.0.6</A>  Pour faire <I>n</I> fois une boucle : <TT>pour...de ...jusque... pas...faire...fpour</TT></H3><P><A NAME="@default44"></A><A NAME="@default45"></A><A NAME="@default46"></A><A NAME="@default47"></A><A NAME="@default48"></A>
<TT>pour </TT><TT><I>k</I></TT><TT> de </TT><TT><I>k</I>1</TT><TT> jusque </TT><TT><I>k</I>2</TT><TT> pas </TT><TT><I>p</I></TT><TT> faire &lt;instructions;&gt; fpour</TT> permet de faire les instructions en faisant varier <I>k</I> de <I>k</I>1 jusqu’à
<I>k</I>2 en faisant des pas de <I>p</I> (si <I>p</I>=1 <TT>pas </TT><TT><I>p</I></TT> peut être omis).<BR>
Bien sûr <I>k</I> peut être remplacé par un autre nom de variable et en 
général les instructions à faire dépendent de cette variable car sinon 
on utilise <TT>repete</TT>
On tape :
</P><DIV CLASS="center"><TT>pour n de 1 jusque 10 faire avance 10*n;tourne_gauche;fpour</TT></DIV><P>
Ou on tape :<BR>
</P><DIV CLASS="center"><TT>for (n:=1;n&lt;=10;n:=n+1){avance 10*n;tourne_gauche;}</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>La tortue dessine un morceau de frise grecque en partant du centre</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>pour n de 10 jusque 1 pas -1 faire avance 10*n;tourne_gauche;fpour</TT></DIV><P>
Ou on tape :<BR>
</P><DIV CLASS="center"><TT>for (n:=10;n&gt;=1;n:=n-1){avance 10*n;tourne_gauche;}</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>La tortue dessine un morceau de frise grecque mais en partant de l’extérieur</TT></DIV><H3 CLASS="subsection"><A NAME="htoc52">2.0.7</A>  Pour faire une boucle : <TT>tantque...faire...ftantque</TT></H3><P><A NAME="@default49"></A><A NAME="@default50"></A><A NAME="@default51"></A>
<TT>tantque &lt;condition&gt; faire &lt;instructions;&gt; ftantque</TT> permet de 
faire les instructions tant que la condition est satisfaite.<BR>
On ouvre un éditeur de programme (<TT>Alt+p</TT> et on tape :
</P><PRE CLASS="verbatim">dessine_tortue;
n:=100;
tantque (n&gt;0) faire 
 avance n;
 tourne_gauche;
 n:=n-10;
ftantque;
</PRE><P>Ou on tape :<BR>
</P><PRE CLASS="verbatim">dessine_tortue;
n:=100;
while (n&gt;0) {
 avance n;
 tourne_gauche;
 n:=n-10;
}:;
</PRE><P>Puis on compile en appuyant sur <TT>OK</TT> ou sur <TT>F9</TT> et on obtient :
</P><DIV CLASS="center"><TT>La tortue dessine un morceau de frise grecque</TT></DIV><DIV CLASS="center"><IMG SRC="castor001.png"></DIV><H3 CLASS="subsection"><A NAME="htoc53">2.0.8</A>  Pour faire une boucle en utilisant la récursivité</H3><P>
Une procédure récursive est une procédure qui s’appelle elle-même mais
avec des paramètres différents et comporte un test d’arrêt qui permet 
d’interrompre cet appel.<BR>
On tape dans un éditeur de programmes puis on compile en appuyant sur <TT>OK</TT>
ou sur <TT>F9</TT> :
</P><PRE CLASS="verbatim"> 
polygo(n,p,a):={
 si p!=0 alors
   avance(a);
   tourne_gauche(360/n);
   polygo(n,p-1,a);
 fsi;
}:;
</PRE><P>Ou on tape en utilisant <TT>si...alors...fsi</TT> au lieu de <TT>if...{...}</TT> :
</P><PRE CLASS="verbatim"> 
polygo(n,p,a):={
 si (p!=0) alors
   avance(a);
   tourne_gauche(360/n);
   polygo(n,p-1,a);
 fsi;
};
</PRE><P>Ou on tape une procédure non récursive en utilisant <TT>repete</TT> :
</P><DIV CLASS="center"><TT>polygo(n,p,a):=repete(p,avance(a),tourne_gauche(360/n))</TT></DIV><P>
Puis on tape dans un niveau de l’écran tortue :
</P><DIV CLASS="center"><TT>efface;dessine_tortue;polygo(6,5,50)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Les 5 cotés d’un hexagone de côtés 50</TT></DIV><DIV CLASS="center"><IMG SRC="castor002.png"></DIV><P>
On veut faire une suite de <I>n</I> triangles équilatèraux : le premier a pour 
côtés <I>a</I>, le deuxième a pour sommet les milieux des cotés du premier 
triangle etc ...
On suppose que la tortue a comme position de départ :
un sommet du premier triangle et est dirigée selon un coté et que 
les triangles sont situés sur sa gauche (si vous choisissez les triangles 
sont situés sur sa droite, il suffira de changer les <TT>tourne_droite</TT> en
<TT>tourne_gauche</TT> et vice-versa). On choisit la même position comme 
position d’arrivée.<BR>
Voici deux procédures récursives.<BR>
On dessine le premier triangle, puis on place la tortue à l’endroit où il
faut être pour faire l’appel récursif, on fait l’appel récursif,
et on ramene la tortue à sa position de départ.<BR>
On tape par exemple dans un éditeur de programmes puis on compile en appuyant
sur <TT>OK</TT> ou sur <TT>F9</TT> :
</P><PRE CLASS="verbatim">tria(n,a):={
si n!=0 alors 
repete(3,avance(a),tourne_gauche(120));
avance(a/2);
tourne_gauche(60);
tria(n-1,a/2);
tourne_droite(60);
avance(-a/2);
fsi;
}:;
</PRE><P>On tape :<BR>
<TT>efface;dessine_tortue;tria(5,100)</TT><BR>
On obtient :
</P><DIV CLASS="center"><IMG SRC="castor003.png"></DIV><P>Ou pour ne pas repasser sur le même trait, on commence à dessiner le 
début du premier triangle, puis on place la tortue à l’endroit où il faut
être pour faire l’appel récursif, on fait l’appel récursif, puis on 
finit de dessiner le premier triangle et on ramène la tortue à sa position 
de départ.<BR>
On tape :
</P><PRE CLASS="verbatim"> 
tria1(n,a):={
si n!=0 alors
avance(a/2);
tourne_droite(60);
tria1(n-1,a/2);
tourne_gauche(60);
avance(a/2);
tourne_droite(120);
repete(2,avance(a),tourne_droite(120));
fsi;
}:;
</PRE><P>Puis on tape :
</P><DIV CLASS="center"><TT>efface;dessine_tortue;tria1(5,100)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>5 triangles équilatèraux, le deuxième triangle a pour sommet les milieux des cotés du premier triangle etc ...</TT></DIV><P>
c’est à dire le même dessin que précédemment.</P><H3 CLASS="subsection"><A NAME="htoc54">2.0.9</A>  Pour définir une fonction : <TT>retourne</TT></H3><P><A NAME="@default52"></A>
<TT>retourne</TT> a un argument qui est la valeur que l’on veut donner 
à la fonction.<BR>
<TT>retourne</TT> permet d’interrompre le programme et de renvoyer l’argument 
de <TT>retourne</TT> comme étant la valeur de la fonction que l’on définit.<BR>
On tape pour avoir une fonction booléenne qui nous dit si il y a un terme nul dans une liste <TT>l</TT> :
</P><PRE CLASS="verbatim">zerodansl(l):={
 pour k de 0 jusque size(l)-1 faire 
  si l[k]==0 alors 
  retourne(1);
  fsi; 
 fpour; 
 retourne(0);
}:;
</PRE><P>Ou on tape :<BR>
</P><PRE CLASS="verbatim">zeroinl(l):={
 for (k:=0;k&lt;size(l);k++){
  if (l[k]==0) retourne(1);
 } 
 retourne(0);
 }:;
</PRE><P>On obtient :
</P><DIV CLASS="center"><TT>La fonction booléenne qui teste si il y a un zéro dans 
une liste</TT></DIV><P>
<B>Remarque</B><BR>
Lorsqu’on fait un dessin tortue, on écrit une procédure : cette procédure
va exécuter toutes les instructions graphiques et renvoie automatiquement 
l’état de la tortue. On n’a donc pas besoin d’utiliser <TT>retourne</TT>, sauf 
si on a besoin de transmettre un résultat.</P><H3 CLASS="subsection"><A NAME="htoc55">2.0.10</A>  Pour lire une expressionà partir du clavier : <TT>lis</TT></H3><P><A NAME="@default53"></A>
<TT>lis</TT> a un argument qui est le nom d’une variable.<BR>
<TT>lis</TT> interrompt le programme et ouvre une petite feneêtre qui permet 
d’entrer une expression qui sera la valeur de l’argument de <TT>lis</TT> : si 
l’expression est une chaîne de caractères il faut mettre des 
guillemets.<BR>
On tape :
</P><PRE CLASS="verbatim">pilote(l):={
si l==f alors retourne 1;fsi; 
si l==e alors L:=L,"efface";efface; fsi;
si l==a alors avance; fsi;
si l==r alors recule; fsi;
si l==d alors tourne_droite; fsi;
si l==g alors tourne_gauche; fsi;
lis(l);
pilotee(l);
}:;
</PRE><P>Puis on tape :
</P><DIV CLASS="center"><TT>pilote(a) d a d a d a f</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>un carré</TT></DIV><P>
Si on veut garder les instructions qui ont été exécutées, On peut 
renvoyer une chaine de caractères contenant ces instructions separées par 
des <TT>;</TT>.<BR>
On tape :
</P><PRE CLASS="verbatim">piloter(l):={
local L;
si l==f alors retourne "";fsi; 
si l==e alors L:="efface;";efface; fsi;
si l==a alors L:="avance;";avance; fsi;
si l==r alors L:="recule;";recule; fsi;
si l==d alors L:="tourne_droite;";tourne_droite; fsi;
si l==g alors L:="tourne_gauche;";tourne_gauche; fsi;
lis(l);
retourne L+piloter(l);
}:;
</PRE><P>Puis on tape :
</P><DIV CLASS="center"><TT>A:=piloter(a)</TT></DIV><P>
Puis :
</P><DIV CLASS="center"><TT>d a d a d a f</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>un carré</TT></DIV><P>
Puis on tape :
</P><DIV CLASS="center"><TT>A</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>"avance;tourne_droite;avance;tourne_droite;<BR>
 avance;tourne_droite;avance;tourne_droite"</TT></DIV><P>
Puis on tape :
</P><DIV CLASS="center"><TT>efface;execute(A)</TT></DIV><P>
On obtient à nouveau :
</P><DIV CLASS="center"><TT>un carré</TT></DIV><H3 CLASS="subsection"><A NAME="htoc56">2.0.11</A>  Pour lire une chaîne de caractères à partir du clavier : <TT>lis_phrase</TT></H3><P><A NAME="@default54"></A>
<TT>lis_phrase</TT> a un argument qui est le nom d’une variable.<BR>
<TT>lis_phrase</TT> interrompt le programme et ouvre une petite feneêtre qui 
permet d’entrer une chaîne de caractères qui sera la valeur de 
l’argument de <TT>lis_phrase</TT> : on tape la chaîne de caractères sans
mettre les guillemets.<BR>
On tape :
</P><PRE CLASS="verbatim">conduite(l):={
si l=="f" alors retourne 1;fsi; 
si l=="e" alors efface; fsi;
si l=="a" alors avance fsi;
si l=="r" alors recule fsi;
si l=="d" alors tourne_droite; fsi;
si l=="g" alors tourne_gauche; fsi;
lis_phrase(l);
conduite(l);
}:;
</PRE><P>Puis on tape :
</P><DIV CLASS="center"><TT>conduite("a") d a d a d a f</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>un carré</TT></DIV><P>
Si on veut garder la suite des instructions qui a été exécutée, on peut
renvoyer une chaine de caractères contenant ces instructions separées par 
des <TT>;</TT>.<BR>
On tape :
</P><PRE CLASS="verbatim">conduire(l):={
local L;
si l=="f" alors retourne "";fsi; 
si l=="e" alors L:="efface;";efface; fsi;
si l=="a" alors L:="avance;";avance; fsi;
si l=="r" alors L:="recule;";recule; fsi;
si l=="d" alors L:="tourne_droite;";tourne_droite; fsi;
si l=="g" alors L:="tourne_gauche;";tourne_gauche; fsi;
lis_phrase(l);
retourne L+conduire(l);
}:;
</PRE><P>Puis on tape :
</P><DIV CLASS="center"><TT>A:=conduire("a") d a d a d a f</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>un carré</TT></DIV><P>
Puis on tape :
</P><DIV CLASS="center"><TT>A</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>"avance;tourne_droite;avance;tourne_droite;<BR>
 avance;tourne_droite;avance;tourne_droite"</TT></DIV><P>
Puis on tape :
</P><DIV CLASS="center"><TT>efface;execute(A)</TT></DIV><P>
On obtient à nouveau :
</P><DIV CLASS="center"><TT>un carré</TT></DIV><H3 CLASS="subsection"><A NAME="htoc57">2.0.12</A>  Pour exécuter une chaîne de caractères : <TT>execute</TT></H3><P><A NAME="@default55"></A>
<TT>execute</TT> a comme argument chaîne de caractères qui est 
une suite de commande. L’argument doit être mis entre des parenthèses<BR>
<TT>execute</TT> exécute cette suite de commande.<BR>
On tape :<BR>
</P><DIV CLASS="center"><TT>execute(" tourne_droite;avance 40; rectangle_plein(20,40);avance -40")</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>le dessin d’un "drapeau"</TT></DIV><H2 CLASS="section"><A NAME="toc16"></A><A NAME="htoc58">2.1</A>  Faire un dessin pas à pas en le mémorisant</H2><H3 CLASS="subsection"><A NAME="htoc59">2.1.1</A>  Pour enregistrer les commandes : <TT>debut_enregistrement</TT></H3><P><A NAME="@default56"></A>
<TT>debut_enregistrement</TT> a comme argument un nom de procédure.<BR>
<TT>debut_enregistrement</TT> va permettre d’enregistrer les commandes comprises 
entre <TT>debut_enregistrement</TT> et <TT>fin_enregistrement</TT> et ainsi
définir une procédure du nom donné en argument de 
<TT>debut_enregistrement</TT>.<BR>
On tape :
</P><DIV CLASS="center"><TT>tourne_gauche </TT></DIV><DIV CLASS="center"><TT>debut_enregistrement(arbre)</TT></DIV><P>
Puis on tape les instructions pour définir <TT>arbre</TT> par exemple :
</P><DIV CLASS="center"><TT>avance 50</TT></DIV><P>
Puis
</P><DIV CLASS="center"><TT>disque_centre 20</TT></DIV><P>
Puis
</P><DIV CLASS="center"><TT>recule 40</TT></DIV><P>
Puis on termine l’enregistrement avec :
</P><DIV CLASS="center"><TT>fin_enregistrement("arbre.tor")</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Un fichier arbre.tor qui content les instructions d’une 
procédure qui a comme nom arbre</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>efface;tourne_gauche;</TT></DIV><DIV CLASS="center"><TT>arbre()</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Le dessin de nôtre arbre</TT></DIV><H3 CLASS="subsection"><A NAME="htoc60">2.1.2</A>  Pour terminer l’enregistrement : <TT>fin_enregistrement</TT></H3><P><A NAME="@default57"></A>
<TT>fin_enregistrement</TT> a comme argument une chaine de caractères.<BR>
<TT>fin_enregistrement</TT> sauve la procédure définie par les instructions 
comprises entre <TT>debut_enregistrement</TT> et <TT>fin_enregistrement</TT>
dans le fichier dont le nom est passé en argument de <TT>fin_enregistrement</TT>.<BR>
On tape :
</P><DIV CLASS="center"><TT>debut_enregistrement(arbre)</TT></DIV><P>
Puis on tape les instructions pour définir <TT>arbre</TT>, puis on tape :
</P><DIV CLASS="center"><TT>fin_enregistrement("arbre.tor")</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Le fichier arbre.tor contenant la procédure arbre</TT></DIV><H2 CLASS="section"><A NAME="toc17"></A><A NAME="htoc61">2.2</A>  Faire un dessin en écrivant une procédure</H2><P>
On peut écrire une procédure dans l’éditeur de programmes.<BR>
On tape les instructions pour définir <TT>arbre</TT> par exemple :
</P><PRE CLASS="verbatim">arbre():={
 avance 50;
 disque_centre 20;
 recule 40;
}:;
</PRE><P>Puis on tape :
</P><PRE CLASS="verbatim">tourne_gauche;
dessine_tortue;
arbre()
}:;
</PRE><P>On obtient :
</P><DIV CLASS="center"><TT>Le dessin qui a comme nom arbre : on remarque que la tortue n’est pas revenue à sa position de départ</TT></DIV><DIV CLASS="center"><IMG SRC="castor004.png"></DIV><P>
On tape les instructions pour définir <TT>arbre</TT> avec deux paramètres :
</P><PRE CLASS="verbatim">arbres(a,b):={
 avance a;
 disque_centre b;
 recule 2*b;
}:;
</PRE><P>Puis on tape :
</P><DIV CLASS="center"><TT>efface;tourne_gauche;dessine_tortue;arbres(50,20)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Le dessin précédent </TT></DIV><H2 CLASS="section"><A NAME="toc18"></A><A NAME="htoc62">2.3</A>  Mettre et retrouver des procédures dans un fichier</H2><H3 CLASS="subsection"><A NAME="htoc63">2.3.1</A>  Écrire des procédures dans un fichier : <TT>sauve</TT></H3><P><A NAME="@default58"></A>
<TT>sauve</TT> a comme argument une chaîne de caractères qui est 
le nom d’un fichier et le nom des procédures et des variables que l’on veut 
sauver dans ce fichier.<BR>
<TT>sauve</TT> permet de mettre en mémoire ces procédures dans ce fichier
et donc de pouvoir les réutiliser dans une autre session de travail.<BR>
On tape :
</P><DIV CLASS="center"><TT>sauve("toto.tor",tete,bras)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>le fichier "toto.tor" contenant les procédures tete et bras</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>sauve("toto.tor",tete,bras)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>le fichier "toto.tor"contenant les procédures tete et bras</TT></DIV><H3 CLASS="subsection"><A NAME="htoc64">2.3.2</A>  Utiliser les procédures écrites dans un fichier : <TT>ramene</TT></H3><P><A NAME="@default59"></A>
<TT>ramene</TT> a comme argument une chaîne de caractères qui 
est le nom d’un fichier contenant des procédures agissant sur la tortue.<BR>
<TT>ramene</TT> permet de valider et donc d’utiliser les procédures 
se trouvant dans ce fichier.<BR>
On tape :
</P><DIV CLASS="center"><TT>ramene("toto.tor")</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>la validation des procédures tete et bras</TT></DIV><HR>
<A HREF="castor002.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="castor004.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
