<!DOCTYPE html>
<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.29+5 of 2017-05-18">
<link rel="stylesheet" type="text/css" href="casrouge.css">
<title>Les programmes d’arithmétique</title>
</head>
<body >
<a href="casrouge007.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="casrouge009.html"><img src="next_motif.gif" alt="Next"></a>
<hr>
<h1 id="sec172" class="chapter">Chapitre 8  Les programmes d’arithmétique</h1>
<h2 id="sec173" class="section">8.1  Quotient et reste de la division euclidienne</h2>
<h3 id="sec174" class="subsection">8.1.1  Les fonctions iquo, irem et smod de <span style="font-family:monospace">Xcas</span></h3>
<p><a id="hevea_default78"></a><a id="hevea_default79"></a><a id="hevea_default80"></a><a id="hevea_default81"></a><a id="hevea_default82"></a>
Si <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont des entiers ou des entiers de Gauss :<br>
<span style="font-family:monospace">iquo(a,b)</span> renvoie le quotient <span style="font-style:italic">q</span> de la division euclidienne de <span style="font-style:italic">a</span> par <span style="font-style:italic">b</span> et<br>
<span style="font-family:monospace">irem(a,b)</span> renvoie le reste <span style="font-style:italic">r</span> de la division euclidienne de <span style="font-style:italic">a</span> par <span style="font-style:italic">b</span>.<br>
<span style="font-style:italic">q</span> et <span style="font-style:italic">r</span> vérifient :<br>
si <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont entiers <span style="font-style:italic">a</span>=<span style="font-style:italic">b</span>*<span style="font-style:italic">q</span>+<span style="font-style:italic">r</span> avec 0 ≤ <span style="font-style:italic">r</span>&lt;<span style="font-style:italic">b</span><br>
si <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont des entiers de Gauss <span style="font-style:italic">a</span>=<span style="font-style:italic">b</span>*<span style="font-style:italic">q</span>+<span style="font-style:italic">r</span> avec |<span style="font-style:italic">r</span>|<sup>2</sup>) ≤ |<span style="font-style:italic">b</span>|<sup>2</sup>/2. <br>
Par exemple si <span style="font-style:italic">a</span>=−2+6*<span style="font-style:italic">i</span> et si <span style="font-style:italic">b</span>=1+3*<span style="font-style:italic">i</span> on a :<br>
<span style="font-style:italic">q</span>=2+<span style="font-style:italic">i</span> et <span style="font-style:italic">r</span>=−1−<span style="font-style:italic">i</span><br>
Si <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont des entiers relatifs <span style="font-family:monospace">smod(a,b)</span> renvoie le reste 
symétrique <span style="font-style:italic">rs</span> de la division euclidienne de <span style="font-style:italic">a</span> par <span style="font-style:italic">b</span>.<br>
<span style="font-style:italic">q</span> et <span style="font-style:italic">rs</span> vérifient :<br>
<span style="font-style:italic">a</span>=<span style="font-style:italic">b</span>*<span style="font-style:italic">q</span>+<span style="font-style:italic">rs</span> avec −<span style="font-style:italic">b</span>/2&lt;<span style="font-style:italic">rs</span> ≤ <span style="font-style:italic">b</span>/2<br>
Exemples :<br>
<span style="font-family:monospace">smod(7,4)=-1</span><br>
<span style="font-family:monospace">smod(-10,4)=-2</span><br>
<span style="font-family:monospace">smod(10,4)=2</span><br>
<span style="font-weight:bold">Remarque</span>
<span style="font-family:monospace">mod</span> (ou <span style="font-family:monospace">%</span>) est une fonction infixée et désigne un élément 
de <span style="font-style:italic">Z</span>/<span style="font-style:italic">nZ</span>.<br>
On a : <span style="font-family:monospace">7 mod 4=-1%4</span> désigne un élément de <span style="font-style:italic">Z</span>/4<span style="font-style:italic">Z</span> mais<br>
<span style="font-family:monospace">smod(7,4)=(7%4)%0=-1</span> désigne un entier.
</p>
<h3 id="sec175" class="subsection">8.1.2  Activité</h3>
<h4 id="sec176" class="subsubsection">le texte de l’exercice</h4>
<ol class="enumerate" type=1><li class="li-enumerate">
Vérifier que : 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">13</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">18</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">45</td></tr>
</table></td></tr>
</table>
</li><li class="li-enumerate">On donne deux entiers <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> vérifiant : 0&lt;<span style="font-style:italic">b</span> &lt;<span style="font-style:italic">a</span>.
On note <span style="font-style:italic">q</span> et <span style="font-style:italic">r</span> le quotient et le reste de la division euclidienne de <span style="font-style:italic">a</span> 
par <span style="font-style:italic">b</span> (<span style="font-style:italic">a</span>=<span style="font-style:italic">bq</span>+<span style="font-style:italic">r</span> avec 0≤ <span style="font-style:italic">r</span>&lt;<span style="font-style:italic">b</span>).<p>Démontrer que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">q</span>&gt;0</td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">q</span>+1</td></tr>
</table></td><td class="dcell">&lt;</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">q</span></td></tr>
</table></td></tr>
</table></li><li class="li-enumerate">On définit <span style="font-style:italic">u</span> et <span style="font-style:italic">v</span> par :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">q</span>+1</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span></td></tr>
</table></td></tr>
</table> et
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span>=<span style="font-style:italic">a</span>(<span style="font-style:italic">q</span>+1)</td></tr>
</table>
Exprimer <span style="font-style:italic">v</span> en fonction de <span style="font-style:italic">b</span> et <span style="font-style:italic">r</span>.<p>Démontrer que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span>≤ <span style="font-style:italic">b</span>&lt;<span style="font-style:italic">a</span>&lt;<span style="font-style:italic">u</span></td></tr>
</table><p>
Si <span style="font-style:italic">r</span>=0, vérifier que : </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">q</span></td></tr>
</table></td></tr>
</table></li><li class="li-enumerate">Si <span style="font-style:italic">r</span> est différent de zéro, on pose :
<span style="font-style:italic">a</span><sub>1</sub>=<span style="font-style:italic">u</span> et <span style="font-style:italic">b</span><sub>1</sub>=<span style="font-style:italic">v</span>.<p>Puis, on recommence :
on divise <span style="font-style:italic">a</span><sub>1</sub> par <span style="font-style:italic">b</span><sub>1</sub>. <br>
On trouve un quotient <span style="font-style:italic">q</span><sub>1</sub> et un reste <span style="font-style:italic">r</span><sub>1</sub>.Si <span style="font-style:italic">r</span><sub>1</sub>  est nul, vérifier 
que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">q</span>+1</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">q</span><sub>1</sub></td></tr>
</table></td></tr>
</table><p>
Si <span style="font-style:italic">r</span><sub>1</sub> n’est pas nul, on recommence.</p><p>Montrer qu’il existe une suite finie d’entiers <span style="font-style:italic">Q</span><sub>0</sub>, <span style="font-style:italic">Q</span><sub>1</sub>,...<span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> strictement 
croissante telle que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span><sub>0</sub></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span><sub>1</sub></td></tr>
</table></td><td class="dcell">+...+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></li><li class="li-enumerate">Rédiger l’algorithme décrit ici et l’appliquer à la fraction : <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">151</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">221</td></tr>
</table></td></tr>
</table>
</li></ol>
<h4 id="sec177" class="subsubsection">L’algorithme</h4>
<p>
On suppose que la fraction <span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">NUM</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">DENOM</span></span><span style="font-family:monospace">∈]0;1[</span>.</p><p>L’algorithme s’écrit en langage non fonctionnel :<br>
<span style="font-family:monospace">DENOM </span>→<span style="font-family:monospace">A<br>
NUM</span>→<span style="font-family:monospace">B<br>
Quotient(A, B)</span>→<span style="font-family:monospace">Q<br>
Reste(A, B)</span>→<span style="font-family:monospace">R<br>
tantque R </span>≠<span style="font-family:monospace">0 faire <br>
Q+1</span>→<span style="font-family:monospace">D<br>
Afficher D<br>
B-R</span>→<span style="font-family:monospace">B<br>
A*D</span>→<span style="font-family:monospace">A<br>
Quotient(A, B)</span>→<span style="font-family:monospace">Q<br>
Reste(A, B)</span>→<span style="font-family:monospace">R<br>
ftantque<br>
Afficher Q<br>
</span>
</p>
<h4 id="sec178" class="subsubsection">Traduction Xcas</h4>
<p>
On écrit la fonction <span style="font-family:monospace">decomp</span> qui va décomposer selon l’algorithme la 
fraction <span style="font-family:monospace">frac</span>. Cette fonction va renvoyer la liste <span style="font-family:monospace">lres</span> égale 
à <span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">Q</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,..</span><span style="font-family:monospace"><span style="font-style:italic">Q</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub><span style="font-family:monospace">]</span> avec <span style="font-family:monospace">0&lt;</span><span style="font-family:monospace"><span style="font-style:italic">Q</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">&lt;,..&lt;</span><span style="font-family:monospace"><span style="font-style:italic">Q</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub> et 
<span style="font-family:monospace"><span style="font-style:italic">frac</span></span><span style="font-family:monospace">=1/</span><span style="font-family:monospace"><span style="font-style:italic">Q</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">+..+1/</span><span style="font-family:monospace"><span style="font-style:italic">Q</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub>.<br>
Attention <span style="font-family:monospace">frac=b/a</span> et donc <span style="font-family:monospace">fxnd(frac)=fxnd(b/a)=[b,a]</span>.
</p><pre class="verbatim">decomp(frac):={
local a,b,l,q,r,lres;
l:=fxnd(frac);
b:=l[0];
a:=l[1];
q:=iquo(a,b);
r:=irem(a,b);
lres:=[];
while (r!=0) {
lres:= concat(lres, q+1);
b:=b-r;
a:=a*(q+1);
q:=iquo(a,b);
r:=irem(a,b);
}
lres:=concat(lres,q);
return lres;
}
</pre>
<h4 id="sec179" class="subsubsection">Application à 151/221</h4>
<p>
On tape :<br>
<span style="font-family:monospace">decomp(151/221)</span><br>
On obtient :<br>
<span style="font-family:monospace">[2,6,61,5056,40895962,4181199228867648]</span><br>
On vérifie :<br>
<span style="font-family:monospace">1/2+1/6+1/61+1/5056+1/40895962+1/4181199228867648</span><br>
On obtient :<br>
<span style="font-family:monospace">151/221</span><br>
On peut écrire un programme pour faire le vérification :<br>
<span style="font-family:monospace">size(l)</span> est égal à la longueur de la liste <span style="font-family:monospace">l</span>
</p><pre class="verbatim">verifie(l):={
local s,k,res;
s:=size(l);
res:=0;
for (k:=0;k&lt;s;k++){
res:=res+1/l[k];
}
return res;
}
</pre><p>
On tape :<br>
<span style="font-family:monospace">verifie([2,6,61,5056,40895962,4181199228867648])</span><br>
On obtient :<br>
<span style="font-family:monospace">151/221</span></p>
<h2 id="sec180" class="section">8.2  Calcul du PGCD par l’algorithme d’Euclide</h2>
<p>
Soient <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> deux entiers positifs dont on cherche le <span style="font-style:italic">PGCD</span>.<br>
L’algorithme d’Euclide est basé sur la définition récursive du <span style="font-style:italic">PGCD</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,0)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">A</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">PGCD</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">A</span>  mod  <span style="font-style:italic">B</span>)   <span style="font-style:italic">si</span>   <span style="font-style:italic">B</span> ≠ 0
</td></tr>
</table></td></tr>
</table><p>
où <span style="font-style:italic">A</span> mod <span style="font-style:italic">B</span> désigne le reste de la division euclidienne de <span style="font-style:italic">A</span> par <span style="font-style:italic">B</span>.<br>
Voici la description de cet algorithme :<br>
on effectue des divisions euclidiennes successives :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">A</span>=</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span> × <span style="font-style:italic">Q</span><sub>1</sub>+<span style="font-style:italic">R</span><sub>1</sub></td><td style="text-align:left;white-space:nowrap" >0 ≤ <span style="font-style:italic">R</span><sub>1</sub> &lt; <span style="font-style:italic">B</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">B</span>=</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span><sub>1</sub> × <span style="font-style:italic">Q</span><sub>2</sub>+<span style="font-style:italic">R</span><sub>2</sub></td><td style="text-align:left;white-space:nowrap" >0 ≤ <span style="font-style:italic">R</span><sub>2</sub> &lt; <span style="font-style:italic">R</span><sub>1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">R</span><sub>1</sub>=</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span><sub>2</sub> × <span style="font-style:italic">Q</span><sub>3</sub>+<span style="font-style:italic">R</span><sub>3</sub></td><td style="text-align:left;white-space:nowrap" >0 ≤ <span style="font-style:italic">R</span><sub>3</sub> &lt; <span style="font-style:italic">R</span><sub>2</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >.......
</td></tr>
</table></td></tr>
</table><p>
Après un nombre fini d’étapes, il existe un entier n tel que : 
<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub> = 0. <br>
on a alors :<br>
<span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>)= <span style="font-style:italic">PGCD</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">R</span><sub>1</sub>) =...<br>
<span style="font-style:italic">PGCD</span>(<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>) = <span style="font-style:italic">PGCD</span>(<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span>−1</sub>,0) = <span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span>−1</sub>
</p>
<h3 id="sec181" class="subsection">8.2.1  Traduction algorithmique</h3>
<p>
-Version itérative<br>
Si <span style="font-style:italic">B</span>≠ 0 on calcule <span style="font-style:italic">R</span>=<span style="font-style:italic">A</span> mod<span style="font-style:italic">B</span>, puis avec <span style="font-style:italic">B</span> dans le rôle 
de <span style="font-style:italic">A</span> (en mettant <span style="font-style:italic">B</span> dans <span style="font-style:italic">A</span> ) et <span style="font-style:italic">R</span> dans le rôle de <span style="font-style:italic">B</span> ( en mettant 
<span style="font-style:italic">R</span> dans <span style="font-style:italic">B</span>) on recommence jusqu’à ce que <span style="font-style:italic">B</span>=0, le <span style="font-style:italic">PGCD</span> est alors égal
à <span style="font-style:italic">A</span>.
</p><pre class="verbatim">fonction PGCD(A,B)
local R
</pre><p>
<span style="font-family:monospace">tantque B </span>≠<span style="font-family:monospace"> 0 faire</span>
</p><pre class="verbatim">  A mod B=&gt;R
  B=&gt;A
  R=&gt;B
ftantque
retourne A
ffonction
</pre><p>-Version récursive<br>
On écrit simplement la définition récursive vue plus haut.
</p><pre class="verbatim">fonction PGCD(A,B)
</pre><p>
<span style="font-family:monospace">Si B </span>≠<span style="font-family:monospace"> 0 alors</span>
</p><pre class="verbatim">  retourne PGCD(B,A mod B) 
  sinon
  retourne A
fsi
ffonction
</pre>
<h3 id="sec182" class="subsection">8.2.2  Traduction Xcas</h3>
<p>
- Version itérative :
</p><pre class="verbatim">pgcd(a,b):={
  local r; 
  while (b!=0){
   r:=irem(a,b);
   a:=b;
   b:=r;
  } 
  return(a);
};
</pre><p>
- Version récursive.
</p><pre class="verbatim">pgcdr(a,b):={
  if (b==0) 
    return(a);
  else 
    return(pgcdr(b,irem(a,b)));
};
</pre>
<h3 id="sec183" class="subsection">8.2.3  Traduction MapleV</h3>
<p>
-Version itérative :
</p><pre class="verbatim">pgcd:=proc(x,y)
local a,b,r:
a:=x:
b:=y:
while (b&gt;0) do
r:=irem(a,b):
a:=b:
b:=r:
od:
RETURN(a):
end:
</pre><p>-Version récursive :
</p><pre class="verbatim">pgcd:=proc(a,b)
if (b=0) then
RETURN(a)
 else 
RETURN(pgcd(b,irem(a,b))):
fi:
end:
</pre>
<h3 id="sec184" class="subsection">8.2.4  Traduction MuPAD</h3>
<p>
-Version itérative :
</p><pre class="verbatim">pgcd:=proc(a,b)
local r:
begin
while (b&gt;0) do
r:=a mod b:
a:=b:
b:=r:
end_while:
return(a):
end_proc;
</pre><p>-Version récursive :
</p><pre class="verbatim">pgcd:=proc(a,b)
begin
if (b=0) then
 return(a)
 else 
return(pgcd(b,a mod b)):
end_if:
end_proc;
</pre>
<h3 id="sec185" class="subsection">8.2.5  Traduction TI89 92</h3>
<p>
-Version itérative
</p><pre class="verbatim">:pgcd(a,b)
:Func 
:Local r
</pre><p>
<span style="font-family:monospace">:While b </span>≠<span style="font-family:monospace"> 0 </span>
</p><pre class="verbatim">:mod(a,b)=&gt;r
:b=&gt;a
:r=&gt;b
:EndWhile
:Return a
:EndFunc
</pre><p>-Version récursive
</p><pre class="verbatim">:pgcd(a,b)
:Func 
</pre><p>
<span style="font-family:monospace">:If b </span>≠<span style="font-family:monospace"> 0 Then</span>
</p><pre class="verbatim">:Return  pgcd(b, mod(a,b)) 
:Else
:Return a
:EndIf
:EndFunc
</pre>
<h3 id="sec186" class="subsection">8.2.6  Le pgcd dans ℤ[<span style="font-style:italic">i</span>]</h3>
<p>
On rappelle que ℤ[<span style="font-style:italic">i</span>]={<span style="font-style:italic">m</span>+<span style="font-style:italic">n</span>*<span style="font-style:italic">i</span>, (<span style="font-style:italic">m</span>,<span style="font-style:italic">n</span>)∈ ℤ<sup>2</sup>}.<br>
Soient <span style="font-style:italic">a</span> ∈ ℤ[<span style="font-style:italic">i</span>] et <span style="font-style:italic">b</span> ∈ ℤ[<span style="font-style:italic">i</span>]−{0}, alors on dit que le quotient <span style="font-style:italic">q</span>
de <span style="font-style:italic">a</span> par <span style="font-style:italic">b</span> est l’affixe du (ou des) point(s), le plus proche pour le 
module, du point d’affixe <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>.
</p><ul class="itemize"><li class="li-itemize">
Montrer que |<span style="font-style:italic">q</span>−<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>|<sup>2</sup> ≤ 1/2. En déduire que |<span style="font-style:italic">a</span>−<span style="font-style:italic">bq</span>|<sup>2</sup> ≤ |<span style="font-style:italic">b</span>|<sup>2</sup>/2
et que l’algorithme d’Euclide se termine lorsqu’on prend <span style="font-style:italic">q</span> comme quotient 
euclidien.
</li><li class="li-itemize">Écrire un programme qui calcule le pgcd de 2 nombres de ℤ[<span style="font-style:italic">i</span>]. On 
normalisera le résultat (en multipliant le résultat par 1,-1,i ou -i)
pour que le pgcd soit un nombre de partie rèelle 
strictement positive et de partie imaginaire positive ou nulle.
</li></ul><p>
On tape :
</p><pre class="verbatim">quotient(a,b):={
local q1,q2,c;
c:=normal(a/b);
q1:=re(c);
q2:=im(c);
return round(q1)+i*round(q2);
}:;
pgcdzi(a,b):={
local q,r;
tantque b!=0 faire
  q:=quotient(a,b);
  r:=a-b*q;
  a:=b;
  b:=r;
ftantque;
//on normalise
si re(a)&lt;0 et im(a)&lt;=0 alors retourne -a;fsi;
si im(a)&lt;0 alors retourne i*a;fsi;
si re(a)&lt;=0 alors retourne -i*a;fsi;
retourne a;
}:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">pgcdzi(3+i,3-i)</span><br>
On obtient :
<span style="font-family:monospace">1+i</span><br>
On tape :<br>
<span style="font-family:monospace">pgcdzi(7+i,-6+17*i)</span><br>
On obtient :
<span style="font-family:monospace">3+4*i</span>
</p>
<h3 id="sec187" class="subsection">8.2.7  Le pgcd dans ℤ[<span style="font-style:italic">i</span>√<span style="text-decoration:overline">2</span>]</h3>
<p>
On rappelle que ℤ[<span style="font-style:italic">i</span>√<span style="text-decoration:overline">2</span>]={<span style="font-style:italic">m</span>+<span style="font-style:italic">i</span>*<span style="font-style:italic">n</span>√<span style="text-decoration:overline">2</span>, (<span style="font-style:italic">m</span>,<span style="font-style:italic">n</span>)∈ ℤ<sup>2</sup>}.<br>
Soient <span style="font-style:italic">a</span> ∈ ℤ[<span style="font-style:italic">i</span>√<span style="text-decoration:overline">2</span>] et <span style="font-style:italic">b</span> ∈ ℤ[<span style="font-style:italic">i</span>√<span style="text-decoration:overline">2</span>]−{0}, alors on dit que le 
quotient <span style="font-style:italic">q</span> de <span style="font-style:italic">a</span> par <span style="font-style:italic">b</span> est l’affixe du (ou des) point(s), le plus proche 
pour le module, du point d’affixe <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>.
On tape :
</p><pre class="verbatim">quorest(a,b):={
local q1,q2,q,r,c;
c:=normal(a/b);
q1:=normal(round(re(c)));
q2:=normal(round(im(c)/sqrt(2)));
q:= q1+i*q2*sqrt(2);
r:=simplify(a-b*q);
return q,r;
}:;
pgcdzis2(a,b):={
local r;
tantque b!=0 faire
  r:=quorest(a,b)[1];
  a:=b;
  b:=r;
ftantque;
//on normalise
si re(a)&lt;0  alors retourne -a;fsi;
retourne a;
}:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">pgcdzis2(3+i*sqrt(2),3-i*sqrt(2))</span><br>
On obtient :
<span style="font-family:monospace">1</span><br>
On tape :<br>
<span style="font-family:monospace">pgcdzis2(4+5*i*sqrt(2),-2+3*i*sqrt(2))</span><br>
On obtient :
<span style="font-family:monospace">2-(3*i)*sqrt(2)</span></p>
<h2 id="sec188" class="section">8.3  Identité de Bézout par l’algorithme d’Euclide</h2>
<p>
Dans ce paragraphe la fonction <span style="font-family:monospace">Bezout(A,B)</span> renvoie la liste {<span style="font-style:italic">U</span>, <span style="font-style:italic">V</span>, <span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>)}
où <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> vérifient :
 <span style="font-style:italic">A</span> × <span style="font-style:italic">U</span> + <span style="font-style:italic">B</span> × <span style="font-style:italic">V</span> = <span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>) 
</p>
<h3 id="sec189" class="subsection">8.3.1  Version itérative sans les listes</h3>
<p>
L’algorithme d’Euclide permet aussi de trouver un couple <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> 
vérifiant:</p><p> <span style="font-style:italic">A</span> × <span style="font-style:italic">U</span> + <span style="font-style:italic">B</span> × <span style="font-style:italic">V</span>= <span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>) </p><p>En effet, si on note  <span style="font-style:italic">A</span><sub>0</sub> et <span style="font-style:italic">B</span><sub>0</sub>  les valeurs de <span style="font-style:italic">A</span> et de <span style="font-style:italic">B</span> du début on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">A</span></td><td style="text-align:center;white-space:nowrap" >=<span style="font-style:italic">A</span><sub>0</sub> × <span style="font-style:italic">U</span>+<span style="font-style:italic">B</span><sub>0</sub> × <span style="font-style:italic">V</span>    avec   <span style="font-style:italic">U</span>=1  <span style="font-style:italic">et</span>  <span style="font-style:italic">V</span>=0 </td></tr>
<tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">B</span></td><td style="text-align:center;white-space:nowrap" >=<span style="font-style:italic">A</span><sub>0</sub> × <span style="font-style:italic">W</span>+<span style="font-style:italic">B</span><sub>0</sub> × <span style="font-style:italic">X</span>    avec   <span style="font-style:italic">W</span>=0  <span style="font-style:italic">et</span>   <span style="font-style:italic">X</span>=1 
</td></tr>
</table></td></tr>
</table><p>Puis on fait évoluer <span style="font-style:italic">A</span>, <span style="font-style:italic">B</span>, <span style="font-style:italic">U</span>, <span style="font-style:italic">V</span>, <span style="font-style:italic">W</span>, <span style="font-style:italic">X</span> de façon à ce que ces 
deux relations soient toujours vérifiées. Voici comment
<span style="font-style:italic">A</span>, <span style="font-style:italic">B</span>, <span style="font-style:italic">U</span>, <span style="font-style:italic">V</span>, <span style="font-style:italic">W</span>, <span style="font-style:italic">X</span> évoluent :<br>
- on pose :
 <span style="font-style:italic">A</span>=<span style="font-style:italic">B</span> × <span style="font-style:italic">Q</span>+<span style="font-style:italic">R</span>     0 ≤ <span style="font-style:italic">R</span> &lt; <span style="font-style:italic">B</span>   ( <span style="font-style:italic">R</span> = <span style="font-style:italic">A</span> mod <span style="font-style:italic">B</span>  <span style="font-style:italic">et</span>   <span style="font-style:italic">Q</span> = <span style="font-style:italic">E</span>(<span style="font-style:italic">A</span> / <span style="font-style:italic">B</span> )) <br>
- on écrit alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">R</span>=<span style="font-style:italic">A</span>−<span style="font-style:italic">B</span> × <span style="font-style:italic">Q</span>=<span style="font-style:italic">A</span><sub>0</sub> × (<span style="font-style:italic">U</span>−<span style="font-style:italic">W</span> × <span style="font-style:italic">Q</span>)+<span style="font-style:italic">B</span><sub>0</sub> × (<span style="font-style:italic">V</span>−<span style="font-style:italic">X</span> × <span style="font-style:italic">Q</span>)=<span style="font-style:italic">A</span><sub>0</sub> × <span style="font-style:italic">S</span>+<span style="font-style:italic">B</span><sub>0</sub> × <span style="font-style:italic">T</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >avec   <span style="font-style:italic">S</span>=<span style="font-style:italic">U</span>−<span style="font-style:italic">W</span> × <span style="font-style:italic">Q</span>   et    <span style="font-style:italic">T</span>=<span style="font-style:italic">V</span>−<span style="font-style:italic">X</span> × <span style="font-style:italic">Q</span>
</td></tr>
</table></td></tr>
</table><p>
Il reste alors à recommencer avec <span style="font-style:italic">B</span> dans le rôle de <span style="font-style:italic">A</span> (<span style="font-family:monospace">B=&gt;A  W=&gt;U  X=&gt;V</span>) et <span style="font-style:italic">R</span> dans le rôle de <span style="font-style:italic">B</span> (<span style="font-family:monospace">R=&gt;B  S=&gt;W  T=&gt;X</span> ) d’où l’algorithme:
</p><pre class="verbatim">fonction Bezout(A,B)
local U,V,W,X,S,T,Q,R
1=&gt;U 0=&gt;V 0=&gt;W 1=&gt;X
</pre><p>
<span style="font-family:monospace">tantque B </span>≠<span style="font-family:monospace"> 0 faire</span>
</p><pre class="verbatim">A mod B=&gt;R 
E(A/B)=&gt;Q
//R=A-B*Q
U-W*Q=&gt;S
V-X*Q=&gt;T
B=&gt;A W=&gt;U X=&gt;V
R=&gt;B S=&gt;W T=&gt;X
ftantque
retourne {U, V, A}
ffonction
</pre>
<h3 id="sec190" class="subsection">8.3.2  Version itérative avec les listes</h3>
<p>
On peut simplifier l’écriture de l’algorithme ci-dessus en utilisant moins de
variables : pour cela on utilise les listes <span style="font-style:italic">LA</span>, <span style="font-style:italic">LB</span>, <span style="font-style:italic">LR</span> pour mémoriser 
les triplets {<span style="font-style:italic">U</span>, <span style="font-style:italic">V</span>, <span style="font-style:italic">A</span>}, {<span style="font-style:italic">W</span>, <span style="font-style:italic">X</span>, <span style="font-style:italic">B</span>} et {<span style="font-style:italic">S</span>, <span style="font-style:italic">T</span>, <span style="font-style:italic">R</span>}.
Ceci est très commode car les logiciels de calcul savent ajouter des listes 
de même longueur (en ajoutant les éléments de même indice) et savent 
aussi multiplier une liste par un nombre (en multipliant chacun des 
éléments de la liste par ce nombre).<br>
</p><pre class="verbatim">fonction Bezout(A,B)
local LA LB LR
{1, 0, A}=&gt;LA
{0, 1, B}=&gt;LB
</pre><p>
<span style="font-family:monospace">tantque LB[3] </span>≠<span style="font-family:monospace"> 0 faire</span>
</p><pre class="verbatim">LA-LB*E(LA[3]/LB[3])=&gt;LR 
LB=&gt;LA 
LR=&gt;LB 
ftantque
retourne LA
ffonction
</pre>
<h3 id="sec191" class="subsection">8.3.3  Version récursive sans les listes</h3>
<p><a id="sec:recsl"></a>
Si on utilise des variables globales pour <span style="font-family:monospace">A, B, D, U, V, T</span>, on peut voir 
la fonction <span style="font-family:monospace">Bezout</span> comme calculant à partir de <span style="font-family:monospace">A B</span>, des valeurs 
qu’elle met dans <span style="font-family:monospace">U, V, D (AU+BV=D)</span>, grâce à une variable locale 
<span style="font-family:monospace">Q</span>.<br>
On écrit donc une fonction sans paramètre : seule la variable <span style="font-family:monospace">Q</span> doit être locale à la foncton alors que les autres variables <span style="font-family:monospace">A, B ...</span> 
sont globales.<br>
<span style="font-family:monospace">Bezout</span> fabrique <span style="font-family:monospace">U, V, D</span> vérifiant <span style="font-family:monospace">A*U+B*V=D</span> à partir de <span style="font-family:monospace">A</span> et <span style="font-family:monospace">B</span>.
Avant l’appel récursif (on présérve <span style="font-family:monospace">E(A/B)=Q</span> et on met <span style="font-family:monospace">A</span> et 
<span style="font-family:monospace">B</span> à jour ( nouvelles valeurs), après l’appel les variables <span style="font-family:monospace">U, V, D</span> vérifient 
<span style="font-family:monospace">A*U+B*V=D</span> (avec <span style="font-family:monospace">A</span> et <span style="font-family:monospace">B</span> les nouvelles valeurs), il suffit 
alors de revenir aux premières valeurs de
<span style="font-family:monospace">A</span> et <span style="font-family:monospace">B</span> en écrivant :<br>
<span style="font-family:monospace">B*U+(A-B*Q)*V=A*V+B*(U-V*Q)</span> <br>
On écrit alors :
</p><pre class="verbatim">fonction Bezout
local Q 
Si B != 0 faire
E(A/B)=&gt;Q
A-B*Q=&gt;R
B=&gt;A
R=&gt;B
Bezout
U-V*Q=&gt;W
V=&gt;U
W=&gt;V
sinon 
1=&gt;U
0=&gt;V
A=&gt;D
fsi
ffonction
</pre>
<h3 id="sec192" class="subsection">8.3.4  Version récursive avec les listes</h3>
<p>
On peut définir récursivement la fonction Bezout par:</p><p> <span style="font-style:italic">Bezout</span>(<span style="font-style:italic">A</span>,0)={1, 0, <span style="font-style:italic">A</span>}  </p><p>Si  <span style="font-style:italic">B</span> ≠ 0  il faut définir  <span style="font-style:italic">Bezout</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>) en fonction de  <span style="font-style:italic">Bezout</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">R</span>) 
lorsque  <span style="font-style:italic">R</span>=<span style="font-style:italic">A</span>−<span style="font-style:italic">B</span> × <span style="font-style:italic">Q</span> et <span style="font-style:italic">Q</span>=<span style="font-style:italic">E</span>(<span style="font-style:italic">A</span>/<span style="font-style:italic">B</span>).</p><p>On a:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">Bezout</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">R</span>)=<span style="font-style:italic">LT</span>={<span style="font-style:italic">W</span>, <span style="font-style:italic">X</span>, <span style="font-style:italic">pgcd</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">R</span>)} </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >avec  <span style="font-style:italic">W</span> × <span style="font-style:italic">B</span>+<span style="font-style:italic">X</span> × <span style="font-style:italic">R</span>=<span style="font-style:italic">pgcd</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">R</span>)
</td></tr>
</table></td></tr>
</table><p>
Donc:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">W</span> × <span style="font-style:italic">B</span>+<span style="font-style:italic">X</span> × (<span style="font-style:italic">A</span>−<span style="font-style:italic">B</span> × <span style="font-style:italic">Q</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">pgcd</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">R</span>)   ou encore </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">X</span> × <span style="font-style:italic">A</span>+(<span style="font-style:italic">W</span>−<span style="font-style:italic">X</span> × <span style="font-style:italic">Q</span>) × <span style="font-style:italic">B</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">pgcd</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>).
</td></tr>
</table></td></tr>
</table><p>
D’où si <span style="font-style:italic">B</span> ≠ 0 et si  <span style="font-style:italic">Bezout</span>(<span style="font-style:italic">B</span>,<span style="font-style:italic">R</span>)=<span style="font-style:italic">LT</span> on a :</p><p> <span style="font-style:italic">Bezout</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>)={<span style="font-style:italic">LT</span>[2], <span style="font-style:italic">LT</span>[1]−<span style="font-style:italic">LT</span>[2] × <span style="font-style:italic">Q</span>, <span style="font-style:italic">LT</span>[3]}.</p><pre class="verbatim">fonction Bezout(A,B)
local LT Q R
</pre><p>
<span style="font-family:monospace">Si B </span>≠<span style="font-family:monospace"> 0 faire</span>
</p><pre class="verbatim">E(A/B)=&gt;Q
A-B*Q=&gt;R
Bezout(B,R)=&gt;LT
retourne {LT[2], LT[1]-LT[2]*Q, LT[3]}
sinon retourne {1, 0, A} 
fsi
ffonction
</pre>
<h3 id="sec193" class="subsection">8.3.5  Traduction Xcas</h3>
<p><a id="sec:bezout"></a>
- Version itérative avec les listes
</p><pre class="verbatim">bezout(a,b):={
//renvoie [u,v,d] tels que a*u+b*v=pgcd(a,b) (fct iterative)
local la,lb,lr,q,lb2;
la:=[1,0,eval(a)];
lb:=[0,1,eval(b)];
lb2:=eval(b);
while (lb2 !=0){
q:=iquo(la[2],lb2);
lr:=la+(-q)*lb;
la:=lb;
lb:=lr;
lb2:=lb[2];
}
return(la);
};
</pre><p>
- Version récursive avec les listes
</p><pre class="verbatim">bezoutr(a,b):={
//renvoie [u,v,d] tels que a*u+b*v=pgcd(a,b) (fct recursive)
local lb,q,r;
if (b!=0) {
q:=iquo(a,b);
r:=irem(a,b);
lb:=bezoutr(b,r);
return([lb[1],lb[0]+(-q)*lb[1],lb[2]]);
} else 
return([1,0,a]);
};
</pre>
<h2 id="sec194" class="section">8.4  Décomposition en facteurs premiers d’un entier</h2>
<p>
Dans cette section, on ne suppose pas connue une table de nombres premiers : 
on ne se sert donc pas du programme crible.
</p>
<h3 id="sec195" class="subsection">8.4.1  Les algorithmes et leurs traductions algorithmiques</h3>
<ul class="itemize"><li class="li-itemize">
Premier algorithme<br>
Soit <span style="font-style:italic">N</span> un entier.<br>
On teste, pour tous les nombres <span style="font-style:italic">D</span> de 2 à <span style="font-style:italic">N</span>, la divisibilité de <span style="font-style:italic">N</span> par 
<span style="font-style:italic">D</span>.<br>
Si <span style="font-style:italic">D</span> divise <span style="font-style:italic">N</span>, on cherche alors les diviseurs de <span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> etc...<span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> joue le 
rôle de <span style="font-style:italic">N</span> et on s’arrête quand <span style="font-style:italic">N</span>=1 <br>
On met les diviseurs trouvés dans la liste <span style="font-family:monospace">FACT</span>.<pre class="verbatim">fonction factprem(N)
local D FACT 
2 =&gt; D
{} =&gt; FACT
tantque N&lt;= 1 faire
si N mod D = 0 alors
   concat(FACT,D) =&gt; FACT
    N/D =&gt; N
   sinon
    D+1 =&gt; D
 fsi
ftantque
retourne FACT
ffonction
</pre></li><li class="li-itemize">Première amélioration<br>
On ne teste que les diviseurs <span style="font-style:italic">D</span> entre 2 et <span style="font-style:italic">E</span>(√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>).<br>
En effet si <span style="font-style:italic">N</span>=<span style="font-style:italic">D</span>1*<span style="font-style:italic">D</span>2 alors on a :<br>
soit <span style="font-style:italic">D</span>1 ≤ <span style="font-style:italic">E</span>(√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>), soit <span style="font-style:italic">D</span>2 ≤ <span style="font-style:italic">E</span>(√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>) car sinon on aurait :<br>
<span style="font-style:italic">D</span>1*<span style="font-style:italic">D</span>2 ≥ (<span style="font-style:italic">E</span>(√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>)+1)<sup>2</sup> &gt;<span style="font-style:italic">N</span>.<pre class="verbatim">fonction factprem1(N)
local D FACT
2 =&gt; D
{} =&gt; FACT
tantque D*D!= N faire
si N mod D = 0 alors
    concat(FACT,D) =&gt; FACT
    N/D=&gt; N
   sinon
    D+1 =&gt; D
 fsi
ftantque
concat(FACT,N) =&gt; FACT
retourne FACT
ffonction
</pre><p>
Dans la liste <span style="font-family:monospace">FACT</span>, on a les diviseurs premiers éventuellement 
plusieurs fois, par exemple :<br>
<span style="font-family:monospace">factprem1(12)={2,2,3}</span>.
</p></li><li class="li-itemize">Deuxième amélioration<br>
On cherche si 2 divise <span style="font-style:italic">N</span>, puis on teste les diviseurs impairs <span style="font-style:italic">D</span> entre 3 et 
<span style="font-style:italic">E</span>(√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>).<p>Dans la liste <span style="font-family:monospace">FACT</span>, on fait suivre chaque diviseur premier par son 
exposant, par exemple :<br>
<span style="font-family:monospace">factprem2(12)={2,2,3,1}</span>.
</p><pre class="verbatim">fonction  facprem2(N)
local K D FACT
{}=&gt;FACT
0 =&gt; K
tantque N mod 2 == 0 faire
    K+1 =&gt; K
    N/2 =&gt; N
ftantque
si K !=0 alors
    concat(FACT,{2 K}) =&gt; FACT
fsi
3 =&gt;D
tantque D*D&lt;= N faire
    0 =&gt; K
    tantque N mod D = 0 faire
      K+1 =&gt; K
      N/D =&gt; N
    ftantque
    si K !=0 alors
      concat(FACT,{D K})=&gt; FACT
    fsi
     D+2 =&gt; D
ftantque
si N != 1 alors
    concat(FACT,{N 1})=&gt; FACT
fsi
retourne FACT
ffonction
</pre></li><li class="li-itemize">Troisième amélioration<br>
On cherche si 2 et 3 divisent <span style="font-style:italic">N</span>, puis on teste les diviseurs <span style="font-style:italic">D</span> entre 5 et 
<span style="font-style:italic">E</span>(√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>) de la forme 6*<span style="font-style:italic">k</span>−1 ou 6*<span style="font-style:italic">k</span>+1.<br>
On remarque que si :<br>
 <span style="font-style:italic">D</span>=6*<span style="font-style:italic">k</span>−1 on a <span style="font-style:italic">D</span>+(4*<span style="font-style:italic">D</span> mod6)= 6*<span style="font-style:italic">k</span>+1<br>
 et que si :<br>
 <span style="font-style:italic">D</span>=6*<span style="font-style:italic">k</span>+1 on a <span style="font-style:italic">D</span>+(4*<span style="font-style:italic">D</span> mod6)=6*(<span style="font-style:italic">k</span>+1)−1<br>
Dans la liste <span style="font-family:monospace">FACT</span>, on fait suivre chaque diviseur par son exposant,
par exemple :<br>
<span style="font-family:monospace">factprem3(12)={2,2,3,1}</span>.
<pre class="verbatim">fonction  factprem3(N)
local J,D,FACT 
2=&gt;D
{}=&gt;FACT
tantque (D*D&lt;=N) faire
 0=&gt;J
 tantque (N mod D=0) faire
   N/D=&gt;N
   J+1=&gt;J
 ftantque
si (J!= 0) alors concat(FACT,{D,J})=&gt;FACT fsi
 si (D&lt;4) alors 
   2*D-1=&gt;D
 sinon
   D+(4*D mod 6)=&gt;D
 fsi
ftantque
si (N !=1) alors concat(FACT,{N,1})=&gt;FACT fsi
retourne(FACT)
ffonction
</pre> 
</li></ul>
<h3 id="sec196" class="subsection">8.4.2  Traduction Xcas</h3>
<p><a id="sec:factprem"></a>
On traduit la troisième amélioration.
</p><pre class="verbatim">factprem(n):={
//decompose n en facteur premier dans la liste l de dimension s
local j,d,s,l;
d:=2;
s:=0;
l:=[];
while (d*d&lt;=n) {
j:=0;
while (irem(n,d)==0){
n:=iquo(n,d);
j:=j+1;
}
if (j!=0) {
l:=concat(l,[d,j]);
s:=s+2;
}
if (d&lt;4) {
d:=2*d-1;
}
else {
d:=d+irem(4*d,6);
}
}
if (n!=1) {
l:=concat(l,[n,1]);
s:=s+2;
}
return([l,s]);
};
</pre>
<h2 id="sec197" class="section">8.5  Décomposition en facteurs premiers en utilisant le crible</h2>
<p>
Pour effectuer la décomposition en facteurs premiers de <span style="font-style:italic">n</span>, on utilise la 
table des nombres premiers fabriquée par le crible : on ne teste ainsi que 
des nombres premiers.<br>
Si on peut écrire <span style="font-style:italic">N</span>=<span style="font-style:italic">A</span>*<span style="font-style:italic">D</span><sup><span style="font-style:italic">J</span></sup> avec <span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">D</span>)=1 et <span style="font-style:italic">J</span>&gt;0 alors <span style="font-style:italic">D</span><sup><span style="font-style:italic">J</span></sup> est un 
facteur de la décomposition de <span style="font-style:italic">N</span>.<br>
On écrit tout d’abord la fonction <span style="font-family:monospace">ddiv(N,D)</span> qui renvoie :<br>
- soit la liste :<br>
<span style="font-family:monospace">[ N,[]]</span> si <span style="font-style:italic">D</span> n’est pas un diviseur de <span style="font-style:italic">N</span>,<br>
- soit la liste :<br>
<span style="font-family:monospace">[A,[D,J]]</span> si <span style="font-style:italic">N</span>=<span style="font-style:italic">A</span>*<span style="font-style:italic">D</span><sup><span style="font-style:italic">J</span></sup> avec <span style="font-style:italic">PGCD</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">D</span>)=1 et <span style="font-style:italic">J</span>&gt;0.<br>
 <span style="font-style:italic">D</span><sup><span style="font-style:italic">J</span></sup> est alors un diviseur de <span style="font-style:italic">N</span> et <span style="font-style:italic">A</span>=<span style="font-style:italic">N</span>/<span style="font-style:italic">D</span><sup><span style="font-style:italic">J</span></sup> . 
</p>
<h3 id="sec198" class="subsection">8.5.1  Traduction Algorithmique</h3>
<pre class="verbatim">fonction ddiv(N,D)
//ddiv renvoie [a,[d,j]] (n=a*d^j, pgcd(a,d)=1) si j!=0 sinon [n,[]] 
local L,J
0=&gt;J
tantque  (N mod D)=0) faire
N/D=&gt;N
J+1=&gt;J
ftantque
si (J=0) alors
{N,{}}=&gt;L
sinon
{N,{D,J}}=&gt;L
fsi
retourne(L)
ffonction
</pre><p>
On cherche la liste des nombres premiers plus petit que √<span style="text-decoration:overline"><span style="font-style:italic">N</span></span> et on met 
cette liste dans la variable <span style="font-style:italic">PREM</span>. Lorsque <span style="font-style:italic">N</span>&gt;1, on teste si ces nombres 
premiers sont des diviseurs de <span style="font-style:italic">N</span> en utilisant <span style="font-family:monospace">ddiv</span>. 
</p><pre class="verbatim">fonction criblefact(N)
//decomposition en facteurs premiers de n 
//en utilisant ddiv et crible
local D,PREM,S,LD,LDIV;
PREM:=crible(floor(sqrt(N)));
S:=dim(PREM);
LDIV:={};
1=&gt;K
tantque (K&lt;=S et N&gt;1) faire 
  ddiv(N,PREM[K])=&gt;LD
  concat(LDIV,ld[2])=&gt;LDIV;
  LD[1]=&gt;N
  K+1=&gt;K
ftantque
si (N != 1) alors
 concat(LDIV,[N,1])=&gt;LDIV;
fsi
retourne(LDIV);
}
</pre>
<h3 id="sec199" class="subsection">8.5.2  Traduction Xcas</h3>
<p><a id="sec:criblefact"></a>
</p><pre class="verbatim">ddiv(n,d):={
//ddiv renvoie [a,[d,j]] (n=a*d^j, pgcd(a,d)=1) si j!=0 
//sinon [n,[]] 
local l,j;
j:=0;
while (irem(n,d)==0){
n:=iquo(n,d);
j:=j+1;
}
if (j==0){
l:=[n,[]];
} else {
l:=[n,[d,j]];
}
return(l);
}
</pre><pre class="verbatim">criblefact(n):={
//decomposition en facteurs premiers de n 
//en utilisant ddiv et crible
local d,prem,s,ld,ldiv;
prem:=crible(floor(sqrt(n)));
s:=size(prem);
ldiv:=[];
for (k:=0;k&lt;s;k++){
ld:=ddiv(n,prem[k]);
ldiv:=concat(ldiv,ld[1]);
n:=ld[0];
k:=k+1;
}
if (n!=1){
ldiv:=concat(ldiv,[n,1]);
}
return(ldiv);
}
</pre>
<h2 id="sec200" class="section">8.6  La liste des diviseurs</h2>
<h3 id="sec201" class="subsection">8.6.1  Les programmes avec les élèves</h3>
<p>
L’algorithme naïf :<br>
<span style="font-family:monospace">pour j de 1 a n faire<br>
  si (j divise n) alors<br>
    afficher j<br>
  fsi<br>
fpour</span><br>

Les élèves remarquent que l’on peut avoir les diviseurs deux par deux.<br>
<span style="font-family:monospace">pour j de 1 a E(</span>√<span style="text-decoration:overline">n</span><span style="font-family:monospace">) faire<br>
  si (j divise n) alors<br>
    afficher j, n/j <br>
  fsi<br>
fpour</span><br>
Malheureusement, lorsque l’entier <span style="font-style:italic">n</span> est le carré de <span style="font-style:italic">p</span>, <span style="font-style:italic">p</span> figure deux 
fois dans l’affichage des diviseurs.<br>
On améliore donc l’algorithme :<br>
 
<span style="font-family:monospace">1 </span>→<span style="font-family:monospace"> j<br>
tantque j&lt;</span>√<span style="text-decoration:overline">n</span><span style="font-family:monospace"> faire<br>
  si (j divise n) alors<br>
    afficher j, n/j <br>
  fsi<br>
  j+1 </span>→<span style="font-family:monospace"> j<br>
ftantque<br>
si j</span>·<span style="font-family:monospace">j=n alors<br>
  afficher j<br>
fsi</span>
<span style="font-weight:bold">Remarque</span>
Les programmes sont ensuite mis sur des calculatrices, c’est pourquoi les 
algorithmes précédents utilisent la commande <span style="font-family:monospace">afficher</span>. Si on veut 
écrire un programme avec <span style="font-family:monospace">Xcas</span> on fera une fonction : on mettera les 
diviseurs dans une liste qui sera à la fin la valeur de la fonction en 
utilisant la commande <span style="font-family:monospace">retourne</span> par exemple :
</p>
<h4 id="sec202" class="subsubsection">Traduction Xcas de l’algorithme naïf</h4>
<pre class="verbatim">nbdivis(n):={
local j, L,sn;
L:=[];
j:=1;
sn:=sqrt(n)
tantque j&lt;sn faire
si irem(n,j)==0 alors L:=concat(L,[j,n/j]); fsi;
j:=j+1;
ftantque;
si j*j==n alors L:=append(L,j) fsi;
retourne L;
}:;
</pre>
<h3 id="sec203" class="subsection">8.6.2  Le nombre de diviseurs d’un entier <span style="font-style:italic">n</span></h3>
<p>
On décompose <span style="font-style:italic">n</span> en facteurs premiers, puis on donne aux exposants de ces 
facteurs premiers toutes les valeurs possibles. 
Si <span style="font-style:italic">n</span>=<span style="font-style:italic">a</span><span style="font-style:italic">b</span><span style="font-style:italic">c</span><sup>γ</sup>
l’exposant de <span style="font-style:italic">a</span> paut prendre α+1 valeurs (0..α), celui de <span style="font-style:italic">b</span>
peut prendre β+1 valeurs et celui de <span style="font-style:italic">c</span>
peut prendre γ+1 valeurs donc le nombre de diviseurs de <span style="font-style:italic">n</span> est (α+1)*(β+1)*(γ+1).
</p>
<h3 id="sec204" class="subsection">8.6.3  L’algorithme sur un exemple</h3>
<p> 
Déscription de l’algorithme sur un exemple :<br>
<span style="font-style:italic">n</span>=360=2<sup>3</sup>*3<sup>2</sup>*5<br>
<span style="font-style:italic">n</span> a donc (3+1)*(2+1)*(1+1)=24 diviseurs.<br>
On les écrit en faisant varier le triplet représentant les exposants avec 
l’ordre :<br>
(0,0,0),(1,0,0),(2,0,0),(3,0,0),<br>
(0,1,0),(1,1,0),(2,1,0),(3,1,0),<br>
(0,2,0),(1,2,0),...,<br>
(0,2,1),(1,2,1),(2,2,1),(3,2,1))<br>
On a (<span style="font-style:italic">a</span><sub>1</sub>,β,γ) &lt; (<span style="font-style:italic">b</span><sub>1</sub>,<span style="font-style:italic">b</span><sub>2</sub>,<span style="font-style:italic">b</span><sub>3</sub>) si :<br>
γ&lt;<span style="font-style:italic">b</span><sub>3</sub> ou <br>
γ=<span style="font-style:italic">b</span><sub>3</sub> et β&lt;<span style="font-style:italic">b</span><sub>2</sub> ou <br>
γ=<span style="font-style:italic">b</span><sub>3</sub> et β=<span style="font-style:italic">b</span><sub>2</sub> et <span style="font-style:italic">a</span><sub>1</sub>&lt;<span style="font-style:italic">b</span><sub>1</sub>.<br>
On obtient les 4*3*2=24 diviseurs de 360 :<br>
1,2,4,8,3,6,12,24,9,18,36,72,5,10,20,40,15,30,60,120,45,90,180,360.<br>
que l’on peut écrire en le tableau suivant :<br>
1,2,4,8 (les puissances de 2) <br>
3,6,12,24 (3*les puissances de 2)<br>
9,18,36,72 (3*3*les puissances de 2)<br>
5,10,20,40 (5*les puissances de 2)<br>
15,30,60,120 (5*3*les puissances de 2)<br>
45,90,180,360 (5*3*3*les puissances de 2).<br>
Comment obtient-on la liste des diviseurs de <span style="font-style:italic">a</span><span style="font-style:italic">b</span><span style="font-style:italic">c</span><sup>γ</sup> 
à partir de la liste <span style="font-family:monospace">L1</span> des diviseurs de <span style="font-style:italic">a</span><span style="font-style:italic">b</span><sup>β</sup> ?<br>
Il suffit de rajouter à <span style="font-family:monospace">L1</span> la liste <span style="font-family:monospace">L2</span> constituée par :<br>
<span style="font-family:monospace"><span style="font-style:italic">c</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1,...,</span><span style="font-family:monospace"><span style="font-style:italic">c</span></span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span><br>
Dans le programme cette liste de diviseurs (<span style="font-family:monospace">L1</span>) sera donc constituée 
au fur et à mesure au moyen d’une liste (<span style="font-family:monospace">L2</span>) qui correspond au parcours
de l’arbre.<br>
On initialise <span style="font-family:monospace">L1</span> avec <span style="font-family:monospace">{1}</span>, puis on rajoute à <span style="font-family:monospace">L1</span>
la liste <span style="font-family:monospace">L2</span> formée par :<br>
<span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1,...,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span>.<br>
Puis on recommence avec le diviseur suivant :<br>
on rajoute à <span style="font-family:monospace">L1</span>
la liste <span style="font-family:monospace">L2</span> formée par <span style="font-family:monospace"><span style="font-style:italic">b</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1,...,</span><span style="font-family:monospace"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span> etc...
</p>
<h3 id="sec205" class="subsection">8.6.4  Les algorithmes donnant la liste des diviseurs de n </h3>
<p> 
La liste <span style="font-family:monospace">L1</span> est la liste destinée à contenir les diviseurs de <span style="font-family:monospace">N</span>.<br>
Au dèbut <span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1={1}</span> et <span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2={}</span>.<br>
Pour avoir la liste des diviseurs de <span style="font-family:monospace">N</span>, on cherche <span style="font-family:monospace">A</span> le premier 
diviseur de <span style="font-family:monospace">N</span> et on cherche <span style="font-family:monospace">a</span> la puissance avec quelle <span style="font-family:monospace">A</span>
divise <span style="font-family:monospace">N</span>.<br>
On définit la liste <span style="font-family:monospace">L2</span> :<br>
<span style="font-family:monospace">L2</span> est obtenue en concaténant, les listes <span style="font-family:monospace">L1*A</span>, <span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup>,
...,<span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup> : au début <span style="font-family:monospace">L1={1}</span> donc 
<span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2={</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,...,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace">}</span>.<br>
On modifie la liste <span style="font-family:monospace">L1</span> en lui concaténant la liste <span style="font-family:monospace">L2</span>, ainsi 
<span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1={1,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,...,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace">}</span>.<br>
Puis, on vide la liste <span style="font-family:monospace">L2</span>. On cherche <span style="font-family:monospace">B</span> le deuxième diviseur 
éventuel de <span style="font-family:monospace">N</span> et on 
cherche <span style="font-family:monospace">b</span> la puissance avec quelle <span style="font-family:monospace">B</span> divise <span style="font-family:monospace">N</span>.<br>
On définit la nouvelle liste <span style="font-family:monospace">L2</span> :<br>
<span style="font-family:monospace">L2</span> est obtenue en concaténant, les listes <span style="font-family:monospace">L1*B</span>, <span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1*</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace">2</span></sup>,
..., <span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1*</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">b</span></span></sup> (c’est à dire 
<span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2={</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,..,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,..,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace">,..,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">b</span></span></sup><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace">,}</span>) <br>
On modifie la liste <span style="font-family:monospace">L1</span> en lui concaténant la liste <span style="font-family:monospace">L2</span>, ainsi :<br>
<span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1={1,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,...,</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,...,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace">,...,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">b</span></span></sup><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">b</span></span></sup><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">b</span></span></sup><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace">2</span></sup><span style="font-family:monospace">,...,</span><span style="font-family:monospace"><span style="font-style:italic">B</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">b</span></span></sup><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">a</span></span></sup><span style="font-family:monospace">}</span>.<br>
Et ainsi de suite, jusqu’à avoir epuisé tous les diviseurs de <span style="font-family:monospace">N</span>.
</p>
<h4 id="sec206" class="subsubsection">Traduction Algorithmique</h4>
<p>
<span style="font-family:monospace">fonction NDIV0(N)<br>
local D,L1,L2,K</span><br>
<span style="font-family:monospace">2 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><br>
<span style="font-family:monospace">{1} =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span><br>
<span style="font-family:monospace"><span style="font-style:italic">tant</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">que</span></span><span style="font-family:monospace">  (</span><span style="font-family:monospace"><span style="font-style:italic">N</span></span><span style="font-family:monospace"> ≠ 1) </span><span style="font-family:monospace"><span style="font-style:italic">faire</span></span><br>
<span style="font-family:monospace">{}=&gt;L2 </span><br>
<span style="font-family:monospace">0=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">K</span></span>:<br>
<span style="font-family:monospace">tantque ((N MOD D) =0) faire</span><br>
<span style="font-family:monospace"><span style="font-style:italic">N</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">N</span></span><br>
<span style="font-family:monospace"><span style="font-style:italic">K</span></span><span style="font-family:monospace">+1 =&gt;</span><span style="font-family:monospace"><span style="font-style:italic">K</span></span><br>
<span style="font-family:monospace"><span style="font-style:italic">concat</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2,</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1*</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">  </span><span style="font-family:monospace"><span style="font-style:italic">K</span></span><span style="font-family:monospace">)=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2</span><br>
<span style="font-family:monospace">ftantque</span><br>
<span style="font-family:monospace"><span style="font-style:italic">concat</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1,</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2)=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span><br>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+1=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><br>
<span style="font-family:monospace">ftantque</span><br>
<span style="font-family:monospace">retourne(L1)</span>
</p>
<h4 id="sec207" class="subsubsection">Traduction Xcas</h4>
<pre class="verbatim">ndiv0(n):={
  local d,l1,l2,k;
  d:=2;
  l1:=[1];
  while (n!=1) {
    l2:=[];
    k:=0;
    while (irem(n,d)==0) {
      n:=iquo(n,d);
      k:=k+1;
      l2:=concat(l2,l1*d^k);
    }
    l1:=concat(l1,l2); 
    d:=d+1;
  }
  return(l1);
}
</pre><p>
On peut améliorer ce programme en calculant <span style="font-family:monospace">l1*d</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">k</span> au fur et 
à mesure sans utiliser <span style="font-family:monospace">k</span>....<br>
On a en effet sur l’exemple précédent <span style="font-style:italic">n</span>=360=2<sup>3</sup>*3<sup>2</sup>*5 :<br>
<span style="font-family:monospace">l1:=[1]</span>;<br>
les puissances de 2 sont obtenus avec
<span style="font-family:monospace">l2:=l1</span> on a alors <span style="font-family:monospace">l2:=[1]</span><br>
<span style="font-family:monospace">l2:=l2*2;l1:=concat(l1,l2)</span> on a alors <span style="font-family:monospace">l2:=[2];l1:=[1,2]</span><br>
<span style="font-family:monospace">l2:=l2*2;l1:=concat(l1,l2)</span> on a alors <span style="font-family:monospace">l2:=[4];l1:=[1,2,4]</span><br>
<span style="font-family:monospace">l2:=l2*2;l1:=concat(l1,l2)</span> on a alors <span style="font-family:monospace">l2:=[8];l1:=[1,2,4,8]</span><br>
les puissances de 3 sont obtenus avec
<span style="font-family:monospace">l2:=l1</span> on a alors <span style="font-family:monospace">l2:=[1,2,4,8]</span><br>
<span style="font-family:monospace">l2:=l2*3;l1:=concat(l1,l2)</span> on a alors <span style="font-family:monospace">l2:=[3,6,12,24];</span> <span style="font-family:monospace">l1:=[1,2,4,8,3,6,12,24]</span><br>
<span style="font-family:monospace">l2:=l2*3;l1:=concat(l1,l2)</span> on a alors <span style="font-family:monospace">l2:=[9,18,36,72];</span> <span style="font-family:monospace">l1:=[1,2,4,8,3,6,12,24,9,18,36,72]</span><br>
les puissances de 5 sont obtenus avec
<span style="font-family:monospace">l2:=l1</span> on a alors <span style="font-family:monospace">l2:=[1,2,4,8,3,6,12,24,9,18,36,72]</span><br>
<span style="font-family:monospace">l2:=l2*5;l1:=concat(l1,l2)</span> on a alors <span style="font-family:monospace">l2:=[5,10,20,40,15,30,60,120,45,90,180,360]</span><br>
donc <br>
<span style="font-family:monospace">l1:=[1,2,4,8,3,6,12,24,9,18,36,72,5,10,20,40,15,30,60,120,45,90,180,360]</span><br>
On tape :
</p><pre class="verbatim">ndiv1(n):={
  local d,l1,l2;
  d:=2;
  l1:=[1];
  while (n!=1) {
    l2:=l1;
    while (irem(n,d)==0) {
      n:=iquo(n,d);
      l2:=l2*d
      l1:=concat(l1,l2);
    }
    d:=d+1;
  }
  return(l1);
}:;
</pre><p>
On peut encore améliorer ce programme si on tient compte du fait qu’après
avoir éventuellement divisé <span style="font-family:monospace">N</span> par 2 autant de fois qu’on le pouvait,
les diviseurs potentiels de <span style="font-family:monospace">N</span> sont impairs.<br>
On remplace alors :<br>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+1 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><br>
par :<br>
<span style="font-family:monospace">si D=2 alors</span>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+1 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">sinon</span><br>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+2 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">fsi</span><br>

On améliore le programme précédent en remarquant que,
si le diviseur potentiel <span style="font-family:monospace">D</span> est tel que <span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">&gt;√</span><span style="font-family:monospace"><span style="text-decoration:overline"><span style="font-style:italic">N</span></span></span>, c’est que 
<span style="font-family:monospace">N</span> est premier ou vaut 1.
On ne continue donc pas la recherche des diviseurs de <span style="font-family:monospace">N</span> et quand 
<span style="font-family:monospace">N</span> est diffèrent de 1 on complète
<span style="font-family:monospace">L1</span> par <span style="font-family:monospace">L1*N</span>.<br>
Et aussi, on ne teste comme diviseur potentiel de <span style="font-family:monospace">N</span>, que les 
nombres 2, 3, puis les nombres de la forme 6*<span style="font-style:italic">k</span>−1 ou de la forme 6*<span style="font-style:italic">k</span>+1 
(pour <span style="font-style:italic">k</span>∈ ℕ).<br>
On remplace donc :<br>
<span style="font-family:monospace">si D=2 alors</span>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+1 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">sinon</span><br>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+2 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">fsi</span><br>
par :<br>
<span style="font-family:monospace">si D&lt;4 alors</span>
<span style="font-family:monospace">2*</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">-1 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">sinon</span><br>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+(4*</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">mod</span><span style="font-family:monospace">6) =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">fsi</span>
</p>
<h4 id="sec208" class="subsubsection">Traduction Algorithmique</h4>
<p>
<span style="font-family:monospace">fonction ndiv2(N)<br>
local D,L1,L2,K</span><br>
<span style="font-family:monospace">2 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><br>
<span style="font-family:monospace">{1} =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span><br>
<span style="font-family:monospace"><span style="font-style:italic">tant</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">que</span></span><span style="font-family:monospace">  (</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace"> ≤ √</span><span style="font-family:monospace"><span style="text-decoration:overline"><span style="font-style:italic">N</span></span></span><span style="font-family:monospace">) </span><span style="font-family:monospace"><span style="font-style:italic">faire</span></span><br>
<span style="font-family:monospace">{}=&gt;L2 </span><br>
<span style="font-family:monospace">0=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">K</span></span>:<br>
<span style="font-family:monospace">tantque ((N MOD D) =0) faire</span><br>
<span style="font-family:monospace"><span style="font-style:italic">N</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">N</span></span><br>
<span style="font-family:monospace"><span style="font-style:italic">K</span></span><span style="font-family:monospace">+1 =&gt;</span><span style="font-family:monospace"><span style="font-style:italic">K</span></span><br>
<span style="font-family:monospace"><span style="font-style:italic">concat</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2,</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1*</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">  </span><span style="font-family:monospace"><span style="font-style:italic">K</span></span><span style="font-family:monospace">)=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2</span><br>
<span style="font-family:monospace">ftantque</span><br>
<span style="font-family:monospace"><span style="font-style:italic">concat</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1,</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">2)=&gt; </span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span><br>
<span style="font-family:monospace">si D&lt;4 alors</span>
<span style="font-family:monospace">2*</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">-1 =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">sinon</span><br>
<span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace">+(4*</span><span style="font-family:monospace"><span style="font-style:italic">D</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">mod</span><span style="font-family:monospace">6) =&gt; </span><span style="font-family:monospace"><span style="font-style:italic">D</span></span>
<span style="font-family:monospace">fsi</span><br>
<span style="font-family:monospace">ftantque</span><br>
<span style="font-family:monospace"><span style="font-style:italic">si</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">N</span></span><span style="font-family:monospace"> ≠ 1 </span><span style="font-family:monospace"><span style="font-style:italic">alors</span></span><br>
<span style="font-family:monospace"><span style="font-style:italic">concat</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1,</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1*</span><span style="font-family:monospace"><span style="font-style:italic">N</span></span><span style="font-family:monospace">) =&gt;</span><span style="font-family:monospace"><span style="font-style:italic">L</span></span><span style="font-family:monospace">1</span><br>
<span style="font-family:monospace">fsi</span><br>
<span style="font-family:monospace">retourne(L1)</span>
</p>
<h4 id="sec209" class="subsubsection">Traductions Xcas des améliorations</h4>
<pre class="verbatim">ndivi(n):={
  local d,l1,l2,k;
  d:=2;
  l1:=[1];
  l2:=l1
  while (irem(n,d)==0) {
      n:=iquo(n,d);
      l2:=l2*d
      l1:=concat(l1,l2);
    }
  d:=3;
   while (d&lt;=sqrt(n) and n&gt;1) {
    l2:=l1;
    while (irem(n,d)==0) {
      n:=iquo(n,d);
      l2:=l2*d
      l1:=concat(l1,l2);
    }
    d:=d+2;
  };
  if (n!=1) {l1:=concat(l1,l1*n)};
  return(l1);
}:;
</pre><p>
Si on ne teste pas <span style="font-family:monospace">d&lt;sqrt(n)</span> le programme est plus simple :
</p><pre class="verbatim">ndivis(n):={
  local d,l1,l2,k;
  d:=2;
  l1:=[1];
  l2:=l1
  while (irem(n,d)==0) {
      n:=iquo(n,d);
      l2:=l2*d
      l1:=concat(l1,l2);
    }
  d:=3;
   while (n&gt;1) {
    l2:=l1;
    while (irem(n,d)==0) {
      n:=iquo(n,d);
      l2:=l2*d
      l1:=concat(l1,l2);
    }
    d:=d+2;
  };
  return(l1);
}:;
</pre><p>
Ou bien on utilise <span style="font-family:monospace">ifactors</span> : on obtient un programme plus rapide surtout
lorsqu’il y a de grands facteurs premiers car la
décomposition en facteurs premiers est optimisée.<br>
<span style="font-family:monospace">ndivfact(n)</span> renvoie la liste des diviseurs de <span style="font-family:monospace">n</span> et la longueur de 
cette liste.
On calcule la longueur de cette liste en faisant le produit des exposants 
augmentés de 1. Par exemple si <span style="font-family:monospace">n=360</span>=2<sup>3</sup>*3<sup>2</sup>*5, la liste des diviseurs
de <span style="font-family:monospace">n=360</span> a comme longueur <span style="font-family:monospace">sd:=(3+1)*(2+1)*(1+1)</span>=24<br>
La liste <span style="font-family:monospace">l1</span> va contenir la liste des diviseurs et pour 
chaque nouveau diviseur de <span style="font-style:italic">n</span>, la liste <span style="font-family:monospace">l2</span> contient les nouveaux 
diviseurs qui doivent être rajoutés à <span style="font-family:monospace">l1</span>.<br>
Par exemple si <span style="font-family:monospace">n=360</span>
au début 
<span style="font-family:monospace">l1:=[1]</span> et <span style="font-family:monospace">l2:=l1</span> <br>
<span style="font-family:monospace">d:=2</span> est un diviseur donc <br>
<span style="font-family:monospace">l2:=2*l2</span> i.e. <span style="font-family:monospace">l2:=[2]</span> et <span style="font-family:monospace">l1:=concat(l1,l2)</span> i.e. <span style="font-family:monospace">l1=[1,2]</span><br>
<span style="font-family:monospace">d:=2</span> est encore un diviseur donc <br>
<span style="font-family:monospace">l2:=2*l2</span> i.e. <span style="font-family:monospace">l2:=[4]</span> et <span style="font-family:monospace">l1:=concat(l1,l2)</span> i.e. <span style="font-family:monospace">l1=[1,2,4]</span><br>
<span style="font-family:monospace">d:=2</span> est encore un diviseur donc <br>
<span style="font-family:monospace">l2:=2*l2</span> i.e. <span style="font-family:monospace">l2:=[8]</span> et <span style="font-family:monospace">l1:=concat(l1,l2)</span> i.e. <span style="font-family:monospace">l1=[1,2,4,8]</span><br>
On a épuiser le diviseur 2. On recopie <span style="font-family:monospace">l1</span> dans <span style="font-family:monospace">l2</span><br>
<span style="font-family:monospace">l2:=l1</span> i.e. <span style="font-family:monospace">l2=[1,2,4,8]</span><br>
le nouveau diviseur est 3 donc <br>
<span style="font-family:monospace">l2:=3*l2</span> i.e. <span style="font-family:monospace">l2:=[3,6,12,24]</span> et <span style="font-family:monospace">l1:=concat(l1,l2)</span> i.e. 
<span style="font-family:monospace">l1=[1,2,4,3,6,12,24]</span><br>
<span style="font-family:monospace">d:=3</span> est encore un diviseur donc <br>
<span style="font-family:monospace">l2:=3*l2</span> i.e. <span style="font-family:monospace">l2:=[9,18,36,72]</span> et <span style="font-family:monospace">l1:=concat(l1,l2)</span> i.e. 
<span style="font-family:monospace">l1=[1,2,4,8,3,6,12,24,9,18,36,72]</span><br>
On a épuiser le diviseur 3. On recopie <span style="font-family:monospace">l1</span> dans <span style="font-family:monospace">l2</span><br>
<span style="font-family:monospace">l2:=l1</span> i.e. <span style="font-family:monospace">l2=[1,2,4,8,3,6,12,24,9,18,36,72]</span>
le nouveau diviseur est 5 donc <br>
<span style="font-family:monospace">l2:=5*l2</span> i.e. <span style="font-family:monospace">l2:=[5,10,20,40,15,30,60,120,45,90,180,360]</span> et 
<span style="font-family:monospace">l1:=concat(l1,l2)</span> i.e.<br>
<span style="font-family:monospace">l1=[1,2,4,8,3,6,12,24,9,18,36,72,5,10,20,40,15,30,60,120,45,90,180,360]</span><br>
On a épuiser tous les diviseurs donc les diviseurs de 360 sont 
<span style="font-family:monospace">l1=[1,2,4,8,3,6,12,24,9,18,36,72,5,10,20,40,15,30,60,120,45,90,180,360]</span><br>
On tape :
</p><pre class="verbatim">ndivfact(n):={
  local F,d,l1,l2,k,kd,sf,sd,j;
  si n==0 alors retourne "erreur"; fsi;
  si n&lt;0 alors n:=-n; fsi;
  F:=ifactors(n);
  sf:=size(F)-1;
  sd:=1;
  pour k de 1 jusque sf pas 2 faire 
   sd:=sd*(F[k]+1);
  fpour;
  k:=1;
  l1:=[1];
    while (k&lt;=sf) {
    l2:=l1;kd:=F[k];
    d:=F[k-1];
    pour j de 1 jusque kd faire
      l2:=l2*d
      l1:=concat(l1,l2);
    fpour;
  k:=k+2;
  }; 
  return l1,sd;
  }:;
</pre><p>
Comparons les temps d’exécution sur 2 exemples.<br>
On tape :<br>
<span style="font-family:monospace">ndivis(30!);</span><br>
On obtient :<br>
<span style="font-family:monospace">Temps mis pour l’évaluation: 7.53</span><br>
On tape :<br>
<span style="font-family:monospace">ndivi(30!);</span><br>
On obtient :<br>
<span style="font-family:monospace">Temps mis pour l’évaluation: 8.03</span><br>
On tape :<br>
<span style="font-family:monospace">ndivfact(30!);</span><br>
On obtient :<br>
<span style="font-family:monospace">Temps mis pour l’évaluation: 7.33</span><br>
Mais si on tape :<br>
<span style="font-family:monospace">ndivis(30!*907);</span><br>
On obtient :<br>
<span style="font-family:monospace">Temps mis pour l’évaluation: 19.28</span><br>
On tape :<br>
<span style="font-family:monospace">ndivi(30!*907);</span><br>
On obtient :<br>
<span style="font-family:monospace">Temps mis pour l’évaluation: 17.07</span><br>
On tape :<br>
<span style="font-family:monospace">ndivfact(30!*907);</span><br>
On obtient :<br>
<span style="font-family:monospace">Temps mis pour l’évaluation: 17.07</span><br>
Donc dans le 1ier cas <span style="font-family:monospace">ndivis</span> va plus vite et dans le 2nd cas c’est
<span style="font-family:monospace">ndivi</span> qui va plus vite.</p>
<h2 id="sec210" class="section">8.7  La liste des diviseurs avec la décomposition en facteurs premiers</h2>
<h3 id="sec211" class="subsection">8.7.1  <span style="font-family:monospace">FPDIV</span></h3>
<p>
On utilise le programme <span style="font-family:monospace">factprem</span> (qui donne la liste des facteurs 
premiers de <span style="font-family:monospace">N</span> (cf <a href="#sec%3Afactprem">8.4.2</a>)
pour obtenir la liste des diviseurs de <span style="font-family:monospace">N</span> selon l’algorithme utilisé dans <span style="font-family:monospace">NDIV1</span>.
</p>
<h4 id="sec212" class="subsubsection">Traduction Algorithmique</h4>
<pre class="verbatim">fonction fpdiv(N)
//renvoie la liste des diviseurs de n en utilisant factprem
local L1,L2,L3,D,ex,S
factprem(N)=&gt;L3
dim(L3)=&gt;S
{1}=&gt;L1
pour  K de 1 a S-1 pas 2 faire
{}=&gt;L2
L3[K]=&gt;D
L3[K+1]=&gt;ex
pour  J de 1 a ex faire 
concat(L2,L1*(D^J))=&gt;L2
}
concat(L1,L2)=&gt;L1
}
retourne(L1)
}
</pre>
<h4 id="sec213" class="subsubsection">Traduction Xcas</h4>
<pre class="verbatim">fpdiv(n):={
//renvoie la liste des diviseurs de n en utilisant factprem
local l1,l2,l3,d,ex,s;
l3:=factprem(n);
s:=size(l3);
l1:=[1];
for (k:=0;k&lt;s-1;k:=k+2) {
l2:=[];
d:=l3[k];
ex:=l3[k+1];
for (j:=1;j&lt;=ex;j++) {
l2:=concat(l2,l1*(d^j));
}
l1:=concat(l1,l2);
}
return(l1);
}
</pre>
<h3 id="sec214" class="subsection">8.7.2  <span style="font-family:monospace">CRIBLEDIV</span></h3>
<p>
Pour obtenir la liste des diviseurs de <span style="font-family:monospace">N</span> selon l’algorithme utilisé 
dans <span style="font-family:monospace">NDIV1</span>, on utilise le programme <span style="font-family:monospace">criblefact</span> 
(cf <a href="#sec%3Acriblefact">8.5.2</a>) qui donne la liste des facteurs premiers de <span style="font-family:monospace">N</span>.<br>
</p>
<h3 id="sec215" class="subsection">8.7.3  Traduction Algorithmique</h3>
<pre class="verbatim">fonction criblediv(N)
//renvoie la liste des diviseurs de n en utilisant factprem
local L1,L2,L3,D,ex,S
criblefact(N)=&gt;L3
dim(L3)=&gt;S
{1}=&gt;L1
pour  K de 1 a S-1 pas 2 faire
{}=&gt;L2
L3[K]=&gt;D
L3[K+1]=&gt;ex
pour  J de 1 a ex faire 
concat(L2,L1*(D^J))=&gt;L2
}
concat(L1,L2)=&gt;L1
}
retourne(L1)
}
</pre>
<h4 id="sec216" class="subsubsection">Traduction Xcas</h4>
<pre class="verbatim">criblediv(n):={
//renvoie la liste des diviseurs de n en utilisant criblefact
local l1,l2,l3,d,ex;
l3:=criblefact(n);
s:=size(l3);
l1:=[1];
for (k:=0;k&lt;s-1;k:=k+2) {
l2:=[];
d:=l3[k];
ex:=l3[k+1];
for (j:=1;j&lt;=ex;j++) {
l2:=concat(l2,l1*(d^j));
}
l1:=concat(l1,l2);
}
return(l1);
}
</pre>
<h2 id="sec217" class="section">8.8  Calcul de  <span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup>   <span style="font-style:italic">mod</span> <span style="font-style:italic">N</span></h2>
<p><a id="sec:puimod"></a>
</p>
<h3 id="sec218" class="subsection">8.8.1  Traduction Algorithmique</h3>
<p>
-Premier algorithme<br>
On utilise deux variables locales PUIS et I.<br>
On fait un programme itératif de façon qu’à chaque étape, PUIS 
représente <span style="font-style:italic">A</span><sup><span style="font-style:italic">I</span></sup> mod<span style="font-style:italic">N</span>
</p><pre class="verbatim">fonction puimod1 (A, P, N)
local PUIS, I
1=&gt;PUIS
pour I de 1 a P faire
  A*PUIS mod N =&gt;PUIS 
fpour
retourne PUIS
ffonction
</pre><p> 
-Deuxième algorithme<br>
On n’utilise ici qu’une seule variable locale PUI, mais on fait varier P de 
façon qu’à chaque étape de l’itération on ait :<br>
 <span style="font-style:italic">PUI</span> * <span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup> mod<span style="font-style:italic">N</span>=<span style="font-style:italic">constante</span>. Au début  <span style="font-style:italic">PUI</span>=1 donc 
<span style="font-style:italic">constante</span>=<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup> mod<span style="font-style:italic">N</span> (pour la valeur initiale du paramètre <span style="font-style:italic">P</span>, c’est 
à dire que cette <span style="font-style:italic">constante</span> est égale à ce que doit retourner la 
fonction), et, à chaque étape, on utilise l’égalité
<span style="font-style:italic">PUI</span>*<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup> mod<span style="font-style:italic">N</span>=(<span style="font-style:italic">PUI</span>*<span style="font-style:italic">A</span>mod<span style="font-style:italic">N</span>)*<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span>−1</sup> mod<span style="font-style:italic">N</span>, pour diminuer la valeur de <span style="font-style:italic">P</span>,
et pour arriver à la fin à <span style="font-style:italic">P</span>=0, et alors on a la <span style="font-style:italic">constante</span>=<span style="font-style:italic">PUI</span>.
</p><pre class="verbatim">fonction puimod2 (A, P, N)
local PUI
1=&gt;PUI
tantque  P&gt;0  faire
  A*PUI mod N =&gt;PUI 
  P-1=&gt;P
ftantque
retourne PUI
ffonction
</pre><p> 
-Troisième algorithme<br>
 On peut aisément modifier ce programme en remarquant que :<br>
<span style="font-style:italic">A</span><sup>2*<span style="font-style:italic">P</span></sup> = (<span style="font-style:italic">A</span>*<span style="font-style:italic">A</span>)<sup><span style="font-style:italic">P</span></sup> .<br>
Donc quand <span style="font-style:italic">P</span> est pair, on a la relation :<br>
<span style="font-style:italic">PUI</span>*<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup> = <span style="font-style:italic">PUI</span>*(<span style="font-style:italic">A</span>*<span style="font-style:italic">A</span>mod<span style="font-style:italic">N</span>)<sup><span style="font-style:italic">P</span>/2</sup> mod<span style="font-style:italic">N</span><br>
et quand <span style="font-style:italic">P</span> est impair, on a la relation :<br>
<span style="font-style:italic">PUI</span>*<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup> = (<span style="font-style:italic">PUI</span>*<span style="font-style:italic">A</span>mod<span style="font-style:italic">N</span>)*<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span>−1</sup>mod<span style="font-style:italic">N</span>.<br>
On obtient alors, un algorithme rapide du calcul de  <span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup> mod<span style="font-style:italic">N</span> .
</p><pre class="verbatim">fonction puimod3 (A, P, N)
local PUI
1=&gt;PUI
tantque  P&gt;0  faire
  si P mod 2 =0 alors
    P/2=&gt;P
    A*A mod N=&gt;A
  sinon
    A*PUI mod N =&gt;PUI 
    P-1=&gt;P
  fsi
ftantque
retourne PUI
ffonction
</pre><p> 
On peut remarquer que si <span style="font-style:italic">P</span> est impair, <span style="font-style:italic">P</span>−1 est pair.<br>
On peut donc écrire :
</p><pre class="verbatim">fonction puimod4 (A, P, N)
local PUI
1=&gt;PUI
tantque  P&gt;0  faire
  si P mod 2 =1 alors
    A*PUI mod N =&gt;PUI 
    P-1=&gt;P
  fsi   
P/2=&gt;P
A*A mod N=&gt;A
ftantque
retourne PUI
ffonction
</pre><p>-Programme récursif</p><p>On peut définir la puissance par les relations de récurrence :
<span style="font-style:italic">A</span><sup>0</sup>=1<br>
<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span>+1</sup> mod<span style="font-style:italic">N</span> =(<span style="font-style:italic">A</span><sup><span style="font-style:italic">P</span></sup> mod<span style="font-style:italic">N</span> )*<span style="font-style:italic">A</span> mod<span style="font-style:italic">N</span> 
</p><pre class="verbatim">fonction puimod5(A, P, N)
si P&gt;0 alors
retourne puimod5(A, P-1, N)*A mod N
sinon
retourne 1
fsi
ffonction
</pre><p>-Programme récursif rapide
</p><pre class="verbatim">fonction puimod6(A, P, N)
si P&gt;0 alors
  si P mod 2 =0 alors
    retourne puimod6((A*A mod N), P/2, N)
  sinon
    retourne puimod6(A, P-1, N)*A mod N
  fsi 
sinon
retourne 1
fsi
ffonction
</pre>
<h3 id="sec219" class="subsection">8.8.2  Traduction Xcas</h3>
<pre class="verbatim">puimod(a,p,n):={
//calcule recursivement la puissance rapide a^p modulo n
 if (p==0){
    return(1);
 }  
 if (irem(p,2)==0){
    return(puimod(irem(a*a,n),iquo(p,2),n));
 } 
 return(irem(a*puimod(a,p-1,n),n));
}
</pre>
<h3 id="sec220" class="subsection">8.8.3  Un exercice</h3>
<p>
Étant donné deux entiers <span style="font-style:italic">a</span>∈ ℕ<sup>*</sup> et <span style="font-style:italic">n</span>∈ ℕ, <span style="font-style:italic">n</span>≥ 2, on veut 
connaitre les différentes valeurs de <span style="font-style:italic">a</span><sup><span style="font-style:italic">p</span></sup> mod<span style="font-style:italic">n</span> pour <span style="font-style:italic">p</span> ∈ ℕ, c’est 
à dire l’orbite de <span style="font-style:italic">a</span> dans (ℤ/<span style="font-style:italic">n</span>ℤ,×).<br>
On démontre que l’orbite se termine toujours par un cycle puisque ℤ/<span style="font-style:italic">n</span>ℤ
a un nombre fini d’éléments.
</p><ul class="itemize"><li class="li-itemize">
Trouver l’orbite de 2<sup><span style="font-style:italic">p</span></sup> mod24
</li><li class="li-itemize">Écrire une fonction de <span style="font-style:italic">a</span> et <span style="font-style:italic">n</span> qui renvoie les plus petis entiers 
<span style="font-style:italic">h</span>≥ 0 et <span style="font-style:italic">T</span>&gt;0 vérifiant :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sup><span style="font-style:italic">h</span></sup>=<span style="font-style:italic">a</span><sup><span style="font-style:italic">h</span>+<span style="font-style:italic">T</span></sup> mod<span style="font-style:italic">n</span></td></tr>
</table> 
et la liste des <span style="font-style:italic">a</span><sup><span style="font-style:italic">p</span></sup> mod<span style="font-style:italic">n</span> pour <span style="font-style:italic">p</span>=0..<span style="font-style:italic">h</span>+<span style="font-style:italic">T</span>−1
</li><li class="li-itemize">Écrire une fonction de <span style="font-style:italic">a</span>, et <span style="font-style:italic">n</span> qui représente graphiquement 
<span style="font-style:italic">a</span><sup><span style="font-style:italic">p</span></sup> mod<span style="font-style:italic">n</span> en fonction de <span style="font-style:italic">p</span>.
</li></ul><p><span style="font-weight:bold">Solution</span>
On tape :
<span style="font-family:monospace">(irem(2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">p ,24)$(p=0..10))</span><br>
On obtient : <span style="font-family:monospace">1,2,4,8,16,8,16,8,16,8,16</span>
donc <span style="font-style:italic">h</span>=3 et <span style="font-style:italic">T</span>=2<br>
On utilise la commande <span style="font-family:monospace">member</span> qui teste si un élément est dans une 
liste et <span style="font-family:monospace">member</span> renvoie soit l’indice +1, soit 0.
On peut utiliser soit un <span style="font-family:monospace">tantque</span> soit un <span style="font-family:monospace">repeter</span> (<span style="font-family:monospace">tantque non arrêt faire....tantque</span> ou <span style="font-family:monospace">repeter ...jusqua arrêt</span>) et on remarquera
le test d’arrêt. On sait qu’une affectation renvoie la valeur affectée, 
donc <span style="font-family:monospace">k:=member(b,L)</span> renvoie soit 0 soit un nombre non nul. On fait une 
boucle et on s’arrete quand <span style="font-family:monospace">k:=member(b,L)</span> est non nul.
</p><pre class="verbatim">orbite1(a,n):={
local k,h,T,p,b,L;
L:=[1];
p:=1;
b:=irem(a,n);
tantque !(k:=member(b,L)) faire
L:=append(L,b);
b:=irem(b*a,n);
p:=p+1;
ftantque;
h:=k-1;
T:=p-h;
return h,T,L;
}:;
</pre><pre class="verbatim">orbite2(a,n):={
local k,h,T,p,b,L;
L:=[];
p:=0;
b:=1;
repeter
L:=append(L,b);
b:=irem(b*a,n);
p:=p+1;
jusqua (k:=member(b,L));
h:=k-1;
T:=p-h;
return h,T,L;
}:;
</pre><p>
On dessine les points du cycle et de 2 périodes avec la couleur <span style="font-style:italic">a</span> ou la couleur 0 lorsque <span style="font-style:italic">a</span>=7 :
</p><pre class="verbatim">dessin(a,n):={
local k,h,T,L,P,s,LT;
P:=NULL;
h,T,L:=orbite1(a,n);
s:=dim(L);
LT:=mid(L,h);
L:=concat(concat(L,LT),LT);
pour k de 0 jusque s+2*T-1 faire 
P:=P,point(k,L[k]);
fpour;
si a==7 alors return affichage(P,epaisseur_point_3);fsi;
return affichage(P,a+epaisseur_point_3);
}:;
</pre><p>
On tape : <span style="font-family:monospace">dessin(2,11)</span><br>
On tape : <span style="font-family:monospace">dessin(3,11)</span><br>
On tape : <span style="font-family:monospace">dessin(2,9)</span><br>
On tape : <span style="font-family:monospace">dessin(3,9)</span><br>
et on observe.....<br>
On peut rappeler
</p><ul class="itemize"><li class="li-itemize">
le Théorème de Fermat :si <span style="font-style:italic">n</span> est premier et 0&lt;<span style="font-style:italic">a</span>&lt;<span style="font-style:italic">n</span>, alors :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span>−1</sup>=1 mod<span style="font-style:italic">n</span></td></tr>
</table>
</li><li class="li-itemize">la Généralisation du théorème de Fermat : si <span style="font-style:italic">a</span> et <span style="font-style:italic">n</span> sont 
premiers entre eux, alors si <span style="font-family:monospace">euler(n)</span>=φ(<span style="font-style:italic">n</span>) est l’indicatrice 
d’Euler, on a :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sup>φ(<span style="font-style:italic">n</span>)</sup>=1 mod<span style="font-style:italic">n</span></td></tr>
</table> 
</li></ul><p>
On tape :
</p><pre class="verbatim">est_premier_avec(n):={
local L,a;
L:=NULL;
pour a de 1 jusque n-1 faire
si gcd(a,n)==1 alors L:=L,a; fsi;
fpour;
return L;
}:;
</pre><p>
Puis, on tape : <span style="font-family:monospace">E:=est_premier_avec(9)</span><br>
On obtient : <span style="font-family:monospace">1,2,4,5,7,8</span><br>
et on a bien : <span style="font-family:monospace">euler(9)=6=dim(E)</span><br>
Une démonstration rapide de ces théorèmes :<br>
Si <span style="font-style:italic">a</span> et <span style="font-style:italic">n</span> sont premiers entre eux, <span style="font-style:italic">a</span> est inversible dans ℤ/<span style="font-style:italic">n</span>ℤ,×
Soit <span style="font-style:italic">E</span> l’ensemble des nombres de [1..<span style="font-style:italic">n</span>] qui sont premiers avec <span style="font-style:italic">n</span> 
(<span style="font-family:monospace">E:=est_premier_avec(n)</span>) et soit <span style="font-family:monospace">Ea</span> l’ensemble des <span style="font-style:italic">k</span>*<span style="font-style:italic">a</span> pour 
<span style="font-style:italic">k</span>∈ <span style="font-style:italic">E</span>. Tous les éléments de <span style="font-style:italic">Ea</span> sont distincts et inversibles dans 
ℤ/<span style="font-style:italic">n</span>ℤ,×: donc 
les ensembles <span style="font-style:italic">E</span> et <span style="font-style:italic">Ea</span> sont les mêmes. En faisant le produit de tous ces 
éléments on obtient Π<sub><span style="font-style:italic">k</span>∈ <span style="font-style:italic">E</span></sub><span style="font-style:italic">k</span>=Π<sub><span style="font-style:italic">k</span>∈ <span style="font-style:italic">Ea</span></sub><span style="font-style:italic">k</span>=<span style="font-style:italic">a</span><sup>φ</sup>(<span style="font-style:italic">n</span>)Π<sub><span style="font-style:italic">k</span>∈ <span style="font-style:italic">E</span></sub><span style="font-style:italic">k</span>,
Π<sub><span style="font-style:italic">k</span>∈ <span style="font-style:italic">E</span></sub><span style="font-style:italic">k</span> étant inversible dans ℤ/<span style="font-style:italic">n</span>ℤ,×
on en déduit que <span style="font-style:italic">a</span><sup>φ</sup>(<span style="font-style:italic">n</span>)=1.</p>
<h2 id="sec221" class="section">8.9  La fonction "estpremier"</h2>
<h3 id="sec222" class="subsection">8.9.1  Traduction Algorithmique</h3>
<p>
- Premier algorithme<br>
On va écrire un fonction booléenne de paramètre <span style="font-style:italic">N</span>, qui sera égale à
<span style="font-style:italic">VRAI</span> quand <span style="font-style:italic">N</span> est premier, et, à <span style="font-style:italic">FAUX</span> sinon.<br>
Pour cela, on cherche si <span style="font-style:italic">N</span> posséde un diviseur différent de 1 et 
inférieur ou égal à 
 <span style="font-style:italic">E</span>(√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>) (partie entière de racine de <span style="font-style:italic">N</span>).<br>
On traite le cas <span style="font-style:italic">N</span>=1 à part !<br>
On utilise une variable booléenne <span style="font-style:italic">PREM</span> qui est au départ à <span style="font-style:italic">VRAI</span>, et 
qui passe à <span style="font-style:italic">FAUX</span> dès que l’on rencontre un diviseur de <span style="font-style:italic">N</span>.<br>
</p><pre class="verbatim">Fonction estpremier(N)
local PREM, I, J
</pre><p>
<span style="font-family:monospace">E(</span>√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span><span style="font-family:monospace">) =&gt;J</span>
</p><pre class="verbatim">Si N = 1 alors
  FAUX=&gt;PREM
  sinon
  VRAI=&gt;PREM
fsi
2=&gt;I
</pre><p>
<span style="font-family:monospace">tantque PREM et I </span>≤<span style="font-family:monospace">J faire</span>
</p><pre class="verbatim">  si N mod I = 0 alors
     FAUX=&gt;PREM
     sinon
     I+1=&gt;I
  fsi 
ftantque
retourne PREM
ffonction
</pre><p>
-Première amélioration<br>
On peut remarquer que l’on peut tester si <span style="font-style:italic">N</span> est pair, et ensuite,
tester si <span style="font-style:italic">N</span> posséde un diviseur impair.
</p><pre class="verbatim">Fonction estpremier(N)
local PREM, I, J
</pre><p>
<span style="font-family:monospace">E(</span>√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span><span style="font-family:monospace">) =&gt;J <br>
 Si (N = 1) ou (N mod 2 = 0) et N</span>≠<span style="font-family:monospace">2 alors</span>
</p><pre class="verbatim">  FAUX=&gt;PREM
  sinon
  VRAI=&gt;PREM
fsi
3=&gt;I
</pre><p>
<span style="font-family:monospace">tantque PREM et I </span>≤<span style="font-family:monospace">J faire</span>
</p><pre class="verbatim">  si N mod I = 0 alors
     FAUX=&gt;PREM
     sinon
     I+2=&gt;I
  fsi 
ftantque
retourne PREM
ffonction
</pre><p>
- Deuxième amélioration<br>
On regarde si N est divisible par 2 ou par 3, sinon on regarde si N posséde un diviseur de la forme 6 × <span style="font-style:italic">k</span>−1  ou 6 × <span style="font-style:italic">k</span>+1  
(pour <span style="font-style:italic">k</span>∈ ℕ).
</p><pre class="verbatim">Fonction estpremier(N)
local PREM, I, J
</pre><p>
<span style="font-family:monospace">E(</span>√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span><span style="font-family:monospace">) =&gt;J</span>
</p><pre class="verbatim">Si (N = 1) ou (N mod 2 = 0) ou ( N mod 3 = 0) alors
  FAUX=&gt;PREM
  sinon
  VRAI=&gt;PREM
fsi
si N=2 ou N=3 alors 
VRAI=&gt;PREM
fsi
5=&gt;I
</pre><p>
<span style="font-family:monospace">tantque PREM et I </span>≤<span style="font-family:monospace">J faire</span>
</p><pre class="verbatim">  si (N mod I = 0) ou (N mod I+2 =0) alors
     FAUX=&gt;PREM
     sinon
     I+6=&gt;I
  fsi 
ftantque
retourne PREM
ffonction
</pre>
<h3 id="sec223" class="subsection">8.9.2  Traduction Xcas</h3>
<pre class="verbatim">estprem(n):={
//teste si n est premier
  local prem,j,k;
  if ((irem(n,2)==0) or (irem(n,3)===0) or (n==1)) {
     return(false);
  }
  if ((n==2) or (n==3)) {
     return(true);
  }
  prem:=true;
  k:=5;
  while ((k*k&lt;=n) and prem) {
     if (irem(n,k)==0 or irem(n,k+2)==0) {
        prem:=false;
     }
     else {
        k:=k+6;
     }
  }
  return(prem);
} 
</pre>
<h2 id="sec224" class="section">8.10  La fonction estpremc en utilisant le crible</h2>
<h3 id="sec225" class="subsection">8.10.1  Traduction algorithmique</h3>
<pre class="verbatim">fonction estpremc(N)
//utilise la fonction crible pour tester si n est premier
local PREM,S;
crible(floor(sqrt(N)))=&gt;PREM
dim(PREM)=&gt;S
si  (N=1) retourne(FAUX)
pour K de 1 a S faire
 si  (N mod ,PREM[K])=0)
    retourne(FAUX);
 fsi
fpour
retourne(VRAI)
ffonction
</pre>
<h3 id="sec226" class="subsection">8.10.2  Traduction Xcas</h3>
<pre class="verbatim">estpremc(n):={
//utilise la fonction crible pour tester si n est premier
local prem,s;
prem:=crible(floor(sqrt(n)));
s:=size(prem);
if (n==1) return(false);
for (k:=0;k&lt;s;k++){
 if (irem(n,prem[k])==0){
    return(false);
 } 
}
return(true);
}
</pre>
<h2 id="sec227" class="section">8.11  Méthode probabiliste de Mr Rabin</h2>
<p>
Si <span style="font-style:italic">N</span> est premier alors tous les nombres <span style="font-style:italic">K</span> strictement inférieurs à <span style="font-style:italic">N</span> 
sont premiers avec <span style="font-style:italic">N</span>, donc d’après le petit théorème de Fermat on a :<br>
 <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup> = 1 mod<span style="font-style:italic">N</span> <br>
Par contre, si <span style="font-style:italic">N</span> n’est pas premier, les entiers <span style="font-style:italic">K</span> (1&lt;<span style="font-style:italic">K</span>&lt;<span style="font-style:italic">N</span>) vérifiant :<br>
 <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup> = 1 mod<span style="font-style:italic">N</span> sont peu nombreux.<br>
 La méthode probabiliste de Rabin consiste à prendre au hasard un 
nombre <span style="font-style:italic">K</span> dans l’intervalle [2 ; <span style="font-style:italic">N</span>−1] (
1&lt; <span style="font-style:italic">K</span> &lt; <span style="font-style:italic">N</span> ) et à calculer :<br>
 <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup>   mod  <span style="font-style:italic">N</span> <br>
Si  <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup> = 1   mod  <span style="font-style:italic">N</span> on refait un autre tirage du nombre <span style="font-style:italic">K</span>, et, si 
 <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup> ≠ 1   mod  <span style="font-style:italic">N</span> on est sûr que <span style="font-style:italic">N</span> n’est pas premier.<br>
Si on obtient  <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup> = 1   mod  <span style="font-style:italic">N</span> pour 20 tirages successifs de <span style="font-style:italic">K</span> on
peut conclure que <span style="font-style:italic">N</span> est premier avec une probabilité d’erreur faible :<br>
on dit alors que <span style="font-style:italic">N</span> est pseudo-premier.<br>
Bien sûr cette méthode est employée pour savoir si de grands nombres 
sont pseudo-premiers mais on préfére utiliser la méthode de Miller-Rabin 
(cf <a href="#sec%3Amiller">8.12</a>)
qui est aussi une méthode probabiliste mais qui donne <span style="font-style:italic">N</span> premier avec une 
probabilité d’erreur plus faible (inférieure à (0.25)<sup>20</sup> si on a 
effectué 20 tirages, soit, une erreur de l’ordre de 10<sup>−12</sup>). 
</p>
<h3 id="sec228" class="subsection">8.11.1  Traduction Algorithmique</h3>
<p>
On suppose que :<br>
<span style="font-family:monospace">hasard(N)</span> donne un nombre entier au hasard entre 0 et <span style="font-style:italic">N</span>−1.<br>
 Le calcul de 
 <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup>   mod  <span style="font-style:italic">N</span> 
se fait grâce à l’algorithme de la puissance rapide (cf page <a href="#sec%3Apuimod">??</a>).<br>
On suppose que :<br>
<span style="font-family:monospace">powmod(K, P, N)</span> calcule  <span style="font-style:italic">K</span><sup><span style="font-style:italic">P</span></sup> mod<span style="font-style:italic">N</span> 
</p><pre class="verbatim">Fonction estprem(N)
local K, I, P
1=&gt;I
1=&gt;P
tantque P = 1 et I &lt; 20 faire
hasard(N-2)+2=&gt;K
powmod(K, N-1, N)=&gt;P
I+1=&gt;I
ftantque
Si P =1 alors
retourne VRAI
sinon
retourne FAUX
fsi
ffonction
</pre>
<h3 id="sec229" class="subsection">8.11.2  Traduction Xcas</h3>
<p> <a id="sec:Xcasrabin"></a>
La fonction <span style="font-family:monospace">powmod</span> existe dans <span style="font-family:monospace">Xcas</span> : il est donc inutile de la programmer. 
</p><pre class="verbatim">rabin(n):={
//teste par la methode de Rabin si n est pseudo-premier
local k,j,p;
j:=1;
p:=1;
while ((p==1) and (j&lt;20)) {
k:=2+rand(n-2);
p:=powmod(k,n-1,n);
j:=j+1;
}
if (p==1) {
return(true);
} 
return(false);
}
</pre>
<h2 id="sec230" class="section">8.12  Méthode probabiliste de Mr Miller-Rabin</h2>
<p> <a id="sec:miller"></a>
</p>
<h3 id="sec231" class="subsection">8.12.1  Un exemple</h3>
<p>
<span style="font-weight:bold">Rappel</span> Le théorème de Fermat :<br>
Si <span style="font-style:italic">n</span> est premier et si <span style="font-style:italic">k</span> est un entier quelconque alors <span style="font-style:italic">k</span><sup><span style="font-style:italic">n</span></sup>=<span style="font-style:italic">k</span> mod<span style="font-style:italic">n</span>.<br>
et donc <br>
Si <span style="font-style:italic">n</span> est premier et si <span style="font-style:italic">k</span> est premier avec <span style="font-style:italic">n</span> alors <span style="font-style:italic">k</span><sup><span style="font-style:italic">n</span>−1</sup>=1 mod<span style="font-style:italic">n</span>.<br>

Soit <span style="font-style:italic">N</span>=561=3*11*17. Il se trouve que l’on a :
pour tout <span style="font-style:italic">A</span> (<span style="font-style:italic">A</span>&lt;<span style="font-style:italic">N</span>), on a <span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span></sup>=<span style="font-style:italic">A</span>  mod  <span style="font-style:italic">N</span>, donc si <span style="font-style:italic">A</span> est premier avec
<span style="font-style:italic">N</span> on a <span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1</sup>=1  mod  <span style="font-style:italic">N</span>, le test de Rabin est donc en defaut,
seulement pour <span style="font-style:italic">A</span> non premier avec <span style="font-style:italic">N</span>.
Par exemple on a :<br>
3<sup>560</sup>=375  mod  561<br>
11<sup>560</sup>=154  mod  561<br>
17<sup>560</sup>=34  mod  561<br>
471<sup>560</sup>=375  mod  561<br>
mais pour tous les nombres <span style="font-style:italic">A</span> non multiples de 3, 11 ou 17 on a :<br>
<span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1</sup>=1  mod  561.<br>
Par exemple on a :<br>
5<sup>560</sup>=1  mod  561.<br>
52<sup><span style="font-style:italic">N</span>−1</sup>=1  mod  561.<br>
On risque donc de dire avec le test de Rabbin que 561 est pseudo-premier.<br>
Il faut donc affiner le test en remarquant que si <span style="font-style:italic">N</span> est premier l’équation:
<span style="font-style:italic">X</span><sup>2</sup>=1 mod<span style="font-style:italic">N</span> n’a pour solution que <span style="font-style:italic">X</span>=1 mod<span style="font-style:italic">N</span> ou <span style="font-style:italic">X</span>=−1 mod<span style="font-style:italic">N</span>.<br>
Le test de Miller-Rabin est basé sur cette remarque.<br>
Pour <span style="font-style:italic">N</span>=561, <span style="font-style:italic">N</span>−1=560, on a : 
560=35*2<sup>16</sup> <br>
13<sup>35</sup>=208  mod  561<br>
13<sup>35*2</sup>=67  mod  561<br>
13<sup>35*4</sup>=1  mod  561<br>
13<sup>35*8</sup>=1  mod  561...<br>
On vient de trouver que 67 est solution de <span style="font-style:italic">X</span><sup>2</sup>=1 mod561 donc on peut 
affirmer que 561 n’est pas premier.<br>
<span style="font-style:italic">A</span>=13 vérifie le test de Rabin car 13<sup>560</sup>=1  mod  561<br>
mais ne vérifie pas le test de Miller-Rabin car <br>
13<sup>35*2</sup>≠ −1 mod561 et 13<sup>35*2</sup> ≠ 1 mod561 <br>
et pourtant 13<sup>35*4</sup>=13<sup>35*4</sup>=1  mod  561<br>
Par contre ce test ne suffit pas pour affirmer qu’un nombre est premier car :<br>
101<sup>35</sup>=560=−1 mod561 et donc 101<sup>35*2</sup>=1 mod561 et cela ne 
fournit pas de solutions autre que 1 ou -1 à l’équation <span style="font-style:italic">X</span><sup>2</sup>=1 mod561. </p>
<h3 id="sec232" class="subsection">8.12.2  L’algorithme</h3>
<p>
L’algorithme est basé sur :<br>
1/ Le petit théorème de Fermat:<br>
 <span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1</sup> = 1 mod<span style="font-style:italic">N</span> si <span style="font-style:italic">N</span> est premier et si <span style="font-style:italic">A</span>&lt;<span style="font-style:italic">N</span>.<br>
2/ Si <span style="font-style:italic">N</span> est premier, l’équation  <span style="font-style:italic">X</span>*<span style="font-style:italic">X</span> = 1 mod<span style="font-style:italic">N</span> n’a pas d’autres 
solutions que <span style="font-style:italic">X</span>=1 mod<span style="font-style:italic">N</span> ou <span style="font-style:italic">X</span>=−1 mod<span style="font-style:italic">N</span>.<br>
En effet il existe un 
entier <span style="font-style:italic">k</span> vérifiant  <span style="font-style:italic">X</span>*<span style="font-style:italic">X</span>−1=(<span style="font-style:italic">X</span>+1)*(<span style="font-style:italic">X</span>−1)=<span style="font-style:italic">k</span>*<span style="font-style:italic">N</span> donc,<br>
puisque <span style="font-style:italic">N</span> est premier, <span style="font-style:italic">N</span> divise <span style="font-style:italic">X</span>+1 ou <span style="font-style:italic">X</span>−1. On a donc soit 
<span style="font-style:italic">X</span>=1 mod<span style="font-style:italic">N</span> ou <span style="font-style:italic">X</span>=−1 mod<span style="font-style:italic">N</span>.<br>
On élimine les nombres pairs que l’on sait ne pas être premiers.<br>
On suppose donc que <span style="font-style:italic">N</span> est impair et donc que <span style="font-style:italic">N</span>−1 est pair et s’écrit :<br>
<span style="font-style:italic">N</span>−1=2<sup><span style="font-style:italic">t</span></sup>*<span style="font-style:italic">Q</span> avec <span style="font-style:italic">t</span>&gt;0 et <span style="font-style:italic">Q</span> impair.<br>
Si <span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1</sup>=1 mod<span style="font-style:italic">N</span> c’est que <span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1</sup> mod<span style="font-style:italic">N</span> est le carré de 
<span style="font-style:italic">B</span>=<span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1/2</sup>=<span style="font-style:italic">A</span><sup>2<sup><span style="font-style:italic">t</span>−1</sup><span style="font-style:italic">Q</span></sup> mod<span style="font-style:italic">N</span>.<br>
Si on trouve <span style="font-style:italic">B</span>≠ 1 mod<span style="font-style:italic">N</span> et <span style="font-style:italic">B</span>≠ −1 mod<span style="font-style:italic">N</span> on est sûr que <span style="font-style:italic">N</span> 
n’est pas premier.<br>
Si <span style="font-style:italic">B</span>=−1 mod<span style="font-style:italic">N</span> on recommence avec une autre valeur de <span style="font-style:italic">A</span>.<br>
Si <span style="font-style:italic">B</span>=1 mod<span style="font-style:italic">N</span> on peut recommencer le même raisonnement si 
<span style="font-style:italic">N</span>−1/2 est encore pair 
(<span style="font-style:italic">B</span>=<span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1/2</sup>=(<span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1/4</sup>)<sup>2</sup> mod<span style="font-style:italic">N</span>) ou <br>
si <span style="font-style:italic">N</span>−1/2 est impair, on recommence avec une autre valeur de <span style="font-style:italic">A</span>.<br>
On en déduit que :<br>
si <span style="font-style:italic">N</span>−1=2<sup><span style="font-style:italic">t</span></sup>.<span style="font-style:italic">Q</span> et <br>
si  <span style="font-style:italic">A</span><sup><span style="font-style:italic">N</span>−1</sup> = 1 mod<span style="font-style:italic">N</span> et <br>
si <span style="font-style:italic">A</span><sup><span style="font-style:italic">Q</span></sup> ≠ 1 mod<span style="font-style:italic">N</span>  et <br>
si pour 0 ≤ <span style="font-style:italic">ex</span> &lt; <span style="font-style:italic">t</span> on a <span style="font-style:italic">A</span><sup>2<sup><span style="font-style:italic">ex</span></sup>.<span style="font-style:italic">Q</span></sup> ≠ −1 mod<span style="font-style:italic">N</span> c’est que <span style="font-style:italic">N</span> n’est pas premier.<br>
D’où la définition :<br>
Soit <span style="font-style:italic">N</span> un entier positif impair égal à 1+2<sup><span style="font-style:italic">t</span></sup>*<span style="font-style:italic">Q</span> avec <span style="font-style:italic">Q</span> impair.<br>
On dit que <span style="font-style:italic">N</span> est pseudo-premier fort de base <span style="font-style:italic">A</span> si :<br>
soit <span style="font-style:italic">A</span><sup><span style="font-style:italic">Q</span></sup>=1 mod<span style="font-style:italic">N</span><br>
soit si il existe <span style="font-style:italic">e</span>, 0 ≤ <span style="font-style:italic">e</span>&lt;<span style="font-style:italic">t</span> tel que <span style="font-style:italic">A</span><sup><span style="font-style:italic">Q</span>*2<sup><span style="font-style:italic">e</span></sup></sup>=−1 mod<span style="font-style:italic">N</span>.<br>
On voit facilement qu’un nombre premier impair est pseudo-premier fort dans 
n’importe quelle base <span style="font-style:italic">A</span> non divisible par <span style="font-style:italic">N</span>.<br>
Réciproquement on peut montrer que si <span style="font-style:italic">N</span>&gt;4 n’est pas premier, il existe
au plus <span style="font-style:italic">N</span>/4 bases <span style="font-style:italic">A</span> (1&lt;<span style="font-style:italic">A</span>&lt;<span style="font-style:italic">N</span>) pour lesquelles <span style="font-style:italic">N</span> est pseudo-premier fort 
de base <span style="font-style:italic">A</span>.<br>
 
L’algorithme va choisir au hasard au plus 20 nombres <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> compris entre 2
et <span style="font-style:italic">N</span>−1 : si <span style="font-style:italic">N</span> est pseudo-premier fort de base <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> pour <span style="font-style:italic">k</span>=1..20 alors
<span style="font-style:italic">N</span> est premier avec une tres forte probabilité égale à 
(1/4)<sup>20</sup>(&lt;10<sup>−12</sup>).<br>
Bien sûr cette méthode est employée pour savoir si de grands nombres 
sont pseudo-premiers.
</p>
<h3 id="sec233" class="subsection">8.12.3  Traduction Algorithmique</h3>
<p>
On suppose que :<br>
<span style="font-family:monospace">hasard(N)</span> donne un nombre entier au hasard entre 0 et <span style="font-style:italic">N</span>−1.<br>
 Le calcul de 
 <span style="font-style:italic">K</span><sup><span style="font-style:italic">N</span>−1</sup> mod<span style="font-style:italic">N</span> 
se fait grâce à l’algorithme de la puissance rapide (cf page <a href="#sec%3Apuimod">??</a>).<br>
On notera :<br>
<span style="font-family:monospace">powmod(K, P, N)</span> la fonction qui calcule  <span style="font-style:italic">K</span><sup><span style="font-style:italic">P</span></sup> mod  <span style="font-style:italic">N</span> 
</p><pre class="verbatim">Fonction Miller(N)
local Q,P,t,C,A,B,ex
si (N=2) alors retourne FAUX
si (N mod 2)==0) alors retourne FAUX
N-1=&gt;Q
0=&gt;t
tantque (Q mod 2 =0) faire
t+1=&gt;t
E(Q/2)=&gt;Q
ftantque
//N-1=2^t*Q
20=&gt;C
VRAI=&gt;P
tantque (C&gt;0 et P) faire
hasard(N-2)+2=&gt;A
0=&gt;ex
powmod(A, Q, N)=&gt;B
si B&lt;&gt;1 alors
tant que (B&lt;&gt;1) et (B&lt;&gt;N-1) et (ex&lt;t-1) faire
ex+1=&gt;ex
powmod(B,2,n)=&gt;B
ftantque
si (B&lt;&gt;N-1) alors 
FAUX=&gt;P
fsi
C-1=&gt;C
ftantque
retourne P
ffonction
</pre>
<h3 id="sec234" class="subsection">8.12.4  Traduction Xcas</h3>
<p> <a id="sec:xcasmiller"></a>
La fonction <span style="font-family:monospace">powmod</span> existe dans <span style="font-family:monospace">Xcas</span> : il est donc inutile de la programmer.
</p><pre class="verbatim">miller(n):={
local p,q,t,c,a,b,ex;
if (n==2){return(true);}
if (irem(n,2)==0) {return(false);}
q:=n-1;
t:=0;
while (irem(q,2)==0) {
t:=t+1;
q:=iquo(q,2);
}
//ainsi n-1=q*2^t
c:=20;
p:=true;
while ((c&gt;0) and p) {
//rand(k) renvoie un nombre entier de [0,k-1] si k&lt;999999999
if (n&lt;=10^9) {a:=2+rand(n-2);} else {a:=2+rand(999999999);}
ex:=0;
b:=powmod(a,q,n);
//si b!=1 on regarde si b^{2^(ex)}=-1 mod n (ex=0..t-1) 
if (b!=1) {
while ((b!=1) and (b!=n-1) and (ex&lt;=t-2)) {
b:=powmod(b,2,n);
ex:=ex+1;}
//si b!=n-1 c'est que n n'est pas premier
if (b!=n-1) {p:=false;}
}
c:=c-1;
}
return(p);
};
</pre>
<h2 id="sec235" class="section">8.13  Numération avec Xcas</h2>
<p><a id="hevea_default83"></a><a id="hevea_default84"></a><a id="hevea_default85"></a>
On a besoin ici des fonctions de <span style="font-family:monospace">Xcas</span> :<br>
- <span style="font-family:monospace">asc</span> qui convertit un caractère
ou une chaîne de caractères,
en une liste de nombres et, <br>
- <span style="font-family:monospace">char</span> qui convertit un nombre ou
une liste de nombres en un caractère 
ou une chaîne de caractères.<br>
On a :<br>
<span style="font-family:monospace">char(n)</span> pour <span style="font-style:italic">n</span> entier, (0 ≤ <span style="font-style:italic">n</span> ≤ 255) donne le caractère 
ayant comme code ASCII l’entier <span style="font-style:italic">n</span>.<br>
<span style="font-family:monospace">char(l)</span> pour une liste d’entiers <span style="font-style:italic">l</span> (0 ≤ <span style="font-style:italic">l</span>[<span style="font-style:italic">j</span>] ≤ 255), donne la 
chaîne de caractères dont 
les caractères ont pour code ASCII les entiers <span style="font-style:italic">l</span>[<span style="font-style:italic">j</span>] qui composent
la liste <span style="font-style:italic">l</span>.<br>
<span style="font-family:monospace">asc(mot)</span> renvoie la liste des codes ASCII des lettres composant le mot.<br>
<span style="font-weight:bold">Exemples</span><br>
<span style="font-family:monospace">asc("A")=[65]</span><br>
<span style="font-family:monospace">char(65)="A"</span><br>
<span style="font-family:monospace">asc("Bonjour")= [66,111,110,106,111,117,114]</span><br>
<span style="font-family:monospace">char([66,111,110,106,111,117,114])="Bonjour"</span><br>
<span style="font-weight:bold">Remarque</span> :<br>
Il existe aussi la fonction <span style="font-family:monospace">ord</span> qui a pour argument une chaîne de 
caractères mais qui renvoie le code ASCII de la première lettre de la
chaîne de caractères :<br>
<br>
<span style="font-family:monospace">ord("B")= 66</span>
<span style="font-family:monospace">ord("Bonjour")= 66</span>
</p>
<h3 id="sec236" class="subsection">8.13.1  Passage de l’écriture en base dix à une écriture en base b</h3>
<h4 id="sec237" class="subsubsection">La base b est inférieure ou égale à 10</h4>
<p>
- Version itérative<br>
Si <span style="font-style:italic">n</span>&lt;<span style="font-style:italic">b</span>, il n’y a rien à faire : l’écriture en base <span style="font-style:italic">b</span> est la même que 
l’écriture en base dix et est <span style="font-style:italic">n</span>.
On divise <span style="font-style:italic">n</span> par <span style="font-style:italic">b</span> : <span style="font-style:italic">n</span>=<span style="font-style:italic">b</span>*<span style="font-style:italic">q</span>+<span style="font-style:italic">r</span> avec 0≤ <span style="font-style:italic">r</span>&lt;<span style="font-style:italic">b</span>).<br>
Le reste <span style="font-style:italic">r</span> de la division euclidienne de <span style="font-style:italic">n</span> par <span style="font-style:italic">b</span> 
(<span style="font-family:monospace">r:=irem(n,b)</span>) donne le dernier chiffre de l’écriture en base <span style="font-style:italic">b</span> de 
<span style="font-style:italic">n</span>.
L’avant dernier chiffre de l’écriture en base <span style="font-style:italic">b</span> de <span style="font-style:italic">n</span> sera donné par le 
le reste de la division euclidienne de <span style="font-style:italic">q</span> (<span style="font-family:monospace">q:=iquo(n,b)</span>) par <span style="font-style:italic">b</span>.
On fait donc une boucle en remplacant <span style="font-style:italic">n</span> par <span style="font-style:italic">q</span> (<span style="font-family:monospace">n:=iquo(n,b)</span>) 
tant que <span style="font-style:italic">n</span> ≥ <span style="font-style:italic">b</span> en mettant à chaque étape <span style="font-family:monospace">r:=irem(n,b)</span> au 
début de la liste qui doit renvoyer le résultat.<br>
On écrit la fonction itérative <span style="font-family:monospace">ecritu</span>
qui renvoie la liste des chiffres de <span style="font-style:italic">n</span> en base <span style="font-style:italic">b</span> :
</p><pre class="verbatim">ecritu(n,b):={
//n est en base 10 et b&lt;=10, ecrit est une fonction iterative 
//renvoie la liste des caracteres de l'ecriture de n en base b  
local L;
L:=[];
while (n&gt;=b){
L:=concat([irem(n,b)],L);
n:=iquo(n,b);
}
L:=concat([n],L);
return(L);
}
</pre><p>
- Version récursive<br>
Si <span style="font-style:italic">n</span>&lt;<span style="font-style:italic">b</span>, l’écriture en base <span style="font-style:italic">b</span> est la même que 
l’écriture en base dix et est <span style="font-style:italic">n</span>.<br>
Si <span style="font-style:italic">n</span> ≥ <span style="font-style:italic">b</span>, l’écriture en base <span style="font-style:italic">b</span> de <span style="font-style:italic">n</span> est formée par
l’écriture en base <span style="font-style:italic">b</span> de <span style="font-style:italic">q</span> suivi de <span style="font-style:italic">r</span>, lorsque <span style="font-style:italic">q</span> et <span style="font-style:italic">r</span> sont le
quotient et le reste de la division euclidienne de <span style="font-style:italic">n</span> par <span style="font-style:italic">b</span> 
(<span style="font-style:italic">n</span>=<span style="font-style:italic">b</span>*<span style="font-style:italic">q</span>+<span style="font-style:italic">r</span> avec 0≤ <span style="font-style:italic">r</span>&lt;<span style="font-style:italic">b</span>).<br>
On écrit la fonction récursive <span style="font-family:monospace">ecritur</span>
qui renvoie la liste des chiffres de <span style="font-style:italic">n</span> en base <span style="font-style:italic">b</span> :
</p><pre class="verbatim">ecritur(n,b):={
//n est en base 10 et b&lt;=10, ecritur est recursive 
//renvoie la liste des caracteres de l'ecriture de n en base b
if (n&gt;=b)
return(concat(ecritur(iquo(n,b),b),irem(n,b)));
else
return([n]);
}
</pre>
<h4 id="sec238" class="subsubsection">La base b est inférieure ou égale à 36</h4>
<p>
On choisit 36 symboles pour écrire un nombre :
les 10 chiffres 0,1..9 et les 26 lettres majuscules <span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>,..,<span style="font-style:italic">Z</span>.<br>
On transforme tout nombre positif ou nul <span style="font-style:italic">n</span> (<span style="font-style:italic">n</span>&lt;<span style="font-style:italic">b</span>) en un caractère : 
ce caractére est soit un chiffre (si <span style="font-style:italic">n</span>&lt;10) soit une lettre (<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>...<span style="font-style:italic">Z</span>) 
(si 9&lt;<span style="font-style:italic">n</span>&lt;36).
</p><pre class="verbatim">chiffre(n,b):={
//transforme n (0&lt;=n&lt;b) en son caractere ds la base b 
if (n&gt;9) 
n:=char(n+55);
else 
n:=char(48+n);
return(n);
}
</pre><p>
On obtient alors la fonction itérative <span style="font-family:monospace">ecritu</span>:
</p><pre class="verbatim">ecritu(n,b):={
//n est en base 10 et b&lt;=36, ecritu est une fonction iterative 
//renvoie la liste des caracteres de l'ecriture de n en base b  
local L,r,rc;
L:=[];
while (n&gt;=b){
r:=irem(n,b);
rc:=chiffre(r,b);
L:=concat([rc],L);
n:=iquo(n,b);
}
n:=chiffre(n,b);
L:=concat([n],L);
return(L);
}
</pre><p>
- Version recursive
</p><pre class="verbatim">ecriture(n,b):={
//n est en base 10 et b&lt;=36, ecriture est une fonction recursive 
//renvoie la liste des caracteres de l'ecriture de n en base b
local r,rc;
if (n&gt;=b){
r:=irem(n,b);
rc:=chiffre(r,b);
return(append(ecriture(iquo(n,b),b),rc));
}
else {
return([chiffre(n,b)]);
}
}
</pre><p>
En utilisant la notion de séquence on peut aussi écrire :
</p><pre class="verbatim">ecrit(n,b):= { 
//renvoie la sequence des chiffres de n dans la base b 
local m,u,cu; 
  m:=(NULL);  
  while(n!=0){ 
      u:=(irem(n,b));  
      if (u&gt;9) { 
          cu:=(char(u+55));  
        } 
       else { 
          cu:=(char(u+48));  
        };  
      m:=(cu,m);  
      n:=(iquo(n,b));  
    };  
  return(m); 
}
</pre>
<h3 id="sec239" class="subsection">8.13.2  Passage de l’écriture en base b de n à l’entier n</h3>
<p>
Il faut convertir ici chaque caractère en sa valeur (on convertit le 
caractère contenu dans m en le nombre nm).<br>
Si <span style="font-style:italic">m</span>=(<span style="font-style:italic">c</span>0,<span style="font-style:italic">c</span>1,<span style="font-style:italic">c</span>2,<span style="font-style:italic">c</span>3) alors <span style="font-style:italic">n</span>=<span style="font-style:italic">c</span>0*<span style="font-style:italic">b</span><sup>3</sup>+<span style="font-style:italic">c</span>1*<span style="font-style:italic">b</span><sup>2</sup>+<span style="font-style:italic">c</span>2*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>3.<br>
On calcule <span style="font-style:italic">n</span> en se servant de l’algorithme de Hörner (cf <a href="#sec%3Ahorner">8.15</a>).
En effet le calcul de <span style="font-style:italic">n</span>=<span style="font-style:italic">c</span>0*<span style="font-style:italic">b</span><sup>3</sup>+<span style="font-style:italic">c</span>1*<span style="font-style:italic">b</span><sup>2</sup>+<span style="font-style:italic">c</span>2*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>3 revient à calculer la 
valeur du polynôme <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">c</span>0*<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">c</span>1*<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">c</span>2*<span style="font-style:italic">x</span>+<span style="font-style:italic">c</span>3 pour <span style="font-style:italic">x</span>=<span style="font-style:italic">b</span>.<br>
<span style="font-style:italic">n</span> va contenir successivement :<br>
0 (<span style="font-style:italic">n</span>:=0) puis<br>
<span style="font-style:italic">c</span>0 (<span style="font-style:italic">n</span>:=<span style="font-style:italic">n</span>*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>0) puis <br>
<span style="font-style:italic">c</span>0*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>1 (<span style="font-style:italic">n</span>:=<span style="font-style:italic">n</span>*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>1) puis<br>
<span style="font-style:italic">c</span>0*<span style="font-style:italic">b</span><sup>2</sup>+<span style="font-style:italic">c</span>1*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>2=(<span style="font-style:italic">c</span>0*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>1)*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>2 (<span style="font-style:italic">n</span>:=<span style="font-style:italic">n</span>*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>2) et enfin<br>
<span style="font-style:italic">c</span>0*<span style="font-style:italic">b</span><sup>3</sup>+<span style="font-style:italic">c</span>1*<span style="font-style:italic">b</span><sup>2</sup>+<span style="font-style:italic">c</span>2*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>3 (<span style="font-style:italic">n</span>:=<span style="font-style:italic">n</span>*<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>3).<br>
On écrit donc la fonction nombre dans <span style="font-family:monospace">Xcas</span> : 
</p><pre class="verbatim">nombre(m,b):={
local s,k,am,nm,n; 
  s:=(size(m));  
  n:=(0);  
  k:=(0);  
  if (s!=0) { 
      while(k&lt;s){ 
          am:=(asc(m[k])[0]);  
          if (am&gt;64) { 
              nm:=(am-55);  
            } 
           else { 
              nm:=(am-48);  
            };  
          if (nm&gt;(b-1)) { 
              return("erreur");  
            }  
          n:=(n*b+nm);  
          k:=(k+1);  
        };  
    }   
  return(n);
}
</pre>
<h3 id="sec240" class="subsection">8.13.3  Un exercice et sa solution</h3>
<h4 id="sec241" class="subsubsection">L’énoncé</h4>
<p>
On veut afficher en base dix la suite ordonnée des entiers dont l’écriture 
en base trois ne comporte que des 0 ou des 1 (pas de 2).
</p><ol class="enumerate" type=1><li class="li-enumerate">
Calculer à la main les huit premiers termes de cette suite.
</li><li class="li-enumerate">Décrire un algorithme qui donne les 128 premiers termes de cette suite.
</li><li class="li-enumerate">Écrire une fonction qui renvoie la liste des <span style="font-style:italic">n</span> premiers termes de 
cette suite.
</li></ol>
<h4 id="sec242" class="subsubsection">La correction</h4>
<ol class="enumerate" type=1><li class="li-enumerate">
Voici les 8 premiers termes de cette suite :<br>
<span style="font-family:monospace">[0,1,3,4,9,10,12,13]</span> dont lécriture en base 3 est :<br>
<span style="font-family:monospace">[[0],[1],[1,0],[1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]</span><br>
</li><li class="li-enumerate">Il y a plusieurs algorithmes possibles :
<ul class="itemize"><li class="li-itemize">
On écrit les nombres de 0 à <span style="font-style:italic">N</span> en base 3 et met dans la liste 
réponse ceux qui ne contiennent pas de 2 dans leur écriture en base 3.
On s’arrete quand la liste réponse contient <span style="font-style:italic">n</span> éléments,
</li><li class="li-itemize">On écrit les nombres de 0 à <span style="font-style:italic">n</span> en base 2 et on considère cette 
écriture comme étant celle d’un nombre écrit en base 3.
</li><li class="li-itemize">On regarde comment on peut les termes de la suite se déduisent les 
uns des autres. On peut remarquer que :<br>
0=3*0,1=3*0+1,3=3*1,4=3*1+1,9=3*3,10=3*3+1,12=3*4,13=3*4+1....
</li><li class="li-itemize">On regarde comment sont faits les termes de la suite.
On peut remarquer que :<br>
3=0+3,4=1+3 donc 3 et 4 ont èté obtenu à partir de
0 et 1 en leur ajoutant 3,<br>
9=0+9,10=1+9,12=3+9,13=4+9 donc 9,10,11 et 12 ont èté obtenu à partir de
0,1,3 et 4 en leur ajoutant 9... 
Les 8 prochains termes de cette suite seront obtenus en ajoutant 3<sup>3</sup>
à chacun des 8 premiers. On obtient ainsi les 16 premiers termes
de cette suite. Puis les 16 prochains termes de cette suite seront obtenus en 
ajoutant 3<sup>4</sup> à chacun des 16 premiers termes etc...
</li></ul>
</li><li class="li-enumerate">On va traduire avec <span style="font-family:monospace">Xcas</span> chacun des algorithmes ci-dessus.
Voici les fonctions de <span style="font-family:monospace">Xcas</span> que l’on va utiliser :
<ul class="itemize"><li class="li-itemize">
La fonction <span style="font-family:monospace">est_element(L,a)</span> qui teste si <span style="font-family:monospace">a</span> est dans la 
liste <span style="font-family:monospace">L</span> et qui renvoie <span style="font-family:monospace">0</span> ou <span style="font-family:monospace">n+1</span> si <span style="font-family:monospace">n</span> est l’indice de
la première occurence de <span style="font-family:monospace">a</span> dans <span style="font-family:monospace">L</span>,
</li><li class="li-itemize">La fonction <span style="font-family:monospace">convert(n,base,b)</span> (resp <span style="font-family:monospace">convert(L,base,b)</span>)
qui convertit un entier <span style="font-family:monospace">n</span> en la liste des coefficients en base <span style="font-family:monospace">b</span> 
dans l’ordre croissant (resp qui convertit la liste <span style="font-family:monospace">L</span> des coefficients 
en base <span style="font-family:monospace">b</span> dans l’odre croissant en un entier <span style="font-family:monospace">n</span>).
</li><li class="li-itemize">Pour ajouter un nombre <span style="font-family:monospace">a</span> à chacun des termes 
d’une liste <span style="font-family:monospace">L</span> on peut utiliser : la fonction <span style="font-family:monospace">map</span> et écrire 
<span style="font-family:monospace">map(L,x-&gt;x+a)</span> ou bien utiliser
l’addition de <span style="font-family:monospace">L</span> et de la liste <span style="font-family:monospace">[a,a..a]</span> ayant la longueur de
<span style="font-family:monospace">L</span> et écrire <span style="font-family:monospace">L+[a$dim(L)]</span>
</li><li class="li-itemize">Pour faire les opérations : multiplier par 3 et multiplier par 3 puis 
ajouter 1 sur chacun des termes d’une liste <span style="font-family:monospace">L</span>,
on peut utiliser : la fonction <span style="font-family:monospace">map</span> et écrire 
<span style="font-family:monospace">mat2list(map(L,x-&gt;[3*x,3*x+1]))</span> car <span style="font-family:monospace">map(L,x-&gt;[3*x,3*x+1])</span>renvoie une matrice et <span style="font-family:monospace">mat2list</span> transforme une matrice en liste.
</li></ul>
Voici les programmes correspondants aux algorithmes décrits précédement
à la question 2. On tape les fonctions <span style="font-family:monospace">pasde21(n)</span> ..<span style="font-family:monospace">pasde24(n)</span>
qui renvoient les <span style="font-family:monospace">n</span> premiers termes de la liste demandée. 
La variable <span style="font-family:monospace">p</span> contient à chaque étape la dimension de la liste 
<span style="font-family:monospace">L</span>.
<ul class="itemize"><li class="li-itemize">
<pre class="verbatim">pasde21(n):={
  local L,j,J,p;
  L:=[0];
  p:=1;
  j:=1;
  tantque p&lt;n faire
    J:=convert(j,base,3);
    si not(est_element(2,J)) alors 
      L:= append(L,j);
      p:=p+1;
    fsi;
    j:=j+1;
  ftantque;
  retourne L;
}
:;

</pre>
</li><li class="li-itemize"><pre class="verbatim">pasde22(n):={
  local J,a,p,L;
  L:=[];
  pour p de 0 jusque n-1 faire
    J:=convert(p,base,2);
    a:=convert(J,base,3);
    L:=append(L,a)
  fpour
  retourne L;
}:;
</pre>
</li><li class="li-itemize">À la fin de la boucle <span style="font-family:monospace">tantque</span>, <span style="font-family:monospace">L</span> a <span style="font-style:italic">p</span>≥ <span style="font-style:italic">n</span> éléments : 
il faut donc raccourcir la liste <span style="font-family:monospace">L</span> (<span style="font-family:monospace">L:=mid(L,0,n)</span>)
<pre class="verbatim">pasde23(n):={
  local L,p;
  L:=[0];
  p:=1;
  tantque p&lt;n faire
    L:=mat2list(map(L,x-&gt;[x*3,x*3+1]));
    p:=2*p;
  ftantque;
  L:=mid(L,0,n);
  retourne L;
}
:;
</pre>
Dans le programme ci-dessus la liste <span style="font-family:monospace">L</span> est recréée à chaque 
itération, il est donc préférable de modifier ce programme pour qu’à 
chaque itération on ne calcule que les nouveaux termes dans la liste 
 <span style="font-family:monospace">LA</span> et ce sont ces nouveaux termes qui créront les termes suivants...
<pre class="verbatim">pasde23b(n):={
  local L,p,LA;
  L:=[0,1];
  LA:=[1];
  p:=2;
  tantque p&lt;n faire 
  LA:=mat2list(map(LA,x-&gt;[x*3,x*3+1]));
  L:=concat(L,LA);
  p:=2*p;
  ftantque;
  L:=mid(L,0,n);
  retourne L;
}
:;
</pre>
À la fin de la boucle <span style="font-family:monospace">tantque</span>, <span style="font-family:monospace">L</span> a 2<sup><span style="font-style:italic">j</span></sup>=<span style="font-style:italic">p</span>≥ <span style="font-style:italic">n</span> éléments : 
il faut raccourcir la liste <span style="font-family:monospace">L</span> (<span style="font-family:monospace">L:=mid(L,0,n)</span>) et on calcule des 
termes pour rien...On modifie encore le programme, mais comme la liste <span style="font-family:monospace">LA</span>
engendre les termes 2 par 2, on calcule quand même un terme de trop si 
<span style="font-family:monospace">n</span> est impair.<pre class="verbatim">pasde23t(n):={
  local L,p,LA;
  L:=[0,1];
  LA:=[1];
  p:=2;
  tantque 2p&lt;=n faire 
  LA:=mat2list(map(LA,x-&gt;[x*3,x*3+1]));
  L:=concat(L,LA);
  p:=2*p;
  ftantque;
  LA:=mat2list(map(mid(LA,0,iquo(n-p+1,2)),x-&gt;[x*3,x*3+1]));
  L:=concat(L,LA);
  retourne mid(L,0,n);
}
:;
</pre></li><li class="li-itemize">La variable <span style="font-family:monospace">j</span> contient le nombre d’iterations : à chaque 
étape on a <span style="font-style:italic">p</span>=2<sup><span style="font-style:italic">j</span></sup> et <span style="font-style:italic">puis</span>3<span style="font-style:italic">j</span>=3<sup><span style="font-style:italic">j</span></sup>.
<pre class="verbatim">pasde24(n):={
  local L,j,p,puis3j;
  L:=[0];
  j:=0;
  p:=1;
  puis3j:=1;
  tantque p&lt;n faire
    L:=concat(L,L+[puis3j$p]);
    //L:=concat(L,map(L,x-&gt;x+puis3j));
    j:=j+1;
    puis3j:=3*puis3j;
    p:=2*p;
  ftantque;
  L:=mid(L,0,n);
  retourne L;
}
:;
</pre>
À la fin de la boucle <span style="font-family:monospace">tantque</span>, <span style="font-family:monospace">L</span> a 2<sup><span style="font-style:italic">j</span></sup>=<span style="font-style:italic">p</span>&gt;=<span style="font-style:italic">n</span> éléments : il 
faut donc raccourcir la liste <span style="font-family:monospace">L</span> (<span style="font-family:monospace">L:=mid(L,0,n)</span>) et on calcule des 
termes pour rien...On modifie donc le programme :
<pre class="verbatim">pasde24b(n):={
  local L,j,p,puis3j;
  L:=[0];
  j:=0;
  p:=1;
  puis3j:=1;
  tantque 2*p&lt;=n faire
    L:=concat(L,L+[puis3j$p]);
    j:=j+1;
    puis3j:=3*puis3j;
    p:=2*p;
  ftantque;
  L:=concat(L,mid(L,0,n-p)+[puis3j$(n-p)]);;
  retourne L;
}:;
</pre>
</li></ul>
Voici ce que l’on obtient :<br>

<img src="casrouge003.png"><p>Ce qui montre que le dernier algorithme est le meilleur...
</p></li></ol>
<h2 id="sec243" class="section">8.14  Écriture d’un entier dans une base rationnelle</h2>
<p>
Soient deux entiers <span style="font-style:italic">p</span>,<span style="font-style:italic">q</span>, premiers entre eux tel que <span style="font-style:italic">q</span>&lt;<span style="font-style:italic">p</span>. 
On veut écrire un entier <span style="font-style:italic">n</span> sous la forme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">n</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">n</span><sub><span style="font-style:italic">k</span></sub>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">q</span></td></tr>
</table></td><td class="dcell">)<sup><span style="font-style:italic">k</span></sup>  avec  <span style="font-style:italic">n</span><sub><span style="font-style:italic">k</span></sub>&lt;<span style="font-style:italic">p</span> </td></tr>
</table><p>
On définit la suite :<br>
<span style="font-style:italic">u</span>(0)=<span style="font-style:italic">n</span>, <span style="font-style:italic">u</span>(1)=<span style="font-style:italic">iquo</span>(<span style="font-style:italic">u</span>(0),<span style="font-style:italic">p</span>)*<span style="font-style:italic">q</span>, <span style="font-style:italic">u</span>(<span style="font-style:italic">k</span>+1)=<span style="font-style:italic">iquo</span>(<span style="font-style:italic">u</span>(<span style="font-style:italic">k</span>),<span style="font-style:italic">p</span>)*<span style="font-style:italic">q</span> 
<span style="font-style:italic">u</span> est une suite décroissante donc il existe <span style="font-style:italic">s</span> tel que <span style="font-style:italic">u</span>(<span style="font-style:italic">s</span>)=0.<br>
On a :<br>
<span style="font-style:italic">u</span>(0)=<span style="font-style:italic">iquo</span>(<span style="font-style:italic">u</span>(0,<span style="font-style:italic">p</span>)*<span style="font-style:italic">p</span>+<span style="font-style:italic">irem</span>(<span style="font-style:italic">u</span>(0),<span style="font-style:italic">p</span>)=<span style="font-style:italic">u</span>(1)*<span style="font-style:italic">p</span>/<span style="font-style:italic">q</span>+<span style="font-style:italic">irem</span>(<span style="font-style:italic">u</span>(0),<span style="font-style:italic">p</span>)<br>
<span style="font-style:italic">u</span>(1)=<span style="font-style:italic">iquo</span>(<span style="font-style:italic">u</span>(1,<span style="font-style:italic">p</span>)*<span style="font-style:italic">p</span>+<span style="font-style:italic">irem</span>(<span style="font-style:italic">u</span>(1),<span style="font-style:italic">p</span>)=<span style="font-style:italic">u</span>(2)*<span style="font-style:italic">p</span>/<span style="font-style:italic">q</span>+<span style="font-style:italic">irem</span>(<span style="font-style:italic">u</span>(1),<span style="font-style:italic">p</span>)<br>
On pose <span style="font-style:italic">n</span><sub>0</sub>=<span style="font-style:italic">irem</span>(<span style="font-style:italic">u</span>(0),<span style="font-style:italic">p</span>)<br>
Donc :<br>
<span style="font-style:italic">q</span><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">u</span>(0)=<span style="font-style:italic">u</span>(1)*<span style="font-style:italic">p</span>*<span style="font-style:italic">q</span><sup><span style="font-style:italic">s</span>−2</sup>+<span style="font-style:italic">q</span><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">n</span><sub>0</sub><br>
et par itération :<br>
<span style="font-style:italic">pq</span><sup><span style="font-style:italic">s</span>−2</sup><span style="font-style:italic">u</span>(1)=<span style="font-style:italic">u</span>(2)<span style="font-style:italic">p</span><sup>2</sup><span style="font-style:italic">q</span><sup><span style="font-style:italic">s</span>−3</sup>+<span style="font-style:italic">pq</span><sup><span style="font-style:italic">s</span>−2</sup><span style="font-style:italic">n</span><sub>1</sub> avec <span style="font-style:italic">n</span><sub>1</sub>==<span style="font-style:italic">irem</span>(<span style="font-style:italic">u</span>(1),<span style="font-style:italic">p</span>)<br>
...<br>
<span style="font-style:italic">q</span><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">u</span>(0)=∑<sub><span style="font-style:italic">k</span>=0</sub><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup><span style="font-style:italic">q</span><sup><span style="font-style:italic">s</span>−<span style="font-style:italic">k</span>−1</sup><span style="font-style:italic">n</span><sub><span style="font-style:italic">k</span></sub><br>
ou encore :<br>
<span style="font-style:italic">n</span>=<span style="font-style:italic">u</span>(0)=∑<sub><span style="font-style:italic">k</span>=0</sub><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup><span style="font-style:italic">q</span><sup>−<span style="font-style:italic">k</span></sup><span style="font-style:italic">n</span><sub><span style="font-style:italic">k</span></sub><br>
Cette écriture est unique : on raisonne par récurrencesur <span style="font-style:italic">n</span>.<br>
Le développement est unique pour tous les <span style="font-style:italic">n</span>&lt;<span style="font-style:italic">p</span>.<br>
Si il y a unicité pour tous les entiers <span style="font-style:italic">m</span>&lt;<span style="font-style:italic">n</span> alors si on a 2 développements
de n :<br>
<span style="font-style:italic">n</span>==∑<sub><span style="font-style:italic">k</span>=0</sub><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup><span style="font-style:italic">q</span><sup>−<span style="font-style:italic">k</span></sup><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">n</span>==∑<sub><span style="font-style:italic">k</span>=0</sub><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup><span style="font-style:italic">q</span><sup>−<span style="font-style:italic">k</span></sup><span style="font-style:italic">b</span><sub><span style="font-style:italic">k</span></sub>
puisque <span style="font-style:italic">n</span>=<span style="font-style:italic">a</span><sub>0</sub>+<span style="font-style:italic">p</span>*∑<sub><span style="font-style:italic">k</span>=1</sub><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span>−1</sup><span style="font-style:italic">q</span><sup>−<span style="font-style:italic">k</span></sup><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">b</span><sub>0</sub>+<span style="font-style:italic">p</span>*∑<sub><span style="font-style:italic">k</span>=1</sub><sup><span style="font-style:italic">s</span>−1</sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span>−1</sup><span style="font-style:italic">q</span><sup>−<span style="font-style:italic">k</span></sup><span style="font-style:italic">b</span><sub><span style="font-style:italic">k</span></sub>= on en déduit que <span style="font-style:italic">a</span><sub>0</sub>=<span style="font-style:italic">b</span><sub>0</sub>=<span style="font-family:monospace">irem</span>(<span style="font-style:italic">n</span>,<span style="font-style:italic">p</span>) et on applique 
l’hypothèse de récurrence à <span style="font-family:monospace">iquo</span>(<span style="font-style:italic">n</span>,<span style="font-style:italic">p</span>)*<span style="font-style:italic">q</span> qui est strictement inférieur à <span style="font-style:italic">n</span>.<br>
On écrit le programme <span style="font-family:monospace">dev</span> qui renvoie la liste de dimension <span style="font-style:italic">s</span> :<br>
[<span style="font-style:italic">n</span><sub>0</sub>,<span style="font-style:italic">n</span><sub>1</sub>..<span style="font-style:italic">n</span><sub><span style="font-style:italic">s</span>−1</sub>] et le programme <span style="font-family:monospace">verif</span> qui effectue la vérification.
</p><pre class="verbatim">dev(n,p,q):={
local L,s,u;
si gcd(p,q)!=1 ou q&gt;p-1 alors return "erreur"; fsi;
L:=NULL;
si n&lt;p alors return n; fsi;
s:=n;
tantque s&gt;0 faire
u:=irem(s,p);
s:=iquo(s,p)*q;
L:=L,u;
}
return [L];
}
:;
verif(L,p,q):={
local n,s,k;
n:=L[0];
s:=size(L);
pour k de 1 jusque s-1 faire
n:=n+L[k]*(p/q)^k;
fpour;
return n;
}:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">L:=dev(33,3,2)</span>
On obtient :<br>
<span style="font-family:monospace">[0,1,2,2,1,2]</span><br>
On tape :<br>
<span style="font-family:monospace">verif(L,3,2)</span>
On obtient :<br>
<span style="font-family:monospace">33</span><br>
On tape :<br>
<span style="font-family:monospace">L:=dev(133,13,8)</span>
On obtient :<br>
<span style="font-family:monospace">[3,2,9,11,8]</span><br>
On tape :<br>
<span style="font-family:monospace">verif(L,13,8)</span>
On obtient :<br>
<span style="font-family:monospace">133</span>
</p>
<h2 id="sec244" class="section">8.15  Traduction Xcas de l’algorithme de Hörner</h2>
<p><a id="hevea_default86"></a><a id="hevea_default87"></a><a id="hevea_default88"></a><a id="sec:horner"></a>
Soit un polynôme <span style="font-style:italic">P</span> donné sous la forme d’une liste <span style="font-family:monospace">l</span> formée par 
les coefficients de <span style="font-style:italic">P</span> selon les puissances décroissantes.<br>
<span style="font-family:monospace">hornerl(l,a)</span> renvoie une liste formée par la valeur <span style="font-family:monospace">val</span> 
du polynôme en <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span> et par la liste <span style="font-family:monospace">lq</span> des coefficients selon les 
puissances décroissantes du quotient <span style="font-style:italic">Q</span>(<span style="font-style:italic">x</span>) de <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>) par (<span style="font-style:italic">x</span>−<span style="font-style:italic">a</span>).<br>
On a :<br>
<span style="font-family:monospace"><span style="font-style:italic">P</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">)=</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[0]*</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">p</span></span></sup><span style="font-family:monospace">+</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[1]*</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">-1</span></sup><span style="font-family:monospace">+...+</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">]=</span><br>
<span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">]+</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">*(</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">-1]+</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">*(</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">-2]+...+</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">*(</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[1]+</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">*</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[0])))</span><br>
<span style="font-family:monospace"><span style="font-style:italic">P</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">x</span></span><span style="font-family:monospace">)=</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[0]*</span><span style="font-family:monospace"><span style="font-style:italic">x</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">p</span></span></sup><span style="font-family:monospace">+</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[1]*</span><span style="font-family:monospace"><span style="font-style:italic">x</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">-1</span></sup><span style="font-family:monospace">+...+</span><span style="font-family:monospace"><span style="font-style:italic">l</span></span><span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">]=</span><br>
<span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">x</span></span><span style="font-family:monospace">-</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">)*(</span><span style="font-family:monospace"><span style="font-style:italic">lq</span></span><span style="font-family:monospace">[0]*</span><span style="font-family:monospace"><span style="font-style:italic">x</span></span><sup><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">-1</span></sup><span style="font-family:monospace">+...</span><span style="font-family:monospace"><span style="font-style:italic">lq</span></span><span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">-1])+</span><span style="font-family:monospace"><span style="font-style:italic">val</span></span> <br>
donc <span style="font-family:monospace"><span style="font-style:italic">val</span></span><span style="font-family:monospace">=</span><span style="font-family:monospace"><span style="font-style:italic">P</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">)</span>
et <span style="font-family:monospace">p=s-1</span> si <span style="font-family:monospace">s</span> est la longueur de la liste <span style="font-family:monospace">l</span> donc :<br>
<span style="font-family:monospace">lq[0]=l[0]<br>
lq[1]=a*lq[0]+l[1]<br>
lq[j]=a*lq[j-1]+l[j]<br>
....<br>
val=a*lq[p-1]+l[p]</span>
</p><pre class="verbatim">hornerl(l,a):={
local s,val,lq,j;
s:=size(l);
//on traite les polys constants (de degre=0) 
if (s==1) {return [l[0],[0]]};
// si s&gt;1
lq:=[];
val:=0;
for (j:=0;j&lt;s-1;j++) {
val:=val*a+l[j];
lq:=append(lq,val);
}
val:=val*a+l[s-1];
return([val,lq]);
};
</pre><p>
On tape :<br>
<span style="font-family:monospace">hornerl([1,2,4],12)</span><br>
On obtient :<br>
<span style="font-family:monospace">[172,[1,14]]</span><br>
ce qui veut dire que :<br>
<span style="font-style:italic">x</span><sup>2</sup>+2<span style="font-style:italic">x</span>+4=(<span style="font-style:italic">x</span>+14)(<span style="font-style:italic">x</span>−12)+172<br>
Si le polynôme est donné avec son écriture habituelle.<br>
Pour utiliser la fonction précédente on a alors besoin des deux 
fonctions :<br>
 <span style="font-family:monospace">symb2poly</span> qui transforme un polynôme en la liste de ses
coefficients selon les puissances décroissantes.<br>
<span style="font-family:monospace">poly2symb</span> qui transforme une liste en l’écriture habituelle du 
polynôme ayant cette pour coefficients selon les puissances décroissantes. 
</p><pre class="verbatim">hornerp(p,a,x):={
//ne marche pas pour les polys constants (de degre=0) 
local l,val,lh;
l:=symb2poly(p,x);
lh:=hornerl(l,a);
p:=poly2symb(lh[1],x);
val:=lh[0];
return([val,p]);
};
</pre><p>
On tape :<br>
<span style="font-family:monospace">hornerp(x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2+2x+4,12,x)</span><br>
On obtient :<br>
<span style="font-family:monospace">172,x+14</span><br>
On tape :<br>
<span style="font-family:monospace">hornerp(y</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2+2y+4,12,y)</span><br>
On obtient :<br>
<span style="font-family:monospace">172,y+14</span><br>
Dans <span style="font-family:monospace">Xcas</span>, il existe la fonction <span style="font-family:monospace">horner</span> qui calcule selon la 
méthode de Hörner la valeur d’un polynôme (donné sous forme de liste 
ou par son expression) en un point :<br>
On tape :<br>
<span style="font-family:monospace">horner(x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2+2x+4,12)</span><br>
On obtient :<br>
<span style="font-family:monospace">172</span><br>
On tape :<br>
<span style="font-family:monospace">horner(y</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2+2y+4,12,y)</span><br>
On obtient :<br>
<span style="font-family:monospace">172</span><br>
On tape :<br>
<span style="font-family:monospace">horner([1,2,4],12)</span><br>
On obtient :<br>
<span style="font-family:monospace">172</span>
</p>
<h3 id="sec245" class="subsection">8.15.1  Un autre exercice et sa solution</h3>
<p>
Trouver le plus petit entier positif <span style="font-style:italic">n</span>, tel que <span style="font-style:italic">n</span>, 2<span style="font-style:italic">n</span>, 3<span style="font-style:italic">n</span>, 4<span style="font-style:italic">n</span>, 5<span style="font-style:italic">n</span>,
6<span style="font-style:italic">n</span> contiennent exactement les mêmes chiffres.<br>
On tape la fonction booléenne qui teste si les entiers <span style="font-style:italic">n</span> et <span style="font-style:italic">m</span> ont des 
chiffres identiques.
On se sert de la fonction <span style="font-family:monospace">string</span> qui transforme un entier en une chaine de caractères, puis on 
transforme cette chaine en la liste de ses caractères ou en son code de Ascii, puis on 
trie cette liste.<br>
On tape :
</p><pre class="verbatim">chiffreid(n,m):={
local S1,S2,s1,s2,L1,L2,k;
  S1:=string(n);s1:=size(S1);
  S2:=string(m);s2:=size(S2);
  si s1!=s2 alors retourne faux; fsi;
  L1:=[sort(S1[k]$(k=0..s1-1))]; 
  L2:=[sort(S2[k]$(k=0..s1-1))];
  retourne L1==L2;
}:;
</pre><p>
ou
</p><pre class="verbatim">chiffreid(n,m):={
local S1,S2,s1,s2,L1,L2,k;
  S1:=string(n);s1:=size(S1);
  S2:=string(m);s2:=size(S2);
  si s1!=s2 alors retourne faux; fsi;
  L1:=sort(asc(S1)); 
  L2:=sort(asc(S2));
  retourne L1==L2;
}:;
</pre><p>On tape la fonction booléenne qui teste si les entiers <span style="font-style:italic">n</span>, 2<span style="font-style:italic">n</span>, 3<span style="font-style:italic">n</span>, 4<span style="font-style:italic">n</span>, 
5<span style="font-style:italic">n</span>, 6<span style="font-style:italic">n</span> ont des chiffres identiques. Si cela est le cas on 
sait que <span style="font-style:italic">n</span> est divisible par 3 puisque la somme des chiffres de <span style="font-style:italic">n</span> est égale la somme des chiffres 
de 3<span style="font-style:italic">n</span>.<br>
On tape :
</p><pre class="verbatim">chiffreid16(n):={
  local k;
  si irem(n,3)!=0 alors retourne faux; fsi;
  pour k de 6 jusque 2 pas -1 faire 
  si chiffreid(n,k*n)==faux alors retourne faux fsi;
  fpour;
  retourne vrai;
  }:;
</pre><p>
On tape la fonction qui renvoie le plus petit entier positif <span style="font-style:italic">n</span>, tel que <span style="font-style:italic">n</span>, 
2<span style="font-style:italic">n</span>, 3<span style="font-style:italic">n</span>, 4<span style="font-style:italic">n</span>, 5<span style="font-style:italic">n</span>, 6<span style="font-style:italic">n</span> contiennent exactement les mêmes chiffres.<br>
On tape : 
</p><pre class="verbatim">ppchiffreid():={
local n;
n:=3;
tantque chiffreid16(n)==faux faire 
  n:=n+3;
 ftantque;
retourne n; 
  }:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">ppchiffreid()</span><br>
On obtient :<br>
<span style="font-family:monospace">142857</span><br>
On vérifie :<br>
On tape :<br>
<span style="font-family:monospace">n:=142857;2*n;3*n;4*n;5*n;6*n</span><br>
On obtient ;<br>
<span style="font-family:monospace">142857,285714,428571,571428,714285,857142</span> 
On peut changer le programme ci-dessus pour savoir qui est le <span style="font-style:italic">n</span> suivant en 
initialisant <span style="font-style:italic">n</span> à 142860. On trouve alors 1428570.<br>
Puis on change à nouveau le programme ci-dessus pour savoir qui est le <span style="font-style:italic">n</span> suivant en 
initialisant <span style="font-style:italic">n</span> à 1428573. On trouve alors 1429857.<br>
Puis par curiosité, on cherche le suivant (mais c’est long !), on trouve 14285700.<br>
On a donc le début de cette suite :
<span style="font-family:monospace">142857, 1428570, 1429857, 14285700, 14298570</span></p>
<h2 id="sec246" class="section">8.16  Savoir si le polynôme <span style="font-style:italic">A</span> est divisible par <span style="font-style:italic">B</span></h2>
<h3 id="sec247" class="subsection">8.16.1  Programmation de la fonction booléenne <span style="font-family:monospace">estdivpoly</span></h3>
<p>
On va écrire la fonction récursive <span style="font-family:monospace">estdivpoly</span> qui a comme arguments, 
deux polynômes <span style="font-family:monospace">A</span> et <span style="font-family:monospace">B</span> écrits sous forme symbolique et qui 
renverra <span style="font-family:monospace">1</span> si <span style="font-family:monospace">A</span> est divisible par <span style="font-family:monospace">B</span> et <span style="font-family:monospace">0</span> sinon.<br>
On rappelle que <span style="font-family:monospace">degree(A)</span> renvoie le degré de <span style="font-family:monospace">A</span> et que
<span style="font-family:monospace">valuation(A)</span> renvoie la valuation de <span style="font-family:monospace">A</span>
(la plus petite puissance de <span style="font-family:monospace">A</span>). </p><p>Pour Savoir si <span style="font-family:monospace">A</span> est divisible par <span style="font-family:monospace">B</span>, on s’interesse aux termes de 
plus haut degré et de plus bas degré de <span style="font-family:monospace">A</span> et <span style="font-family:monospace">B</span> : c’est à dire
qu’a chaque étape on essaye de faire la division par les 2 bouts ....<br>
Par exemple si :<br>
<span style="font-family:monospace">A=x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+2*x-3</span> et <span style="font-family:monospace">B=x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2+x</span> on sait que <span style="font-family:monospace">A</span> n’est pas 
divisible par <span style="font-family:monospace">B</span> car <span style="font-family:monospace">-3</span> n’est pas divisible par <span style="font-family:monospace">x</span>,<br>
ou encore si :<br>
<span style="font-family:monospace">A=x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+2*x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2</span> et <span style="font-family:monospace">B=x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2+1</span> on sait que <span style="font-family:monospace">A</span> 
n’est pas divisible par <span style="font-family:monospace">B</span> car le quotient aurait pour degré
<span style="font-family:monospace">3-2=1</span> et pour valuation <span style="font-family:monospace">2-0=2</span>, ce qui est impossible <span style="font-family:monospace">1&lt;2</span> (le 
degré n’peut pas être inférieur à la valuation. <br>
</p><pre class="verbatim">estdivpoly(A,B):={
  local da,db,va,vb,dq,vq,dva,dvb,dvq,Q,Ca,Cb;
  da:=degree(A);
  va:=valuation(A);
  dva:=da-va;
  db:=degree(B);
  vb:=valuation(B);
  dvb:=db-vb;
  if (A==0) then return 1;end_if;
  if ((da&lt;db) or (va&lt;vb)) then return 0;end_if;
  if ((dva==0) and (dvb&gt;0)) then return 0;end_if;
  if ((dva&gt;=0) and (dvb==0)) then return 1;end_if;
  Cb:=coeffs(B);
  if ((dva&gt;0) and (dvb&gt;0)) then 
  dq:=da-db;
  vq:=va-vb;
  dvq:=dq-vq;
  if (dvq&lt;0) then return 0;end_if;
  Ca:=coeffs(A); 
  Q:=Ca[0]/Cb[0]*x^(dq);
  if (dvq==0) then 
  A:=normal(A-B*Q);
  else
  Q:=Q+Ca[dva]/Cb[dvb]*x^(vq);  
  A:=normal(A-B*Q);
  end_if;
  da:=degree(A);
  va:=valuation(A);
   end_if;
  return estdivpoly(A,B);
};
</pre><p>
On tape :
<span style="font-family:monospace">A:=normal((x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">4-x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-1)*(x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">5-x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-1)</span><br>
puis,<br>
<span style="font-family:monospace">estdivpoly(A,x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">4-x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-1)</span><br>
On obtient :<br>
<span style="font-family:monospace">1</span>
</p>
<h3 id="sec248" class="subsection">8.16.2  Autre version du programme précedent : <span style="font-family:monospace">quoexpoly</span></h3>
<p>
Lorsque <span style="font-family:monospace">A</span> est divisible par <span style="font-family:monospace">B</span> on peut en modifiant le programme
précédent avoir facilement le quotient exact de <span style="font-family:monospace">A</span> par <span style="font-family:monospace">B</span>.<br>
On écrit la fonction récursive <span style="font-family:monospace">quoexpoly</span> qui a trois arguments, 
deux polynômes <span style="font-family:monospace">A</span> et <span style="font-family:monospace">B</span> écrits sous forme symbolique et <span style="font-family:monospace">0</span>.
<span style="font-family:monospace">quoexpoly</span> renverra <span style="font-family:monospace">1,Q</span> si <span style="font-family:monospace">A=B*Q</span> et <span style="font-family:monospace">0</span> sinon.<br>
Puis on écrit la fonction <span style="font-family:monospace">quopoly(A,B)</span> qui est égale à 
<span style="font-family:monospace">quoexpoly(A,B,0)</span>.
</p><pre class="verbatim">quoexpoly(A,B,SQ):={
  local da,db,va,vb,dq,vq,dva,dvb,dvq,Q,Ca,Cb;
  da:=degree(A);
  va:=valuation(A);
  dva:=da-va;
  db:=degree(B);
  vb:=valuation(B);
  dvb:=db-vb;
  if (A==0) then return 1,SQ;end_if;
  if ((da&lt;db) or (va&lt;vb)) then return 0;end_if;
  if ((dva==0) and (dvb&gt;0)) then return 0;end_if;
  if ((dva&gt;=0) and (dvb==0)) then return 1,normal(SQ+normal(A/B));end_if;
  Cb:=coeffs(B);
  if ((dva&gt;0) and (dvb&gt;0)) then 
  dq:=da-db;
  vq:=va-vb;
  dvq:=dq-vq;
  if (dvq&lt;0) then return 0;end_if;
  Ca:=coeffs(A); 
  Q:=Ca[0]/Cb[0]*x^(dq);
  if (dvq==0) then 
  A:=normal(A-B*Q);
  SQ:=normal(SQ+Q);
  else
  Q:=Q+Ca[dva]/Cb[dvb]*x^(vq);  
  A:=normal(A-B*Q);
   SQ:=normal(SQ+Q);
  end_if;
  da:=degree(A);
  va:=valuation(A);
   end_if;
  return quoexpoly(A,B,SQ);
};
estquopoly(A,B):=quoexpoly(A,B,0);
</pre><p>
On tape :
<span style="font-family:monospace">A:=normal((x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">4-x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-1)*(x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">5-x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-1)</span><br>
puis,<br>
<span style="font-family:monospace">estquopoly(A,x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">4-x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-1)</span><br>
On obtient :<br>
<span style="font-family:monospace">1,x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">5-x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3+x</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-1</span></p>
<h2 id="sec249" class="section">8.17  Affichage d’un nombre en une chaîne comprenant des espaces</h2>
<h3 id="sec250" class="subsection">8.17.1  Affichage d’un nombre entier par tranches de <span style="font-style:italic">p</span> chiffres</h3>
<p>
Pour rendre plus facile la lecture d’un grand nombre entier, on veut l’afficher
par tranches, c’est à dire selon une chaîne de caractères constituées
par les <span style="font-style:italic">p</span> premiers chiffres du nombre et d’un espace, puis les <span style="font-style:italic">p</span> suivants 
etc...
On écrit le programme qui va afficher le nombre <span style="font-style:italic">n</span> par tranches de <span style="font-style:italic">p</span> 
chiffres: 
</p><pre class="verbatim">affichen(n,p):={
local reste,result,s;
result:="";
while (n&gt;10^p) {
//on transforme irem(n,10^p) en une chaine
reste:=cat(irem(n,10^p),"");
s:=size(reste);
//on ajoute l'espace et les zeros qui manquent
reste:=cat(" ",op(newList(p-s)),reste);
n:=iquo(n,10^p);
//on concatene reste avec result 
result:=cat(reste,result);
}
reste:=cat(n);
return cat(reste,result);
};
</pre><p>
On tape :<br>
<span style="font-family:monospace">affichen(1234567,3)</span>
On obtient :<br>
<span style="font-family:monospace">"1 234 567"</span>
</p>
<h3 id="sec251" class="subsection">8.17.2  Transformation d’un affichage par tranches en un nombre entier</h3>
<p>
Pour avoir la transformation inverse, on va transformer une chaîne
comportant des chiffres et un autre caractère (par exemple un espace) en un 
nombre entier.<br>
On écrit le programme :
</p><pre class="verbatim">enleve(chn,ch):={
local l,s;
s:=length(chn)-1;
//on transforme chn en une liste de ces lettres
//puis, on enleve le caractere ch de cette liste
l:=remove(x-&gt;(ord(x)==ord(ch)),seq(chn[k],k,0,s));
//on transforme la liste en chaine
return expr(char(ord(l)));
};
</pre><p>
On peut aussi remplacer la dernière ligne :<br>
<span style="font-family:monospace">return char(ord(l))</span><br>
(<span style="font-family:monospace">ord(l)</span> transforme la liste de caractères en la liste de leurs codes 
ascii et <span style="font-family:monospace">char</span> transforme la liste des codes ascii en une chaîne).<br>
par :<br>
<span style="font-family:monospace">return cat(op(l))</span><br>
car <span style="font-family:monospace">op(l)</span> transforme la liste en une séquence et <span style="font-family:monospace">cat</span>
concatène les éléments de cette séquence en une chaîne.
On tape :<br>
<span style="font-family:monospace">enleve("1 234 567"," ")</span>
On obtient :<br>
<span style="font-family:monospace">1234567</span>
</p>
<h3 id="sec252" class="subsection">8.17.3  Affichage d’un nombre décimal de [0,1[ par tranches de <span style="font-style:italic">p</span> chiffres</h3>
<p>
Pour rendre plus facile la lecture d’un nombre décimal de [0,1[, on veut 
l’afficher par tranches, c’est à dire selon une chaîne de caractères 
constituées par les <span style="font-style:italic">p</span> premières décimales du nombre et d’un espace, 
puis les <span style="font-style:italic">p</span> suivants etc...
On suppose que l’écriture de <span style="font-style:italic">d</span> comporte un point (.) suivi des 
décimales et ne comporte pas d’exposant (pas de <span style="font-style:italic">e</span>4)</p><p>On écrit le programme qui va afficher le nombre <span style="font-style:italic">d</span> par tranches de <span style="font-style:italic">p</span> 
chiffres: 
</p><pre class="verbatim">affiched(d,p):={
local deb,result;
//on suppose 0&lt;=d&lt;1
d:=cat(d,"");
if (d[0]=="0") {d:=tail(d);}
if (expr(tail(d))&lt;10^p){return d;}
deb:=mid(d,0,p+1);
result:=cat(deb," ");
d:=mid(d,p+1);
while (expr(d)&gt;10^p) {
deb:=mid(d,0,p);
result:=cat(result,deb," ");
d:=mid(d,p);
}
return cat(result,d);
};
</pre><p>
On tape :<br>
<span style="font-family:monospace">affiched(0.1234567,3)</span><br>
On obtient :<br>
<span style="font-family:monospace">".123 456 7"</span><br>
<span style="font-weight:bold">Remarque</span><br>
La commande <span style="font-family:monospace">enleve(affiched(d,3)," ")</span> permet encore de retrouver <span style="font-family:monospace">d</span>.
</p><pre class="verbatim">enleve(chn,ch):={
local l,s;
s:=length(chn)-1;
//on transforme chn en une liste de ces lettres
//puis, on enleve le caractere ch de cette liste
l:=remove(x-&gt;(ord(x)==ord(ch)),seq(chn[k],k,0,s));
//on transforme la liste en chaine
return expr(char(ord(l)));
};
</pre>
<h3 id="sec253" class="subsection">8.17.4  Affichage d’un nombre décimal par tranches de <span style="font-style:italic">p</span> chiffres</h3>
<p>
Pour rendre plus facile la lecture d’un nombre décimal, on veut 
l’afficher par tranches, c’est à dire selon une chaîne de caractères 
constituées par sa partie entière écrite par tranches de <span style="font-style:italic">p</span> chiffres,
puis ses <span style="font-style:italic">p</span> premières décimales du nombre et d’un espace, puis les <span style="font-style:italic">p</span> 
suivants etc...<br>
Ici, le nombre <span style="font-style:italic">f</span> peut comporter un exposant à la fin de son écriture.<br>
On écrit le programme qui va afficher le nombre décimal <span style="font-style:italic">f</span> par tranches 
de <span style="font-style:italic">p</span> chiffres : 
</p><pre class="verbatim">//pour les flottants f utiliser affichef
// appelle affichen et affiched 
//par exemple affichef(1234.12345,3)
affichef(f,p):={
local deb,result,s,indicep,fn,fd,indicee;
//on suppose f&gt;1
f:=cat(f);
s:=size(f)-1;
indicep:=member(".",seq(f[k],k,0,s));
indicee:=member("e",seq(f[k],k,0,s));
if (indicep!=0) {
fn:=mid(f,0,indicep-1);
fd:=mid(f,indicep-1);
if (indicee!=0) {
return affichen(expr(fn),p)+affiched(expr(mid(fd,0,
indicee-1)),p)+mid(fd,indicee-1);}
return affichen(expr(fn),p)+affiched(expr(fd),p)
}
return affichen(expr(f),p);
};
</pre><p>
On tape :<br>
<span style="font-family:monospace">affichef(1234567.1234567,3)</span> <br>
On obtient (pour 12 chiffres significatifs) :<br>
<span style="font-family:monospace">"1 234 567.123 46"</span><br>
On obtient (pour 14 chiffres significatifs) :<br>
<span style="font-family:monospace">"1 234 567.123 456 7"</span><br>
On obtient (pour 15 chiffres significatifs) :<br>
<span style="font-family:monospace">"0.123 456 712 345 670 0*e7"</span><br>
<span style="font-weight:bold">Remarque</span><br>
La commande <span style="font-family:monospace">enleve(affichef(q,3)," ")</span> permet encore de retrouver <span style="font-family:monospace">q</span>.
</p><pre class="verbatim">enleve(chn,ch):={
local l,s;
s:=length(chn)-1;
//on transforme chn en une liste de ces lettres
//puis, on enleve le caractere ch de cette liste
l:=remove(x-&gt;(ord(x)==ord(ch)),seq(chn[k],k,0,s));
//on transforme la liste en chaine
return expr(char(ord(l)));
};
</pre>
<h2 id="sec254" class="section">8.18  Écriture décimale d’un nombre rationnel</h2>
<h3 id="sec255" class="subsection">8.18.1  Algorithme de la potence</h3>
<p>
Pour obtenir la partie entière et le développement décimal de 
 <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>, on va construire deux listes :
<span style="font-family:monospace">L1</span> la liste des restes et <span style="font-family:monospace">L2</span> 
la liste des quotients obtenus par l’algorithme de la potence .<br>
On met le quotient <span style="font-style:italic">q</span> dans <span style="font-family:monospace">L1</span> et le reste <span style="font-style:italic">r</span> dans <span style="font-family:monospace">L2</span>.<br>
On a ainsi, la partie entière de  <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> dans <span style="font-family:monospace">L1</span>
et comme  <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=<span style="font-style:italic">q</span>+<span style="font-style:italic">r</span>/<span style="font-style:italic">b</span> on cherche la partie entière de  10*<span style="font-style:italic">r</span>/<span style="font-style:italic">b</span> qui va rallonger <span style="font-family:monospace">L1</span> etc...</p><p>Si on veut, par exemple, le développement décimale de 
 278/31 on cherche :<br>
le quotient <span style="font-style:italic">q</span>=8 et le reste <span style="font-style:italic">r</span>=30 de la divison euclidienne de 278 par 31.<br>
La partie entière est donc 8 et, on met 8<span style="font-family:monospace">L1</span> .
Pour avoir la partie décimale de  278/31, on fait 
comme à la main l’algorithme de
la potence : on multiplie le reste trouvé par 10, on trouve 300 
puis on le divise par 31 : le quotient trouvé 9 est 
rajouté à <span style="font-family:monospace">L1</span> et le reste est rajouté à <span style="font-family:monospace">L2</span> etc...<br>
On écrit la fonction potence qui renvoie dans la première liste 
la partie entière puis les <span style="font-style:italic">n</span> décimales de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> et dans la 
deuxième liste les restes successifs obtenus.
</p><pre class="verbatim">potence(a,b,n):={
 local L1,L2,k;
 b0:=b;
 b:=iquo(a,b0);
 a:=irem(a,b0);
 L1:=[b];
 L2:=[a];
 for (k:=1;k&lt;=n and a!=0;k++){
    b:=iquo(a*10,b0);
    a:=irem(a*10,b0);
    L2:=append(L2,a);
    L1:=append(L1,b);
 };
 return([L1,L2]);
};
</pre><p>
En exécutant <span style="font-family:monospace">potence(278,31,20)</span>, on lit la partie entière de 
 278/31 et les chiffres de sa partie décimale dans la 
première liste et, la suite des restes dans la deuxième liste.<br>
<span style="font-weight:bold">Exercice</span><br>
Écrire la partie entière et le développement décimal de :<br>
 <span style="font-style:italic">a</span>=11/7, <span style="font-style:italic">b</span>=15/14 et 
<span style="font-style:italic">c</span>=17/28.<br>
Calculer <span style="font-style:italic">a</span>−<span style="font-style:italic">b</span> et <span style="font-style:italic">a</span>−<span style="font-style:italic">c</span> 
et donner leur partie entière et leur
développement décimal.<br>
Que remarqez-vous ?<br>
<span style="font-weight:bold">Exercice</span>
Comment modifier <span style="font-family:monospace">L1</span> et <span style="font-family:monospace">L2</span> pour que les chiffres de la 
partie décimale de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> se lisent par paquet de trois 
chiffres dans <span style="font-family:monospace">L1</span>.<br>
 Avec l’exemple 278/31 on veut obtenir :
<span style="font-family:monospace">L1=[8,967,741,935 ...]</span><br>
Tester votre modification pour 349/1332.<br>
Que remarquez vous ? 
</p>
<h3 id="sec256" class="subsection">8.18.2  Avec un programme</h3>
<p>
<span style="font-family:monospace">division(a,b,n,t)</span> donne la partie entière suivie de <span style="font-style:italic">n</span> paquets de
<span style="font-style:italic">t</span> décimales (i.e. des <span style="font-style:italic">n</span>*<span style="font-style:italic">t</span> premières 
décimales) de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>.
</p><pre class="verbatim"> 
division(a,b,n,t):={
local L1,L2,p,q,r,k;
L1:=[iquo(a,b)];
r:=irem(a,b);
for (k:=1;k&lt;=n and r!=0;k++) {
q:=iquo(r*10^t,b);
//10^(p-1)&lt;= q &lt;10^p
if (q==0) {p:=1} else {p:=floor(ln(q)/ln(10)+1)};
//on complete par des zeros pour avoir un paquet de t decimales
for (j:=p+1;j&lt;=t;j++){
L1:=append(L1,0);
}
L1:=append(L1,q);
r:=irem(r*10^t,b);
}
return(L1,r);
};
</pre><p>
On tape pour avoir 5*6=30 decimales :<br>
<span style="font-family:monospace">division(2669,201,6,5)</span><br>
On obtient :<br>
<span style="font-family:monospace">[13,27860,69651,74129,35323,38308,45771],29</span> 
</p>
<h3 id="sec257" class="subsection">8.18.3  Construction d’un rationnel</h3>
<p>
Trouver un nombre rationnel qui s’écrit :<br>
0.123123123123... se terminant par une suite illimitée de 123.<br>
Trouver un nombre rationnel qui s’écrit :<br>
0.120123123123... se terminant par une suite illimitée de 123.<br>
Écrire un programme qui permet de trouver un nombre rationnel à partir 
d’un développement décimal périodique.<br>
Réponse :<br>
On écrit la fonction <span style="font-family:monospace">rationnel</span> qui a comme le paramètre deux listes 
<span style="font-family:monospace">l1</span> et <span style="font-family:monospace">l2</span> :<br>
- <span style="font-family:monospace">l1</span> désigne la partie non périodique de ce développement et 
<span style="font-family:monospace">l1[0]</span> désigne la partie entière.<br>
- <span style="font-family:monospace">l2</span> représente un développement décimal périodique.</p><pre class="verbatim"> 
rationnel(l1,l2):={
//l1 et l2 sont non vides
local pui,s1,s2,n,p,np,pui,k;
pui:=10;
s2:=size(l2);
n:=l2[0];
for (k:=1;k&lt;s2;k++){
pui:=pui*10;
n:=n*10+l2[k];
}
// 0.123123...=123/999 
p:=n/(pui-1);
//np partie non periodique
np:=l1[0];
s1:=size(l1);
pui:=1;
for (k:=1;k&lt;s1;k++){
pui:=pui*10;
np:=np+l1[k]/pui;
}
//pui=10^(s1-1) 
return(np+p/pui);
};
</pre>
<h2 id="sec258" class="section">8.19  Développement en fraction continue</h2>
<h3 id="sec259" class="subsection">8.19.1  Développement en fraction continue d’un rationnel</h3>
<h4 id="sec260" class="subsubsection">Les définitions</h4>
<p>
<span style="font-weight:bold">Théorème1</span> Si <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont des entiers naturels premiers entre
eux, alors il existe des entiers naturels 
<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> (0 ≤ <span style="font-style:italic">n</span>) tels que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">a</span><sub>0</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>1</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>2</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−2</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Si <span style="font-style:italic">b</span>≤ <span style="font-style:italic">a</span> les <span style="font-style:italic">aj</span> sont non nuls et, si <span style="font-style:italic">a</span>&lt;<span style="font-style:italic">b</span> alors <span style="font-style:italic">a</span><sub>0</sub>=0 et les autres 
<span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> sont non nuls.<br>
<span style="font-weight:bold">Définition</span>
On pose alors <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=(<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>) et on dit que 
(<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>) 
est une fraction continue : c’est le développement en fraction continue de
 <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>.<br>
<span style="font-weight:bold">Remarque</span> si <span style="font-style:italic">b</span>≤ <span style="font-style:italic">a</span> et si <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=(<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>) 
alors <span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>=(0,<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>).<br>
<span style="font-weight:bold">Réduite et reste</span>
On dit que la fraction <span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>/<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span></sub> égale à la
fraction continue (<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>), où <span style="font-style:italic">p</span>≤ <span style="font-style:italic">n</span>, est la réduite de 
rang <span style="font-style:italic">p</span> de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> ou que c’est le développement en 
fraction continue d’ordre <span style="font-style:italic">p</span> de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>.<br>
 On dit que 
<span style="font-style:italic">r</span>=(0,<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>) est le reste du développement d’ordre <span style="font-style:italic">p</span> (<span style="font-style:italic">r</span>&lt;1)
et on a <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=(<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">r</span>)=(<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>,1/<span style="font-style:italic">r</span>),<br>
<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=<span style="font-style:italic">a</span><sub>0</sub>+1/<span style="font-style:italic">a</span><sub>1</sub>+1/<span style="font-style:italic">a</span><sub>2</sub>+1/...<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−3</sub>+1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−2</sub>+1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">r</span>.<br>
</p>
<h4 id="sec261" class="subsubsection">Propriétés des réduites</h4>
<p>
Si <span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>/<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span></sub> égale à la
fraction continue (<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>), où <span style="font-style:italic">p</span>≤ <span style="font-style:italic">n</span>, est la réduite de 
rang <span style="font-style:italic">p</span> de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=(<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>), on a :<br>
<span style="font-style:italic">P</span><sub>0</sub>=<span style="font-style:italic">a</span><sub>0</sub><br>
<span style="font-style:italic">Q</span><sub>0</sub>=1<br>
<span style="font-style:italic">P</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>0</sub>*<span style="font-style:italic">a</span><sub>1</sub>+1<br>
<span style="font-style:italic">Q</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>1</sub><br>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−2</sub><br>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−2</sub><br>
En effet on le montre par récurrence :<br>
<span style="font-style:italic">P</span><sub>2</sub>/<span style="font-style:italic">Q</span><sub>2</sub>=<span style="font-style:italic">a</span><sub>0</sub>+<span style="font-style:italic">a</span><sub>2</sub>/(<span style="font-style:italic">a</span><sub>1</sub><span style="font-style:italic">a</span><sub>2</sub>+1) donc<br>
<span style="font-style:italic">P</span><sub>2</sub>=<span style="font-style:italic">a</span><sub>2</sub>(<span style="font-style:italic">a</span><sub>0</sub>+<span style="font-style:italic">a</span><sub>1</sub>+1)+<span style="font-style:italic">a</span><sub>0</sub>=<span style="font-style:italic">a</span><sub>2</sub><span style="font-style:italic">P</span><sub>1</sub>+<span style="font-style:italic">P</span><sub>0</sub> et <br>
<span style="font-style:italic">Q</span><sub>2</sub>=<span style="font-style:italic">a</span><sub>2</sub><span style="font-style:italic">a</span><sub>1</sub>+1=<span style="font-style:italic">a</span><sub>2</sub><span style="font-style:italic">Q</span><sub>1</sub>+<span style="font-style:italic">Q</span><sub>0</sub><br>
(<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub>)=<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>+1</sub>/<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>+1</sub> donc<br>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>+1</sub>/<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>+1</sub>=((<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−2</sub>)/((<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub>)<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−2</sub>)<br>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>+1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub>(<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−2</sub>)+<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−1</sub> et <br>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>+1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub>(<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−2</sub>)+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>+1</sub><span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−1</sub>
</p>
<h4 id="sec262" class="subsubsection">Les programmes</h4>
<p>
<span style="font-weight:bold">Le programme f2dfc :</span> <br>
On veut transformer une fraction en son développement en fraction continue :<br>
<span style="font-family:monospace"><span style="font-style:italic">f</span></span><span style="font-family:monospace">2</span><span style="font-family:monospace"><span style="font-style:italic">dfc</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">b</span></span><span style="font-family:monospace">)=(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">, </span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">,...</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub><span style="font-family:monospace">)</span>.<br>
Pour obtenir le développement en fraction continue de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>, on cherche le 
quotient <span style="font-style:italic">q</span> et le reste <span style="font-style:italic">r</span> de la division euclidienne de <span style="font-style:italic">a</span> par <span style="font-style:italic">b</span>.
On a : <span style="font-style:italic">q</span>=<span style="font-style:italic">a</span><sub>0</sub> et <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=<span style="font-style:italic">a</span><sub>0</sub>+<span style="font-style:italic">r</span>/<span style="font-style:italic">b</span>=<span style="font-style:italic">a</span><sub>0</sub>+1/(<span style="font-style:italic">b</span>/<span style="font-style:italic">r</span>) et, on continue en cherchant
la partie entiére de <span style="font-style:italic">b</span>/<span style="font-style:italic">r</span> qui sera <span style="font-style:italic">a</span><sub>1</sub>....On reconnait
l’algorithme d’Euclide : la suite (<span style="font-style:italic">a</span><sub>0</sub>, <span style="font-style:italic">a</span><sub>1</sub>,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>) est donc la suite 
des quotients de l ’algorithme d’Euclide.<br>
On écrit le programme : 
</p><pre class="verbatim">f2dfc(fract):={
local r,q,l,lres,a,b;
l:=f2nd(fract);
a:=l[0];
b:=l[1];
lres:=[];
while (b&gt;0) {
q:=iquo(a,b)
lres:=concat(lres,q);
r:=irem(a,b); 
a:=b;
b:=r:
}
return lres;
}
</pre><p>
On tape :<br>
<span style="font-family:monospace">f2dfc(2599/357)</span><br>
On obtient :<br>
<span style="font-family:monospace">[7,3,1,1,3,14]</span><br>
<span style="font-weight:bold">Le programme f2reduites d’un rationnel et l’identité de Bézout :</span> 
On veut obtenir la suite des réduites de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>.<br>
L’algorithme pour obtenir les réduites ressemble beaucoup à l’algorithme 
utilisé pour obtenir les coefficients <span style="font-style:italic">u</span> et <span style="font-style:italic">v</span> de l’identité de 
Bézout (cf <a href="#sec%3Abezout">8.3.5</a>).<br>
En effet on a :<br>
<span style="font-style:italic">P</span><sub>0</sub>=<span style="font-style:italic">a</span><sub>0</sub>=<span style="font-style:italic">a</span><sub>0</sub>*1+0 alors que <span style="font-style:italic">v</span><sub>0</sub>=0 <br>
<span style="font-style:italic">Q</span><sub>0</sub>=1=<span style="font-style:italic">a</span><sub>0</sub>*0+1 alors que <span style="font-style:italic">u</span><sub>0</sub>=1<br>
<span style="font-style:italic">P</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>0</sub><span style="font-style:italic">a</span><sub>1</sub>+1=<span style="font-style:italic">P</span><sub>0</sub>*<span style="font-style:italic">a</span><sub>1</sub>+1 alors que <span style="font-style:italic">v</span><sub>1</sub>=1<br>
<span style="font-style:italic">Q</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>1</sub>*<span style="font-style:italic">Q</span><sub>0</sub>+0 alors que <span style="font-style:italic">u</span><sub>1</sub>=0<br>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−2</sub> alors que <span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span>−2</sub>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−2</sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span>−1</sub><br>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−2</sub> alors que <span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span>−2</sub>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−2</sub><span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span>−1</sub><br>
Ainsi :<br>
<span style="font-style:italic">P</span><sub>0</sub>=0+<span style="font-style:italic">a</span><sub>0</sub>*1=<span style="font-style:italic">v</span><sub>0</sub>−<span style="font-style:italic">a</span><sub>0</sub>*<span style="font-style:italic">v</span><sub>1</sub>=−<span style="font-style:italic">v</span><sub>2</sub> <br>
<span style="font-style:italic">P</span><sub>1</sub>=1+<span style="font-style:italic">P</span><sub>0</sub>*<span style="font-style:italic">a</span><sub>1</sub>=<span style="font-style:italic">v</span><sub>1</sub>−<span style="font-style:italic">v</span><sub>2</sub>*<span style="font-style:italic">a</span><sub>1</sub>=<span style="font-style:italic">v</span><sub>3</sub><br>
<span style="font-style:italic">P</span><sub>2</sub>=<span style="font-style:italic">P</span><sub>0</sub>+<span style="font-style:italic">P</span><sub>1</sub>*<span style="font-style:italic">a</span><sub>2</sub>=−<span style="font-style:italic">v</span><sub>2</sub>+<span style="font-style:italic">v</span><sub>3</sub>*<span style="font-style:italic">a</span><sub>2</sub>=−(<span style="font-style:italic">v</span><sub>2</sub>−<span style="font-style:italic">v</span><sub>3</sub>*<span style="font-style:italic">a</span><sub>2</sub>)=−<span style="font-style:italic">v</span><sub>4</sub><br>
On a donc pour tout <span style="font-style:italic">p</span> ≥ 0, si <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub> est la suite des quotients de 
l’algorithme d’Euclide :<br>
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">p</span>−2</sub> avec <span style="font-style:italic">Q</span><sub>−2</sub>=1=<span style="font-style:italic">u</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>−1</sub>=0=<span style="font-style:italic">u</span><sub>1</sub> et,<br>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span>−2</sub> avec <span style="font-style:italic">P</span><sub>−2</sub>=0=<span style="font-style:italic">v</span><sub>0</sub> et <span style="font-style:italic">P</span><sub>−1</sub>=1=<span style="font-style:italic">v</span><sub>1</sub><br>
Dans l’algorithme de Bézout on a :<br>
<span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span></sub>=−<span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−2</sub>+<span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span>−2</sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span></sub>=−<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span>−1</sub>*<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−2</sub>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">p</span>−2</sub> 
<span style="font-style:italic">Q</span><sub>0</sub>=0+<span style="font-style:italic">u</span><sub>2</sub> donc <span style="font-style:italic">Q</span><sub>1</sub>=−<span style="font-style:italic">u</span><sub>3</sub>, <span style="font-style:italic">Q</span><sub>2</sub>=<span style="font-style:italic">u</span><sub>4</sub> etc...donc <span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub>=(−1)<sup><span style="font-style:italic">n</span></sup><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+2</sub> et,<br>
<span style="font-style:italic">P</span><sub>0</sub>=−<span style="font-style:italic">v</span><sub>2</sub>+0 donc <span style="font-style:italic">P</span><sub>1</sub>=<span style="font-style:italic">v</span><sub>3</sub>, <span style="font-style:italic">P</span><sub>2</sub>=−<span style="font-style:italic">v</span><sub>4</sub> etc...donc <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>=(−1)<sup><span style="font-style:italic">n</span>+1</sup><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+2</sub>.<br>
Donc <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub>=−<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+2</sub>/<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+2</sub><br>
Donc la suite <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub>/<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> est donc la suite des −<span style="font-style:italic">u</span>/<span style="font-style:italic">v</span>.<br>
On écrit le programme (calqué sur le programme <span style="font-family:monospace">Bezout</span> avec les 
listes) qui transforme une fraction en son développement en fraction continue
suivi de la suite de ces réduites : 
</p><pre class="verbatim">f2reduites(fract):={
local lr,q,l,lres,la,lb,lq;
l:=f2nd(fract);
//a:=l[0];b:=l[1];
la:=[1,0,l[0]];
lb:=[0,1,l[1]];
lq:=[];
lres:=[];
while (lb[2]&gt;0) {
q:=iquo(la[2],lb[2])
lr:=la-q*lb;
lq:=concat(lq,q);
lres:=concat(lres,-lr[1]/lr[0]);
la:=lb;
lb:=lr;
}
return lq,lres;
}
</pre><p>
On tape :<br>
<span style="font-family:monospace">f2reduites(2599/357)</span><br>
On obtient :<br>
<span style="font-family:monospace">[7,3,1,1,3,14],[7,22/3,29/4,51/7,182/25,2599/357]</span><br>
<span style="font-weight:bold">Remarque</span> :<br>
On ne peut pas remplacer :<br>
<span style="font-family:monospace">lr:=la-q*lb;</span><br>
<span style="font-family:monospace">lres:=concat(lres,-lr[1]/lr[0])</span><br>
par :<br>
<span style="font-family:monospace">lr:=la+q*lb;</span><br>
<span style="font-family:monospace">lres:=concat(lres,lr[1]/lr[0]);</span><br>
car alors <span style="font-family:monospace">lr</span> n’est plus la suite des restes !<br>
<span style="font-weight:bold">Le programme dfc2reduites d’un rationnel et l’identité de Bézout:</span> 
On veut obtenir la suite des réduites d’une liste <span style="font-style:italic">l</span> (qui sera par exemple 
le développement en fraction continue d’un rationnel <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>) 
On écrit le programme (calqué sur le programme <span style="font-family:monospace">Bezout</span> sans les 
listes) qui transforme une liste [<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,..<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>] en la 
liste [<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>0</sub>+1/<span style="font-style:italic">a</span><sub>1</sub>,....,(<span style="font-style:italic">a</span><sub>0</sub>+1/<span style="font-style:italic">a</span><sub>1</sub>+1/...+1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>+1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>)] : 
</p><pre class="verbatim">dfc2reduites(l):={
local s,p0,q0,p1,q1,p,q,lres,j;
s:=size(l);
lres:=[];
p0:=0;
p1:=1;
q0:=1;
q1:=0;
for (j:=0;j&lt;s;j++){
  p:=p0+l[j]*p1;
  q:=q0+l[j]*q1;
  lres:=concat(lres,p/q);
  p0:=p1;
  q0:=q1;
  p1:=p;
  q1:=q;
}
return lres;
}
</pre><p>
On remarquera que :<br>
 -la suite des <span style="font-style:italic">P</span> est initialisée par
<span style="font-style:italic">p</span>0 et <span style="font-style:italic">p</span>1, puis, quand <span style="font-style:italic">j</span>=0, on fait le calcul de <span style="font-style:italic">P</span><sub>0</sub> qui est mis dans 
<span style="font-style:italic">p</span>, puis, quand <span style="font-style:italic">j</span>=1 on fait 
le calcul de <span style="font-style:italic">P</span><sub>1</sub> qui est mis dans <span style="font-style:italic">p</span>, etc... et que<br>
- la suite des <span style="font-style:italic">Q</span> est initialisée par :
<span style="font-style:italic">q</span>0 et <span style="font-style:italic">q</span>1, puis, quand <span style="font-style:italic">j</span>=0 on fait le calcul de <span style="font-style:italic">Q</span><sub>0</sub> qui est mis dans 
<span style="font-style:italic">q</span>, quand <span style="font-style:italic">j</span>=1, on fait
le calcul de <span style="font-style:italic">Q</span><sub>1</sub> est mis dans <span style="font-style:italic">q</span>, etc...<br>
On tape :<br>
<span style="font-family:monospace">dfc2reduites([7,3,1,1,3,14])</span><br>
On obtient :<br>
<span style="font-family:monospace">[7,22/3,29/4,51/7,182/25,2599/357]</span>
</p>
<h3 id="sec263" class="subsection">8.19.2  Développement en fraction continue d’un réel quelconque</h3>
<p>
<span style="font-weight:bold">Théorème2</span> Si α est un nombre réel non rationnel,
alors il existe des entiers naturels non nuls 
<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> et un réel β&lt;1 tels que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α=<span style="font-style:italic">a</span><sub>0</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>1</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>2</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−2</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>+β</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
On dit que (<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span>1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>) est le développement en fraction continue 
d’ordre <span style="font-style:italic">n</span>+1 de α et que β est le reste de ce développement.<br>
Un rationnel a un développement en fraction continue fini et 
réciproquement, un développement en fraction continue fini représente 
un rationnel.<br>
Un réel non rationnel a un développement en fraction continue infini.<br>
Si α est un nombre quadratique (i.e. α est racine d’une 
équation du second degré), α a un développement en fraction 
continue périodique et réciproquement, un développement en fraction 
continue périodique représente un nombre quadratique.</p>
<h3 id="sec264" class="subsection">8.19.3  Les programmes</h3>
<p>
On va écrire deux fonctions <span style="font-family:monospace">r2dfc</span> et <span style="font-family:monospace">dfc2r</span>.
</p>
<h4 id="sec265" class="subsubsection">La fonction r2dfc</h4>
<p>
<span style="font-family:monospace">r2dfc(alpha,n)</span> qui transforme un réel <span style="font-family:monospace">alpha</span> en son
développement en fraction continue et qui renvoie deux listes, soit :<br>
- <span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">...</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">p</span></span></sub><span style="font-family:monospace">],[]</span> avec <span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace"> ≤ </span><span style="font-family:monospace"><span style="font-style:italic">n</span></span> où les <span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">j</span></span></sub> sont 
des entiers, la deuxième liste est 
vide et la première liste est le développement en fraction 
continue de <span style="font-family:monospace">alpha</span> (les <span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">j</span></span></sub> sont des entiers et donc <span style="font-family:monospace">alpha</span> 
est une fraction)<br>
- <span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">...</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span><span style="font-family:monospace">-1</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">b</span></span><span style="font-family:monospace">],[]</span>, la deuxième liste est vide et 
la première liste est le développement en fraction 
continue d’ordre <span style="font-style:italic">n</span>−1 de <span style="font-family:monospace">alpha</span> suivi de <span style="font-family:monospace"><span style="font-style:italic">b</span></span><span style="font-family:monospace">&gt;1</span> (le reste est égal à 
<span style="font-family:monospace">1/</span><span style="font-family:monospace"><span style="font-style:italic">b</span></span>), où les <span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">j</span></span></sub> sont des entiers et <span style="font-family:monospace">b</span> est un réel 
plus grand que 1, soit,<br>
- <span style="font-family:monospace">[</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">...</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">p</span></span></sub><span style="font-family:monospace">],[</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">r</span></span></sub><span style="font-family:monospace">,..</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">p</span></span></sub><span style="font-family:monospace">]</span> avec <span style="font-family:monospace"><span style="font-style:italic">r</span></span><span style="font-family:monospace">≤ </span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace"> &lt; </span><span style="font-family:monospace"><span style="font-style:italic">n</span></span><br>
où les <span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">j</span></span></sub> sont des entiers, la première liste est le 
développement en fraction continue d’ordre <span style="font-style:italic">p</span> de <span style="font-family:monospace">alpha</span> et 
la deuxième liste représente la période de cedéveloppement en fraction 
continue (les <span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">j</span></span></sub> sont des entiers et donc <span style="font-family:monospace">alpha</span> est un nombre 
quadratique)<br>
.<br>
On remarquera dans le programme ci-dessous que :<br>
<span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">=</span><span style="font-family:monospace"><span style="font-style:italic">floor</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">alpha</span></span><span style="font-family:monospace">)=</span><span style="font-family:monospace"><span style="font-style:italic">q</span></span> remplace <span style="font-family:monospace"><span style="font-style:italic">q</span></span><span style="font-family:monospace">:=</span><span style="font-family:monospace"><span style="font-style:italic">iquo</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">b</span></span><span style="font-family:monospace">)</span> lorsque 
<span style="font-family:monospace">alpha=a/b</span><br>
et que <span style="font-family:monospace">r=alpha-q</span> remplace <span style="font-family:monospace"><span style="font-style:italic">irem</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">b</span></span><span style="font-family:monospace">)/</span><span style="font-family:monospace"><span style="font-style:italic">b</span></span> lorsque 
<span style="font-family:monospace">alpha=a/b</span><br>
et donc que si <span style="font-family:monospace">r=alpha-q</span>, <span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">=</span><span style="font-family:monospace"><span style="font-style:italic">floor</span></span><span style="font-family:monospace">(1/</span><span style="font-family:monospace"><span style="font-style:italic">r</span></span><span style="font-family:monospace">)</span> etc...<br>
Le problème ici est de pouvoir comparer <span style="font-family:monospace">alpha</span> et <span style="font-family:monospace">q</span> 
c’est à dire savoir si <span style="font-family:monospace">r==0</span> et pour cela on est obligé de
faire les calculs avec beaucoup de décimales c’est à dire d’augmenter 
le nombre de digits (on tape par exemple <span style="font-family:monospace">DIGITS:=30</span>). 
Il faut bien sûr repérer la période, pour cela on forme la liste 
<span style="font-family:monospace">lr</span> des restes successifs. La liste <span style="font-family:monospace">lq</span> des parties entières
successives forme le début du développement en fraction continue.
</p><pre class="verbatim">r2dfc(alpha,n):={
local r,q,lq,lr,p,j;
q:=floor(alpha);
r:=normal(alpha-q);
lq:=[];
lr:=[];
for (j:=1;j&lt;=n;j:=j+1) {
lq:=concat(lq,q);
if (r==0){return (lq,[]);}
p:=member(r,lr);
if (p) {return (lq,mid(lq,p)):}
lr:=concat(lr,r);
alpha:=normal(1/r);
q:=floor(alpha);
r:=normal(alpha-q);
}
return (concat(lq,alpha),[]);
};
</pre><p>
On tape :<br>
<span style="font-family:monospace">dfc2r(sqrt(2),1)</span><br>
On obtient :<br>
<span style="font-family:monospace">([1,sqrt(2)+1],[])</span><br>
On tape :<br>
<span style="font-family:monospace">dfc2r(sqrt(2),2)</span><br>
On obtient :<br>
<span style="font-family:monospace">([1,2],[2])</span><br>
On tape :<br>
<span style="font-family:monospace">dfc2r(pi),6</span><br>
On obtient :<br>
<span style="font-family:monospace">([3,7,15,1,292,1,(-33102*pi+103993)/(33215*pi-104348)],[])</span>
<span style="font-weight:bold">Remarque</span>
Le premier argument doit être un nombre exact, car sinon les calculs sont 
faits en mode approché et le test r==0 n’est jamais réalisé...
</p>
<h4 id="sec266" class="subsubsection">La fonction dfc2r</h4>
<p>
On écrit la fonction réciproque de <span style="font-family:monospace">r2dfc</span> qui à partir d’un 
développement en fraction continue et d’un reste éventuel ou d’un 
développement en fraction continue et d’une période éventuelle 
renvoie un réel.<br>
<span style="font-family:monospace">dfc2r(d,t)</span> transforme en un réel, la liste <span style="font-family:monospace">d</span> représente un
développement en fraction continue et la liste 
<span style="font-family:monospace">t</span> représente la période.<br>
On remarquera que lorsque la liste 
<span style="font-family:monospace">t</span> n’est pas vide il faut déterminer le nombre <span style="font-family:monospace">0&lt;y&lt;1</span> qui admet 
cette liste périodique comme développement en fraction continue et 
pour ce faire résoudre l’équation :<br>
<span style="font-family:monospace"><span style="font-style:italic">y</span></span><span style="font-family:monospace">=(0,</span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,...</span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">st</span></span><span style="font-family:monospace">-1</span></sub><span style="font-family:monospace">+</span><span style="font-family:monospace"><span style="font-style:italic">y</span></span><span style="font-family:monospace">)</span>
le reste est alors <span style="font-family:monospace"><span style="font-style:italic">y</span></span><span style="font-family:monospace">+</span><span style="font-family:monospace"><span style="font-style:italic">d</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">s</span></span><span style="font-family:monospace">-1</span></sub> (<span style="font-family:monospace">s:=size(d)</span>).<br>
On écrit le programme :
</p><pre class="verbatim">dfc2r(d,t):={
local s,st,alpha,l,ap,k;
s:=size(d);
alpha:=d[s-1];
for (k:=s-2;k&gt;=0;k:=k-1) {alpha:=normal(d[k]+1/alpha);}
if (t==[]) {return normal(alpha);}
st:=size(t);
purge(y);
ap:=t[st-1]+y;
for (k:=st-2;k&gt;=0;k:=k-1) {ap:=normal(t[k]+1/ap);}
l:=solve(y=1/ap,y);
if (l[0]&gt;0){y:=normal(l[0]);}else{y:=normal(l[1]);};
alpha:=d[s-1]+y;
for (k:=s-2;k&gt;=0;k:=k-1) {alpha:=normal(d[k]+1/alpha);}
return(normal(a)lpha);
};
</pre><p>
ou avec une écriture plus concise :
</p><pre class="verbatim">dfc2r(d,t):={
local s,st,alpha,l,ap,k;
s:=size(d);
st:=size(t);
if (st==0) 
  {y:=0;} 
   else 
 {purge(y);
  ap:=t[st-1]+y;
  for (k:=st-2;k&gt;=0;k:=k-1) {ap:=normal(t[k]+1/ap);}
  l:=solve(y=1/ap,y);
  if (l[0]&gt;0){y:=normal(l[0]);}else{y:=normal(l[1]);};
  }
alpha:=d[s-1]+y;
for (k:=s-2;k&gt;=0;k:=k-1) {alpha:=normal(d[k]+1/alpha);}
return(normal(alpha));
};
</pre>
<h3 id="sec267" class="subsection">8.19.4  Exemples</h3>
<p>
1/ Développement en fraction continue de :
<span style="font-family:monospace">1393/972</span>,
<span style="font-family:monospace">1+√</span><span style="font-family:monospace"><span style="text-decoration:overline">13</span></span> et 
<span style="font-family:monospace">1-√</span><span style="font-family:monospace"><span style="text-decoration:overline">13</span></span>.<br>
On a :<br>
<span style="font-family:monospace">r2dfc(1393/972,3)=[1,2,3,130/31],[]</span><br>
<span style="font-family:monospace">r2dfc(1393/972,7)=[1,2,3,4,5,6],[]</span><br>
et on a bien :<br>
<span style="font-family:monospace">r2dfc(130/31,3)=[4,5,6],[]</span><br>
<span style="font-family:monospace">r2dfc(31/130,4)=[0,4,5,6],[]</span><br>
On peut vérifier que :<br>
<span style="font-family:monospace">dfc2r([1,2,3,4,5,6],[])=1393/972</span><br>
<span style="font-family:monospace">dfc2r([1,2,3+31/130],[])=dfc2r([1,2,3,130/31],[])=1393/972</span><br>
On a : <br>
<span style="font-family:monospace">r2dfc(1+sqrt(13),3)=[4,1,1,(sqrt(13)+2)/3],[]</span><br>
<span style="font-family:monospace">r2dfc(1+sqrt(13),6)=[4,1,1,1,1,6],[1,1,1,1,6]</span><br>
<span style="font-family:monospace">r2dfc(1-sqrt(13),7)=[-3,2,1,1,6,1,1],[1,1,6,1,1]</span></p><p>2/ Trouver les réels qui ont comme développement en fraction continue :<br>
<span style="font-family:monospace">[2,4,4,4,4,4....]</span> (suite illimitée de <span style="font-family:monospace">4</span>) et<br>
<span style="font-family:monospace">[1,1,1,1,1,1....]</span> (suite illimitée de <span style="font-family:monospace">1</span>).<br>
On a :<br>
<span style="font-family:monospace">dfc2r([2,4],[4])=sqrt(5)</span>
ou encore
<span style="font-family:monospace">dfc2r([2],[4])=sqrt(5)</span>
On a :<br>
<span style="font-family:monospace">dfc2r([1],[1])=(sqrt(5)+1)/2</span>
</p>
<h3 id="sec268" class="subsection">8.19.5  Suite des réduites successives d’un réel</h3>
<p>
Si <span style="font-family:monospace">alpha</span> a comme développement en fraction continue
<span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">,....</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub><span style="font-family:monospace">....)</span>, la suite des réduites est la suite des 
nombres rationnels ayant comme développement en fraction continue :
<span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">),(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">),..,(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">....</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub><span style="font-family:monospace">),.... </span>.<br>
On écrit le programme permettant d’obtenir les <span style="font-family:monospace">p</span> premières 
réduites de <span style="font-family:monospace">alpha</span>.<br>
On écrit le programme <span style="font-family:monospace">reduiten</span> (on recalcule les réduites sans 
se servir des relations de récurrence) :
</p><pre class="verbatim">reduiten(alpha,p):={
local l,k,ld,lt,st,s,q,lred,redu;
ld:=r2dfc(alpha,p);
l:=ld[0];
s:= size(l);
if (s&lt;p) {
  lt:=ld[1];
  st:=size(lt);
  if (st!=0){
    q:=iquo(p-s,st);
    for (j:=0;j&lt;=q; j++){
      l:= concat(l,lt)
    }
  }
  else {
  p:=s;
  } 
}
lred:=[];
for (k:=1;k&lt;=p;k++){
  redu:=dfc2r(mid(l,0,k),[]);
  lred:=append(lred,redu);
}
return (lred);
};
</pre><p>
<span style="font-family:monospace">reduiten(sqrt(53),5)</span><br>
On obtient :<br>
<span style="font-family:monospace">[7,22/3,29/4,51/7,182/25]</span><br>

On écrit maintenant le programme <span style="font-family:monospace">reduite</span> permettant d’obtenir les 
<span style="font-family:monospace">p</span> premières réduites de <span style="font-family:monospace">alpha</span>, en se servant de la fonction 
<span style="font-family:monospace">dfc2reduites</span> écrite auparavant et qui utilise les relations de 
récurrence.
</p><pre class="verbatim">reduite(alpha,p):={
local l,ld,lt,st,s,q,lred;
ld:=r2dfc(alpha,p);
l:=ld[0];
s:= size(l);
if (s&lt;p) {
  lt:=ld[1];
  st:=size(lt);
  if (st!=0){
    q:=iquo(p-s,st);
    for (j:=0;j&lt;=q; j++){
      l:= concat(l,lt)
    }
  }
}  
l:= mid(l,0,p);
lred:=dfc2reduites(l);
return lred;
}
</pre><p>
On tape :<br>
<span style="font-family:monospace">reduite(sqrt(53),5)</span><br>
On obtient :<br>
<span style="font-family:monospace">[7,22/3,29/4,51/7,182/25]</span><br>
On tape :<br>
<span style="font-family:monospace">reduite(11/3,2)</span><br>
On obtient :<br>
<span style="font-family:monospace">[3,4]</span>
</p>
<h3 id="sec269" class="subsection">8.19.6  Suite des réduites "plus 1" successives d’un réel</h3>
<p>
Si <span style="font-family:monospace">alpha</span> a comme développement en fraction continue
<span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">,....</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub><span style="font-family:monospace">....)</span>, la suite des réduites "plus 1"
est la suite des nombres 
rationnels ayant comme développement en fraction continue :
<span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">+1),(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">+1),..,(</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">0</span></sub><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace">....</span><span style="font-family:monospace"><span style="font-style:italic">a</span></span><sub><span style="font-family:monospace"><span style="font-style:italic">n</span></span></sub><span style="font-family:monospace">+1),.... </span>.<br>
On écrit le programme permettant d’obtenir les <span style="font-family:monospace">p</span> premières 
réduites "plus 1" de <span style="font-family:monospace">alpha</span>.
</p><pre class="verbatim">reduite1(alpha,p):={
local l,ld,lt,st,s,q,lred;
ld:=r2dfc(alpha,p);
l:=ld[0];
s:= size(l);
if (s&lt;p) {
  lt:=ld[1];
  st:=size(lt);
  if (st!=0){
    q:=iquo(p-s,st);
    for (j:=0;j&lt;=q; j++){
    l:= concat(l,lt)
    }
  }
}  
l:= mid(l,0,p)+1;
lred:=dfc2reduites(l);
return lred;
}
</pre>
<h3 id="sec270" class="subsection">8.19.7  Propriété des réduites</h3>
<p>
<span style="font-weight:bold">Propriété des réduites de </span><span style="font-weight:bold"><span style="font-family:monospace">alpha</span></span> :<br>
Une réduite <span style="font-family:monospace">p/q</span> approche <span style="font-family:monospace">alpha</span> à moins de <span style="font-family:monospace">1/</span><span style="font-family:monospace"><span style="font-style:italic">q</span></span><sup><span style="font-family:monospace">2</span></sup> et si
<span style="font-family:monospace">s/t</span> est la réduite plus 1 de même rang <span style="font-family:monospace">n</span> on a :<br>
- <span style="font-family:monospace">|</span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">q</span></span><span style="font-family:monospace">-</span><span style="font-family:monospace"><span style="font-style:italic">s</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><span style="font-family:monospace">|&lt;1/</span><span style="font-family:monospace"><span style="font-style:italic">q</span></span><sup><span style="font-family:monospace">2</span></sup> <br>
- si <span style="font-family:monospace">n</span> est pair <span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">q</span></span><span style="font-family:monospace"> ≤ </span><span style="font-family:monospace"><span style="font-style:italic">alpha</span></span><span style="font-family:monospace"> ≤ </span><span style="font-family:monospace"><span style="font-style:italic">r</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">s</span></span><br>
- si <span style="font-family:monospace">n</span> est impair <span style="font-family:monospace"><span style="font-style:italic">r</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">s</span></span><span style="font-family:monospace"> ≤ </span><span style="font-family:monospace"><span style="font-style:italic">alpha</span></span><span style="font-family:monospace"> ≤ </span><span style="font-family:monospace"><span style="font-style:italic">p</span></span><span style="font-family:monospace">/</span><span style="font-family:monospace"><span style="font-style:italic">q</span></span><br>
- les réduites de rang pair et les réduites de rang impair forment 
deux suites adjacentes qui convergent vers <span style="font-family:monospace">alpha</span><br>
- les réduites plus 1 de rang pair et les réduites plus 1 de rang impair 
forment deux suites adjacentes qui convergent vers <span style="font-family:monospace">alpha</span><br>
Donc, si on pose :<br>
<span style="font-family:monospace">lred:=reduite(alpha,10)</span> et 
<span style="font-family:monospace">lred1:=reduite1(alpha,10)</span>,
ces deux suites <span style="font-family:monospace">lred</span> et <span style="font-family:monospace">lred1</span> fournissent un encadrement de 
<span style="font-family:monospace">alpha</span> plus précisément on a :<br>
<span style="font-family:monospace">lred[0] </span>≤<span style="font-family:monospace"> lred1[1]</span>≤..≤<span style="font-family:monospace"> lred[2p] </span>≤<span style="font-family:monospace"> lred1[2p+1]&lt;alpha</span><br>
<span style="font-family:monospace">alpha&lt;lred[2p+1]</span>≤<span style="font-family:monospace"> lred1[2p] </span>≤ ...≤<span style="font-family:monospace"> lred[1] </span>≤<span style="font-family:monospace"> lred1[0]</span><br>
c’est à dire que l’encadrement fait avec 2 réduites successives de rang
<span style="font-style:italic">p</span>−1 et <span style="font-style:italic">p</span> est moins bon que l’encadrement fait avec la réduite de rang 
<span style="font-style:italic">p</span> et la réduite plus 1 de rang <span style="font-style:italic">p</span>.<br>
<span style="font-weight:bold">Exemple</span><br>
On a :<br>
<span style="font-family:monospace">r2dfc(sqrt(53),5)= [7,3,1,1,3,sqrt(53)+7],[]</span><br>
<span style="font-family:monospace">dfc2r([7,3,1,1,3],[])=182/25</span><br>
<span style="font-family:monospace">reduite(sqrt(53),5)[4]=182/25=7.28</span><br>
<span style="font-family:monospace">reduite1(sqrt(53),5)[4]=233/32=7.28125</span><br>
<span style="font-family:monospace">reduite(182/25,5)[4]=182/25=7.28</span><br>
<span style="font-family:monospace">reduite1(182/25,5)[4]=233/32=7.28125</span><br>
et donc <span style="font-family:monospace">7.28&lt;√</span><span style="font-family:monospace"><span style="text-decoration:overline">53</span></span><span style="font-family:monospace">&lt;7.28125</span><br>
<span style="font-family:monospace">r2dfc(sqrt(53),6)= [7,3,1,1,3,14],[3,1,1,3,14]</span><br>
<span style="font-family:monospace">dfc2r([7,3,1,1,3,14],[])=2599/357</span><br>
<span style="font-family:monospace">reduite(sqrt(53),6)[5]=2599/357=7.28011204482</span><br>
<span style="font-family:monospace">reduite1(sqrt(53),6)[5]=2781/382=7.28010471204</span><br>
<span style="font-family:monospace">reduite(2599/357,5)[4]=2599/357=7.28011204482</span><br>
<span style="font-family:monospace">reduite1(2599/357,5)[4]=2781/382=7.28010471204</span><br>
et donc <span style="font-family:monospace">7.28010471204&lt;√</span><span style="font-family:monospace"><span style="text-decoration:overline">53</span></span><span style="font-family:monospace">&lt;7.28011204482</span><br>
On a 1/357<sup>2</sup>=7.84627576521<span style="font-style:italic">e</span>−06 et 1/382<sup>2</sup>=6.8528823223<span style="font-style:italic">e</span>−06</p>
<h2 id="sec271" class="section">8.20  Suite de Hamming</h2>
<h3 id="sec272" class="subsection">8.20.1  La définition</h3>
<p>
La suite de Hamming est la suite des nombres entiers qui n’ont pour diviseurs 
premiers que 2, 3 et 5.<br>
Cette suite commence par : [2,3,4,5,6,8,9,10,12,15,16,18,20,24,25...]<br>
</p>
<h3 id="sec273" class="subsection">8.20.2  L’algorithme à l’aide d’un crible</h3>
<p>
On écrit tous les nombres de Hamming de 0 à <span style="font-family:monospace">n&gt;0</span> et on barre les 
nombres qui sont de la forme 2<sup><span style="font-style:italic">a</span></sup>*3<sup><span style="font-style:italic">b</span></sup>*5<sup><span style="font-style:italic">c</span></sup> avec <span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>,<span style="font-style:italic">c</span> variant de 0 à un
nombre tel que 2<sup><span style="font-style:italic">a</span></sup>*3<sup><span style="font-style:italic">b</span></sup>*5<sup><span style="font-style:italic">c</span></sup> ≤ <span style="font-style:italic">n</span>: les nombres barrés (excepté 1) 
sont les nombres de Hamming inférieurs à <span style="font-family:monospace">n&gt;0</span>.<br>
Voici la fonction <span style="font-family:monospace">hamming(n)</span> écrite en <span style="font-family:monospace">Xcas</span> pour obtenir
les nombres de Hamming inférieurs à <span style="font-family:monospace">n&gt;0</span>.
</p><pre class="verbatim">hamming(n):={
  local H,L,a,b,c,j,d;
  L:=makelist(x-&gt;x,0,n);
  //les nbres de Hamming sont 2^a*3^b*5^c
  c:=0; b:=0;a:=0;
  d:=1;
  while (d&lt;=n) { 
    while (d&lt;=n){ 
      while (d&lt;=n) {
 L[d]:=0;
 //d:=5*d
 c:=c+1;
 d:=2^a*3^b*5^c; 
      }
      c:=0; 
      b:=b+1;
      //d:=2^a*3^b*5^c
      d:=2^a*3^b;
    }
    //c:=0;
    b:=0;
    a:=a+1;
    //d:=2^a*3^b*5^c
    d:=2^a;
  }
  H:=[];
  for (j:=2;j&lt;=n;j++) {
    if (L[j]==0) H:=append(H,j);
  }
  return H;
}
</pre><p>
ou encore en supprimant la variable c :
</p><pre class="verbatim">hamming(n):={
  local H,L,a,b,j,d;
  L:=makelist(x-&gt;x,0,n);
  //les nbres de Hamming sont 2^a*3^b*5^c
 a:=0;
  d:=1;
  while (d&lt;=n) { 
    b:=0; 
    while (d&lt;=n){ 
      while (d&lt;=n) {
 L[d]:=0;
 d:=5*d; 
      } 
      b:=b+1;
      d:=2^a*3^b;
    }
    a:=a+1;
    d:=2^a;
  }
  H:=[];
  for (j:=2;j&lt;=n;j++) {
    if (L[j]==0) H:=append(H,j);
  }
  return H;
}
</pre><p>
ou encore en supprimant a,b,c et en preservant la valeur de d avant les while :
</p><pre class="verbatim">hamming(n):={
  local H,L,d,j,k;
  L:=makelist(x-&gt;x,0,n);
  //les nbres de Hamming sont 2^a*3^b*5^c
  d:=1;
  while (d&lt;=n) { 
    j:=d; 
    while (j&lt;=n){
      k:=j; 
      while (k&lt;=n) {
 L[k]:=0;
 k:=5*k; 
      } 
      j:=3*j;
    }
    d:=2*d;
  }
  H:=[];
  for (j:=2;j&lt;=n;j++) {
    if (L[j]==0) H:=append(H,j);
  }
  return H;
}
</pre><p>
On tape :<br>
<span style="font-family:monospace">hamming(20)</span><br>
On obtient :<br>
<span style="font-family:monospace">[2,3,4,5,6,8,9,10,12,15,16,18,20]</span><br>
On tape :<br>
<span style="font-family:monospace">hamming(40)</span><br>
On obtient :<br>
<span style="font-family:monospace">[2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40]</span>
</p>
<h3 id="sec274" class="subsection">8.20.3  L’algorithme sans faire un crible</h3>
<p>
Supposons que l’on ait trouvé les premiers éléments de cette suite par
exemple : 2,3,4,5.<br>
L’élément suivant est obtenu en multipliant une des cases 
précédentes par 2, 3 ou 5.<br>
Le problème c’est d’avoir les éléments suivants dans l’ordre....<br>
Comment trouver lélément suivant de <span style="font-family:monospace">H:=[2,3,4,5]</span> :<br>
on a déja multiplié <span style="font-family:monospace">H[0]=2</span> par 2 pour obtenir 4 donc<br>
on peut multiplier <span style="font-family:monospace">H[1]=3</span> par 2 pour obtenir m=6 ou<br>
multiplier <span style="font-family:monospace">H[0]=2</span> par 3 pour obtenir p=6 ou<br>
multiplier <span style="font-family:monospace">H[0]=2</span> par 5 pour obtenir q=10.<br>
L’élément suivant est donc 6=min(6,6,10) et <span style="font-family:monospace">H:=[2,3,4,5,6]</span>.<br>
Maintenant, on a déja multiplier 
<span style="font-family:monospace">H[0]=2</span> par 2 et par 3 pour obtenir 4 et 6 et<br>
on a déja multiplier <span style="font-family:monospace">H[1]=3</span> par 2 pour obtenir 6 donc<br>
donc<br>
on peut multiplier <span style="font-family:monospace">H[2]=4</span> par 2 pour obtenir m=8 ou<br>
multiplier <span style="font-family:monospace">H[1]=3</span> par 3 pour obtenir p=9 ou<br>
multiplier <span style="font-family:monospace">H[0]=2</span> par 5 pour obtenir q=10.<br>
L’élément suivant est donc 8=min(8,9,10) et <span style="font-family:monospace">H:=[2,3,4,5,6,8]</span>.<br>
Pour que chaque terme de la suite soit multiplié par 2, par 3 et par 5,
il faut donc pévoir 3 indices :<br>
<span style="font-family:monospace">k0</span> qui sera l’indice de l’élément qu’il faut multiplier par 2,<br>
<span style="font-family:monospace">k1</span> qui sera l’indice de l’élément qu’il faut multiplier par 3,<br>
<span style="font-family:monospace">k2</span> qui sera l’indice de l’élément qu’il faut multiplier par 5.<br>
Cela signifie que :<br>
pour tout <span style="font-family:monospace">r&lt;k0</span> les <span style="font-family:monospace">2*H[r]</span> ont déjà été rajoutés,<br>
pour tout <span style="font-family:monospace">r&lt;k1</span> les <span style="font-family:monospace">3*H[r]</span> ont déjà été rajoutés,<br>
pour tout <span style="font-family:monospace">r&lt;k2</span> les <span style="font-family:monospace">5*H[r]</span> ont déjà été rajoutés,<br>
Naturellement <span style="font-family:monospace">k0</span>≥ <span style="font-family:monospace">k1</span>≥ <span style="font-family:monospace">k2</span>.<br>
Les 3 candidats pour être l’élément suivant sont donc :<br>
<span style="font-family:monospace">2*H[k0]</span>, <span style="font-family:monospace">3*H[k1]</span>, <span style="font-family:monospace">5*H[k2]</span><br>
l’un de ces éléments est plus petit que les autres et on le rajoute à la 
suite. Il faut alors augmenter l’indice correspondant de 1 : par exemple 
si c’est <span style="font-family:monospace">3*H[k1]</span> qui est le minimum il faut augmenter <span style="font-family:monospace">k1</span> de 1 et
si <span style="font-family:monospace">3*H[k1]</span>= <span style="font-family:monospace">5*H[k2]</span> est le minimum, il faut augmenter <span style="font-family:monospace">k1</span> et 
<span style="font-family:monospace">k2</span> de 1. 
</p>
<h3 id="sec275" class="subsection">8.20.4  La traduction de l’algorithme avec Xcas</h3>
<p>
<span style="font-family:monospace">hamming(n)</span> va renvoyer les <span style="font-family:monospace">n</span> premiers éléments de la suite de 
Hamming.<br>
L’indice <span style="font-family:monospace">j</span> sert simplement à compter les éléments de <span style="font-family:monospace">H</span>.<br>
<span style="font-family:monospace">k</span> est une suite qui contient les indices <span style="font-family:monospace">k0,k1,k2</span>.<br>
On peut initialiser <span style="font-family:monospace">H</span> à <span style="font-family:monospace">[2,3,4,5]</span> donc <span style="font-family:monospace">j</span> à <span style="font-family:monospace">4</span>,
et <span style="font-family:monospace">k</span> à <span style="font-family:monospace">[1,0,0]</span> (car <span style="font-family:monospace">H[0]=2</span> a été multiplié par 2, 
mais pas par 3, ni par 5) mais cela suppose <span style="font-family:monospace">n&gt;3</span>.<br>
On peut aussi initialiser <span style="font-family:monospace">H</span> à <span style="font-family:monospace">[1]</span>, <span style="font-family:monospace">k</span> à <span style="font-family:monospace">[0,0,0]</span>
(<span style="font-family:monospace">H[0]=1</span> n’a pas été multiplié par 2, ni par 3, ni par 5)
et <span style="font-family:monospace">j</span> à <span style="font-family:monospace">0</span> puis enlever <span style="font-family:monospace">1</span> de <span style="font-family:monospace">H</span> à la fin car <span style="font-family:monospace">1</span> 
n’est pas un terme de la suite.<br>

Voici la fonction <span style="font-family:monospace">hamming(n)</span> écrite en <span style="font-family:monospace">Xcas</span> pour <span style="font-family:monospace">n&gt;3</span>.
</p><pre class="verbatim">//pour n&gt;3
hamming(n):={
  local H,j,k,m,p,q,mi;
  H:=[2,3,4,5];
  j:=4;
  k:=[1,0,0];
  while (j&lt;n) {
  m:=2*H[k[0]];
  p:=3*H[k[1]];
  q:=5*H[k[2]];
  mi:=min(m,p,q);
  H:=append(H,mi);
  j:=j+1;
  if (mi==m) {k[0]:=k[0]+1};
  if (mi==p) {k[1]:=k[1]+1};
  if (mi==q) {k[2]:=k[2]+1};
  }
  return H;
}
</pre><p>
Voici la fonction <span style="font-family:monospace">hamming(n)</span> écrite en <span style="font-family:monospace">Xcas</span> pour <span style="font-family:monospace">n&gt;0</span>.
</p><pre class="verbatim">//pour n&gt;0
hamming(n):={
  local H,j,k,m,p,q,mi;
  H:=[1];
  j:=0;
  k:=[0,0,0];
  while (j&lt;n) {
  m:=2*H[k[0]];
  p:=3*H[k[1]];
  q:=5*H[k[2]];
  mi:=min(m,p,q);
  H:=append(H,mi);
  j:=j+1;
  if (mi==m) {k[0]:=k[0]+1};
  if (mi==p) {k[1]:=k[1]+1};
  if (mi==q) {k[2]:=k[2]+1};
  }
  return tail(H);
}:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">hamming(20)</span><br>
On obtient :<br>
<span style="font-family:monospace">[2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40]</span>
</p>
<h2 id="sec276" class="section">8.21  Développement diadique de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>∈ [0;1[</h2>
<h3 id="sec277" class="subsection">8.21.1  L’énoncé</h3>
<p>
Le développement diadique de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>∈ [0;1[ est lécriture de
<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> sous la forme :
<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=<span style="font-style:italic">d</span><sub>1</sub>/2+<span style="font-style:italic">d</span><sub>2</sub>/2<sup>2</sup>+...+<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>/2<sup><span style="font-style:italic">k</span></sup> avec 
<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>∈ {0,1}.<br>
</p><ol class="enumerate" type=1><li class="li-enumerate">
Écrire un programme qui affiche la liste des <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> se terminant par la liste 
des premiers termes <span style="font-style:italic">d</span><sub>1</sub>,<span style="font-style:italic">d</span><sub>2</sub>..,<span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span></sub> de la suite <span style="font-style:italic">d</span>,<br>
</li><li class="li-enumerate">Écrire un programme qui affiche la liste des <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> se terminant par la 
liste des <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> qui forme la période. Par exemple, on a :<br>
7/12=1/2+0/2<sup>2</sup>+0/2<sup>3</sup>+1/2<sup>4</sup>+0/2<sup>5</sup>+1/2<sup>6</sup>+.... et on écrit [1,0,0,1,0,[1,0]].<br>
</li></ol>
<h3 id="sec278" class="subsection">8.21.2  La solution</h3>
<ol class="enumerate" type=1><li class="li-enumerate">
Si <span style="font-style:italic">q</span>=<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> et si <span style="font-style:italic">d</span><sub>1</sub>=<span style="font-style:italic">floor</span>(2*<span style="font-style:italic">q</span>), on a 
<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=<span style="font-style:italic">d</span><sub>1</sub>/2+2<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>*<span style="font-style:italic">d</span><sub>1</sub>/2*<span style="font-style:italic">b</span>. Donc, 
le développement diadique de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>∈ [0;1[ est lécriture de
<span style="font-style:italic">q</span>=<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> sous la forme : <span style="font-style:italic">d</span><sub>1</sub> suivi du développement diadique de
la fraction 2<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>*<span style="font-style:italic">d</span><sub>1</sub>/2*<span style="font-style:italic">b</span> de [0;1[.<br>
On tape pour avoir les premiers termes <span style="font-style:italic">d</span><sub>1</sub>,<span style="font-style:italic">d</span><sub>2</sub>..,<span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span></sub> de la suite <span style="font-style:italic">d</span> :
<pre class="verbatim">diadiquen(a,b,n):={
local d,q,k,p,L;
p:=2;
L:=NULL;
q:=a/b;
pour k de 1 jusque n faire
d:=floor(p*q);
L:=L,d;
q:=q-d/p;
p:=2*p
fpour;
retourne L;
}:;
</pre>
On tape : <span style="font-family:monospace">diadiquen(3,10,15)</span><br>
On obtient : <span style="font-family:monospace">0,1,0,0,1,1,0,0,1,1,0,0,1,1,0</span><br>
</li><li class="li-enumerate">Pour trouver la période, il faut savoir que l’on commence une période 
lorsque l’on retrouve parmi la liste des nouvelles 
fractions à développer un même numérateur. On garde donc dans <span style="font-family:monospace">A</span> 
la liste des numérateurs en mettant un 0 quand le terme correspondant de <span style="font-style:italic">d</span> 
est nul. <br>
On tape pour avoir les premiers termes de la suite <span style="font-style:italic">d</span> et sa période : 
<pre class="verbatim">diadiques(a,b):={
local d,q,k,p,L,A;
L:=NULL;
A:=NULL;
q:=a/b;
a:=numer(q);
p:=2;
d:=floor(p*q);
repeter
L:=L,d;
si d!=0 alors 
A:=A,a;
sinon 
A:=A,0;
fsi;
q:=q-d/p;
a:=numer(q);
p:=2*p
d:=floor(p*q);
k:=member(a,[A]);
jusqua k!=0 and d!=0;
retourne [L,mid([L],k-1)];
}:;
</pre>
On tape : <span style="font-family:monospace">diadiques(3,10)</span><br>
On obtient : <span style="font-family:monospace">[0,1,0,0,1,[1,0,0,1]]</span>
</li></ol>
<h2 id="sec279" class="section">8.22  Écriture d’un entier comme ∑<sub><span style="font-style:italic">j</span>≥ 1</sub> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub><span style="font-style:italic">j</span>! avec 0≤ <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>&lt;<span style="font-style:italic">j</span></h2>
<h3 id="sec280" class="subsection">8.22.1  L’énoncé</h3>
<p>
On veut écrire un entier <span style="font-style:italic">n</span> ∈ ℕ sous la forme ∑<sub><span style="font-style:italic">j</span>≥ 1</sub> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub><span style="font-style:italic">j</span>! avec 
0≤ <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>&lt;<span style="font-style:italic">j</span> pour tout <span style="font-style:italic">j</span>.<br>
Par exemple 43=1· 4!+3· 3!+0· 2!+1· 1!.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Quel est le plus grand entier <span style="font-style:italic">J</span> tel que <span style="font-style:italic">a</span><sub><span style="font-style:italic">J</span></sub> ≠ 0 ?
</li><li class="li-enumerate">Écrire un programme <span style="font-family:monospace">ecritfac</span> qui renvoie les coefficients <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>
du développement dans l’ordre décroissant : par exemple
<span style="font-family:monospace">ecritfac(43)</span> renverra <span style="font-family:monospace">(1,3,0,1)</span>. 
</li></ol>
<h3 id="sec281" class="subsection">8.22.2  La solution</h3>
<ol class="enumerate" type=1><li class="li-enumerate">
Montrons par recurrence que :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=<span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>= 1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">j</span>· <span style="font-style:italic">j</span>!&lt;<span style="font-style:italic">N</span>!</td></tr>
</table>
vrai pour <span style="font-style:italic">N</span>=2 car 1&lt;2!=2<br>
si ∑<sub><span style="font-style:italic">j</span>= 1</sub><sup><span style="font-style:italic">j</span>=<span style="font-style:italic">N</span>−1</sup> <span style="font-style:italic">j</span>· <span style="font-style:italic">j</span>!&lt;<span style="font-style:italic">N</span>! alors
∑<sub><span style="font-style:italic">j</span>= 1</sub><sup><span style="font-style:italic">j</span>=<span style="font-style:italic">N</span>−1</sup> <span style="font-style:italic">j</span>· <span style="font-style:italic">j</span>!+<span style="font-style:italic">N</span>· <span style="font-style:italic">N</span>!&lt;<span style="font-style:italic">N</span>!+<span style="font-style:italic">N</span>· <span style="font-style:italic">N</span>!=(<span style="font-style:italic">N</span>+1)!<p>Si <span style="font-style:italic">n</span>=∑<sub><span style="font-style:italic">j</span>= 1</sub><sup><span style="font-style:italic">j</span>=<span style="font-style:italic">J</span></sup> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub><span style="font-style:italic">j</span>! avec 0≤ <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>&lt;<span style="font-style:italic">j</span> et <span style="font-style:italic">a</span><sub><span style="font-style:italic">J</span></sub>≠ 0 on a :<br>
<span style="font-style:italic">J</span>!≤ <span style="font-style:italic">n</span>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">J</span></sub><span style="font-style:italic">J</span>!+∑<sub><span style="font-style:italic">j</span>= 1</sub><sup><span style="font-style:italic">j</span>=<span style="font-style:italic">J</span>−1</sup> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub><span style="font-style:italic">j</span>!&lt;<span style="font-style:italic">J</span>· <span style="font-style:italic">J</span>!+∑<sub><span style="font-style:italic">j</span>= 1</sub><sup><span style="font-style:italic">j</span>=<span style="font-style:italic">J</span>−1</sup> <span style="font-style:italic">j</span>· <span style="font-style:italic">j</span>!<br>
donc
<span style="font-style:italic">J</span>!≤ <span style="font-style:italic">n</span>&lt;(<span style="font-style:italic">J</span>+1)!
</p></li><li class="li-enumerate">On cherche d’abord la valeur de <span style="font-style:italic">J</span>, puis on fait le quotient de <span style="font-style:italic">n</span> par 
<span style="font-style:italic">J</span>! et on recommence avec comme valeur de <span style="font-style:italic">n</span> le reste de la division de 
<span style="font-style:italic">n</span> par <span style="font-style:italic">J</span>!.<br>
On tape :
<pre class="verbatim">ecritfac(n):={
  local j,J,k,L,a;
  L:=NULL;
  j:=1;
  tantque n&gt;=j! faire j:=j+1 ftantque;
  J:=j-1;
  pour k de J jusque 1 pas -1 faire 
    a:=iquo(n,k!);
    L:=L,a;
    n:=irem(n,k!);
  fpour;
return L;
}:;
</pre>
On tape :
<span style="font-family:monospace">ecritfac(43)</span><br>
On obtient : <span style="font-family:monospace">(1,3,0,1)</span>
On tape :
<span style="font-family:monospace">ecritfac(150)</span><br>
On obtient : <span style="font-family:monospace">(1,1,1,0,0)</span>
</li></ol>
<h2 id="sec282" class="section">8.23  Les nombres de Mersenne</h2>
<h3 id="sec283" class="subsection">8.23.1  Définitions et téorèmes</h3>
<p>
<span style="font-weight:bold">Définitions</span> <br>
Lorsque pour <span style="font-style:italic">p</span> ∈ ℕ, <span style="font-style:italic">M</span><sub><span style="font-style:italic">p</span></sub>=2<sup><span style="font-style:italic">p</span></sup>−1 est premier on dit que c’est un nombre 
premier de <span style="font-weight:bold">Mersenne</span>. <br>
Un nombre <span style="font-style:italic">n</span> est <span style="font-weight:bold">parfait</span> si il est égal à la somme de ses diviseurs 
propres (1 est compris mais pas <span style="font-style:italic">n</span>).<br>
Par exemple 6 et 28 sont parfaits car 6=1+2+3 et 28=1+2+4+7+14.<br>
<span style="font-weight:bold">Téorème 1</span><br>
<span style="font-style:italic">k</span> est un nombre parfait pair si et seulement si il est de la forme
<span style="font-style:italic">k</span>= 2<sup><span style="font-style:italic">n</span>−1</sup>(2<sup><span style="font-style:italic">n</span></sup>−1) avec <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub>=2<sup><span style="font-style:italic">n</span></sup>−1 premier.<br>
<span style="font-weight:bold">Téorème 2</span><br>
Si <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub>=2<sup><span style="font-style:italic">n</span></sup>−1 est premier, alors <span style="font-style:italic">n</span> est aussi premier.<br>
La réciproque est fausse (voir le <span style="font-weight:bold">Test de Lucas-Lehmer</span> ci-après),
par exemple, <span style="font-style:italic">M</span><sub>11</sub> n’est pas premier :<br>
<span style="font-style:italic">M</span><sub>11</sub>=2<sup>11</sup>−1=2047=23*89<br>
<span style="font-weight:bold">Téorème 3</span><br>
Soient 2 nombres premiers <span style="font-style:italic">p</span> et <span style="font-style:italic">q</span>. Si <span style="font-style:italic">q</span> divise <span style="font-style:italic">M</span><sub><span style="font-style:italic">p</span></sub> = 2<sup><span style="font-style:italic">p</span></sup>−1, alors
<span style="font-style:italic">q</span>=+/−1 (mod8) et il existe <span style="font-style:italic">k</span> ∈ ℕ tel que <span style="font-style:italic">q</span> = 2<span style="font-style:italic">kp</span> + 1.<br>
<span style="font-weight:bold">Téorème 4</span><br>
Si <span style="font-style:italic">p</span> un nombre premier vérifiant <span style="font-style:italic">p</span> = 3 (mod4) alors 2<span style="font-style:italic">p</span>+1 est un 
nombre premier si et seulement si 2<span style="font-style:italic">p</span>+1 divides <span style="font-style:italic">M</span><sub><span style="font-style:italic">p</span></sub>.<br>
<span style="font-weight:bold">Téorème 5</span><br>
Si on fait la somme des chiffres d’un nombre parfait pair différent de 6, 
puis la somme des chiffres du résultat et que l’on continue le processus 
alors on obtient 1.<br>
<span style="font-weight:bold">Exercice</span><br>
Écrire un programme qui teste si un nombre <span style="font-style:italic">n</span> vérifie le théorème 5.<br>

Il faut donc utiliser la fonction <span style="font-family:monospace">revlist(convert(n,base,10))</span> de 
<span style="font-family:monospace">Xcas</span> qui renvoie la liste des chiffres de l’écriture en base 10 de 
l’entier <span style="font-family:monospace">n</span>.<br>
On tape :
</p><pre class="verbatim">sumchiffre(n):={
local L,s;
si n==6 alors retourne 1 fsi;
s:=n;
tantque s&gt;9 faire 
L:=convert(n,base,10);
s:=sum(L);
ftantque;
si s==1 alors retourne 1;
sinon  retourne s;
fsi;
}:;
</pre>
<h3 id="sec284" class="subsection">8.23.2  Test de Lucas-Lehmer</h3>
<p>
<span style="font-weight:bold">Test de Lucas-Lehmer</span><br>
Si <span style="font-style:italic">p</span> est un nombre premier alors le nombre de Mersenne <span style="font-style:italic">M</span><sub><span style="font-style:italic">p</span></sub>=2<sup><span style="font-style:italic">p</span></sup>−1 est 
premier si et seulement si 2<sup><span style="font-style:italic">p</span></sup>−1 divise <span style="font-style:italic">S</span>(<span style="font-style:italic">p</span>−1) lorsque <span style="font-style:italic">S</span>(<span style="font-style:italic">n</span>) est la suite
définie par <span style="font-style:italic">S</span>(<span style="font-style:italic">n</span>+1)=<span style="font-style:italic">S</span>(<span style="font-style:italic">n</span>)<sup>2</sup>−2, et <span style="font-style:italic">S</span>(1)=4.
<span style="font-weight:bold">Exercice</span><br>
Écrire le programme correspondant à ce test : on calculera la suite <span style="font-style:italic">S</span>(<span style="font-style:italic">n</span>)
modulo 2<sup><span style="font-style:italic">p</span></sup>−1 pour gagner du temps.<br>
On tape :
</p><pre class="verbatim">Test_LL(p):={
local s,j;      
s := 4;
pour j de 2 jusque p-1 faire
  s := s^2-2 mod n;
fpour;
si s == 0 alors
     return "2^"+string(p)+"-1 est premier";
  sinon
     return "2^"+string(p)+"-1 est non premier";
fsi;
}:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">Test_LL(11213)</span>
On obtient (Evaluation time: 6.43) :<br>
<span style="font-family:monospace">2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">11213-1 est premier</span><br>
On tape :<br>
<span style="font-family:monospace">Test_LL(11351)</span>
On obtient :<br>
<span style="font-family:monospace">2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">11351-1 est non premier</span><br>
<span style="font-weight:bold">Remarque</span><br>
En janvier 1998, un élève ingénieur a prouvé que <span style="font-style:italic">M</span><sub><span style="font-style:italic">p</span></sub> était premier
pour <span style="font-style:italic">p</span>=3021377 (<span style="font-style:italic">M</span><sub><span style="font-style:italic">p</span></sub> a 909526 chiffres !).</p>
<h2 id="sec285" class="section">8.24  Les nombres parfaits et les nombres amiables</h2>
<h3 id="sec286" class="subsection">8.24.1  Les nombres parfaits</h3>
<p>
<span style="font-weight:bold">Définitions</span> <br>
Un nombre <span style="font-style:italic">n</span> est <span style="font-weight:bold">parfait</span> si il est égal à la somme de ses diviseurs 
propres (1 est compris mais pas <span style="font-style:italic">n</span>).<br>
Par exemple 6 et 28 sont parfaits car 6=1+2+3 et 28=1+2+4+7+14.</p><p><span style="font-weight:bold">L’énoncé</span><br>
Quels sont les nombres parfaits inférieurs à 11000?<br>
Montrer que si 2<sup><span style="font-style:italic">p</span></sup>−1 est premier alors 2<sup><span style="font-style:italic">p</span>−1</sup>(2<sup><span style="font-style:italic">p</span></sup>−1) est parfait.
<span style="font-weight:bold">La solution</span><br>
On utilise l’instruction <span style="font-family:monospace">idivis(n)</span> qui renvoie la liste des diviseurs 
de l’entier <span style="font-family:monospace">n</span> et l’instruction <span style="font-family:monospace">sum(L)</span> qui renvoie la somme de la
liste <span style="font-family:monospace">L</span>.<br>
On tape avec les instructions françaises :
</p><pre class="verbatim">parfait(n):={
  local j,a,b,L;
  L:=NULL;
  pour j de 2 jusque n faire
    a:=sum(idivis(j))-j;
    si a==j alors L:=L,j; fsi;
  fpour;
  retourne L;
}:;
</pre><p>
On tape pour avoir les nombres parfaits inférieur à 11000 :<br>
<span style="font-family:monospace">parfait(11000) </span>
0n obtient :<br>
<span style="font-family:monospace">6,28,496,8128</span><br>

Si 2<sup><span style="font-style:italic">p</span></sup>−1 est premier alors les diviseurs de 2<sup><span style="font-style:italic">p</span>−1</sup>(2<sup><span style="font-style:italic">p</span></sup>−1) sont :<br>
1,(2<sup><span style="font-style:italic">p</span></sup>−1),2,2(2<sup><span style="font-style:italic">p</span></sup>−1),2<sup>2</sup>,2<sup>2</sup>(2<sup><span style="font-style:italic">p</span></sup>−1),..2<sup><span style="font-style:italic">p</span>−2</sup>,2<sup><span style="font-style:italic">p</span>−2</sup>(2<sup><span style="font-style:italic">p</span></sup>−1),2<sup><span style="font-style:italic">p</span>−1</sup>,2<sup><span style="font-style:italic">p</span>−1</sup>(2<sup><span style="font-style:italic">p</span></sup>−1).
La somme de ces diviseurs est :<br>
On tape pour avoir cette somme simplifiée et factorisée :<br>
<span style="font-family:monospace">factor(normal(sum(2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">k*(1+2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">p-1),k=0..p-1)))</span><br>
0n obtient :<br>
<span style="font-family:monospace">2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">p*(2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">p -1)</span><br>
La somme de tous les diviseurs propres de 2<sup><span style="font-style:italic">p</span>−1</sup>(2<sup><span style="font-style:italic">p</span></sup>−1) est
2<sup><span style="font-style:italic">p</span>−1</sup>(2<sup><span style="font-style:italic">p</span></sup>−1) donc si 2<sup><span style="font-style:italic">p</span></sup>−1 est premier 2<sup><span style="font-style:italic">p</span>−1</sup>(2<sup><span style="font-style:italic">p</span></sup>−1) est parfait.<br>
Euler a montré que tous les nombres parfaits pairs sont de cette forme.<br>

Donc 2<sup><span style="font-style:italic">p</span>−1</sup>(2<sup><span style="font-style:italic">p</span></sup>−1) est parfait si <span style="font-style:italic">M</span><sub><span style="font-style:italic">p</span></sub>=2<sup><span style="font-style:italic">p</span></sup>−1 est premier.<br>
Pour <span style="font-style:italic">p</span>=2 on a 2<sup>2</sup>−1=3 est premier donc 2*3=6 est parfait.<br>
Pour <span style="font-style:italic">p</span>=3 on a 2<sup>3</sup>−1=7 est premier donc 4*7=28 est parfait.<br>
Pour <span style="font-style:italic">p</span>=5 on a 2<sup>5</sup>−1=31 est premier donc 16*31=496 est parfait.<br>
Pour <span style="font-style:italic">p</span>=7 on a 2<sup>7</sup>−1=127 est premier donc 64*127=8128 est parfait.<br>
Pour <span style="font-style:italic">p</span>=13 on a 2<sup>13</sup>−1=8191 est premier donc 4096*8191=33550336 est parfait.<br>
Pour <span style="font-style:italic">p</span>=17 on a 2<sup>17</sup>−1=13107 est premier donc 65536*131071=8589869056 est parfait (il a été découvert en 1588 par Cataldi).<br>
Pour <span style="font-style:italic">p</span>=19 on a 2<sup>19</sup>−1=524287 est premier donc 262144*524287=137438691328 est parfait (il a été découvert en 1588 par Cataldi).<br>
Puis pour <span style="font-style:italic">p</span>=31,61,89 on a encore 2<sup><span style="font-style:italic">p</span></sup>−1 premier ....<br>
 En 1936 le Dr Samuel I. Krieger dit que pour <span style="font-style:italic">p</span>=257 2<sup>513</sup>−2<sup>256</sup> est 
parfait (il a 155 chiffres ) malheureusement le nombre 2<sup>257</sup>−1 n’est pas 
premier..... .<br>
On refait donc un programme qui teste si 2<sup><span style="font-style:italic">p</span></sup>−1 est premier et on en déduit 
le nombre parfait correspondant.
</p><pre class="verbatim">parfait2(p):={
  local j,a,b,L;
  L:=NULL;
  pour j de 2 jusque p faire
   a:=2^(j-1);
   b:=2*a-1;
   si isprime(b) alors L:=[L,a*b,j]; fsi;
  fpour;
  retourne L;
}:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">A:=parfait2(1100)</span><br>
<span style="font-family:monospace">size(A)</span><br>
On obtient :<br>
<span style="font-family:monospace">14</span><br>
On tape :<br>
<span style="font-family:monospace">A[13]</span><br>
On obtient le 14ième nombre parfait :<br>
<span style="font-family:monospace">[2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">606*(2</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">607-1),607]</span><br>
On tape :<br>
<span style="font-family:monospace">B:=[A]:;</span><br>
<span style="font-family:monospace">col(B,1)</span><br>
On obtient la liste des nombres <span style="font-style:italic">p</span>≤ 1100 tels que 2<sup><span style="font-style:italic">p</span></sup>−1 soit premier :<br>
<span style="font-family:monospace">[2,3,5,7,13,17,19,31,61,89,107,127,521,607]</span><br>
<span style="font-weight:bold">Remarque : relation entre les nombres parfaits et les cubes</span><br>
0n remarque qu’à part 6 chaque nombre parfait est égal à la somme des 
cubes de nombres impairs consécutifs:<br>
28=1<sup>3</sup>+3<sup>3</sup>=<span style="font-family:monospace">sum((2*n+1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3,n=0..1)</span><br>
496=1<sup>3</sup>+3<sup>3</sup>+5<sup>3</sup>+7<sup>3</sup>=<span style="font-family:monospace">sum((2*n+1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3,n=0..3)</span><br>
8128=1<sup>3</sup>+3<sup>3</sup>+5<sup>3</sup>+7<sup>3</sup>+9<sup>3</sup>+11<sup>3</sup>+13<sup>3</sup>+15<sup>3</sup>=<span style="font-family:monospace">sum((2*n+1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3,n=0..7)</span><br>
33550336=<span style="font-family:monospace">sum((2*n+1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3,n=0..63)</span><br>
8589869056=<span style="font-family:monospace">sum((2*n+1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3,n=0..255)</span><br>
137438691328=<span style="font-family:monospace">sum((2*n+1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">3,n=0..511)</span><br>
0n remarque aussi que l’on fait la somme pour <span style="font-style:italic">n</span> variant de 0 à :<br>
1=2<sup>1</sup>−1<br>
3=2<sup>2</sup>−1<br>
7=2<sup>3</sup>−1<br>
63=2<sup>6</sup>−1<br>
255=2<sup>8</sup>−1<br>
511=2<sup>9</sup>−1<br>

<span style="font-weight:bold">Question ouverte</span>
Existe-t-il des nombres parfaits impairs ????????????
Ce que l’on sait c’est que si il en existe un alors il est tres grand !
Cete question est certainement le plus vieux problème de mathematiques non 
résolu....</p>
<h3 id="sec287" class="subsection">8.24.2  Les nombres amiables</h3>
<p>
<span style="font-weight:bold">L’énoncé</span><br>
On se propose d’écrire un programme qui donne la suite des couples amiables 
dont l’un des nombres est inférieur ou égal à un entier <span style="font-style:italic">n</span>. Voici les 
définitions des nombres parfaits et des nombres amiables :<br>
<span style="font-weight:bold">Définitions</span> <br>
Un nombre <span style="font-style:italic">n</span> est <span style="font-weight:bold">parfait</span> si il est égal à la somme de ses diviseurs 
propres (1 est compris mais pas <span style="font-style:italic">n</span>).<br>
Deux nombres <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont <span style="font-weight:bold">amiables</span> ou amis, si l’un est égal à la 
somme des diviseurs propres de l’autre et inversement.<br>
Les nombres parfaits <span style="font-style:italic">a</span> sont des nombres amiables avec eux mêmes.
<span style="font-weight:bold">La solution</span><br>
On utilise l’instruction <span style="font-family:monospace">idivis(n)</span> qui renvoie la liste des diviseurs 
de l’entier <span style="font-family:monospace">n</span> et l’instruction <span style="font-family:monospace">sum(L)</span> qui renvoie la somme de la
liste <span style="font-family:monospace">L</span>.<br>
Pour ne pas avoir 2 fois le même couple on n’affiche que les couples [<span style="font-style:italic">j</span>,<span style="font-style:italic">a</span>] 
avec <span style="font-style:italic">j</span>≤ <span style="font-style:italic">a</span>.<br>
On tape avec les instructions françaises :
</p><pre class="verbatim">amiable(n):={
  local j,a,b,L;
  L:=NULL;
  pour j de 2 jusque n faire
    a:=sum(idivis(j))-j;
    b:=sum(idivis(a))-a;
    si b==j et j&lt;=a alors L:=L,[j,a]; fsi;
  fpour;
  retourne L;
}:;
</pre><p>
On tape pour avoir les nombres amiable inférieur à 11000 :<br>
<span style="font-family:monospace">amiable(11000) </span>
0n obtient :<br>
<span style="font-family:monospace">[6,6],[28,28],[220,284],[496,496],[1184,1210],[2620,2924],
[5020,5564],[6232,6368],[8128,8128],[10744,10856]</span><br>
Les nombres parfaits <span style="font-style:italic">a</span> sont les nombres amiables [<span style="font-style:italic">a</span>,<span style="font-style:italic">a</span>].</p>
<h2 id="sec288" class="section">8.25  Les parallélépipèdes rectangles presque parfaits</h2>
<h3 id="sec289" class="subsection">8.25.1  L’énoncé</h3>
<p>
On se propose d’écrire un programme qui donne les dimensions des 
parallélépipèdes rectangles presque parfaits dont les côtés sont
inférieurs ou égaux à un entier <span style="font-style:italic">n</span>≤ 1000. Voici 
la définition d’un parallélépipède rectangle presque parfait :<br>
<span style="font-weight:bold">Définitions</span> <br>
Un parallélépipède rectangle est presque parfait si :
</p><ol class="enumerate" type=1><li class="li-enumerate">
les longueurs de ses côtés sont des nombres entiers,
</li><li class="li-enumerate">les longueurs des dagonales de ses 3 faces sont aussi des nombres entiers.
</li></ol><p>
Par exemple, le parallélépipède rectangle de côtés 44 17 240 est 
presque parfait.<br>
<span style="font-weight:bold">Attention</span> les 6 permutations de (44 17 240) représentent le même
parallélépipède rectangle.
</p>
<h3 id="sec290" class="subsection">8.25.2  La solution</h3>
<p>
Si 3 entiers (<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>,<span style="font-style:italic">c</span>) vérifiant <span style="font-style:italic">a</span>&lt; <span style="font-style:italic">b</span>&lt; <span style="font-style:italic">c</span> représentent un 
parallélépipède rectangle, pour su’il soit presque parfait il faut que :
</p><ol class="enumerate" type=1><li class="li-enumerate">
√<span style="text-decoration:overline"><span style="font-style:italic">a</span></span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">+</span><span style="text-decoration:overline"><span style="font-style:italic">b</span></span><sup><span style="text-decoration:overline">2</span></sup> soit un entier,
</li><li class="li-enumerate">√<span style="text-decoration:overline"><span style="font-style:italic">a</span></span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">+</span><span style="text-decoration:overline"><span style="font-style:italic">c</span></span><sup><span style="text-decoration:overline">2</span></sup> soit un entier,
</li><li class="li-enumerate">√<span style="text-decoration:overline"><span style="font-style:italic">b</span></span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">+</span><span style="text-decoration:overline"><span style="font-style:italic">c</span></span><sup><span style="text-decoration:overline">2</span></sup> soit un entier
</li></ol><p>
Comment tester qu’un nombre <span style="font-style:italic">p</span> est un carré parfait ?
On peut écrire :<br>
<span style="font-family:monospace">frac(sqrt(p))==0</span> ou<br>
<span style="font-family:monospace">floor(sqrt(p))</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">2-p==0</span><br>
mais cela demande un calcul ! Il est donc préferable d’utiliser la commande
<span style="font-family:monospace">type</span> qui renvoie le type de l’argument. Par exemple :<br>
<span style="font-family:monospace">type(sqrt(4))==integer</span> renvoie <span style="font-family:monospace">1</span> et <span style="font-family:monospace">type(sqrt(5))==integer</span> 
renvoie <span style="font-family:monospace">0</span>.<br>
On tape :
</p><pre class="verbatim">parapparfait(n):={
  local a,b,c,L;
  L:=NULL;
  pour a de 1 jusque n faire
    pour b de a+1 jusque n faire
      si type(sqrt(a^2+b^2))==integer  alors
         pour c de b+1 jusque n faire
           si type(sqrt(a^2+c^2))==integer alors
             si type(sqrt(c^2+b^2))==integer alors 
                L:=L,[a,b,c]; 
             fsi;
           fsi;
        fpour;
      fsi;
    fpour;
  fpour;
  retourne L;
}:;
</pre><p>
0n tape : <span style="font-family:monospace">L:=parapparfait(1000)</span><br>
On obtient (c’est long !): <br>
<span style="font-family:monospace">[44,117,240],[85,132,720],[88,234,480],[132,351,720],</span><br>
<span style="font-family:monospace">[140,480,693],[160,231,792],[176,468,960],[240,252,275],</span><br>
<span style="font-family:monospace">[480,504,550],[720,756,825]</span></p><p>On peut modifier le programme pour avoir pour chaque <span style="font-style:italic">a</span>, une liste provisoire
<span style="font-family:monospace">P</span> qui sera la liste <span style="font-style:italic">a</span>,<span style="font-style:italic">b</span><sub>1</sub>,<span style="font-style:italic">b</span><sub>2</sub>...<span style="font-style:italic">b</span><sub><span style="font-style:italic">p</span></sub> telle que <span style="font-style:italic">a</span><sup>2</sup>+<span style="font-style:italic">b</span><sub><span style="font-style:italic">j</span></sub><sup>2</sup> soit un 
carré. Puis dans cette liste on cherchera les <span style="font-style:italic">b</span><sub><span style="font-style:italic">j</span></sub> et les <span style="font-style:italic">b</span><sub><span style="font-style:italic">k</span></sub> tels que
<span style="font-style:italic">b</span><sub><span style="font-style:italic">j</span></sub><sup>2</sup>+<span style="font-style:italic">b</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup> soit un carré. Le triplet [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span><sub><span style="font-style:italic">j</span></sub>,<span style="font-style:italic">b</span><sub><span style="font-style:italic">k</span></sub>] répond alors à la 
quesstion.<br>
On tape :
</p><pre class="verbatim">paralparfait(n):={
  local a,b,c,L,P,j,s,k,b2;
  L:=NULL;
  pour a de 1 jusque n faire
    P:=a;
    pour b de a+1 jusque n faire
      si type(sqrt(a^2+b^2))==integer  alors
         P:=P,b;
      fsi;
    fpour;
    s:=size(P)-1; 
    pour j de 1 jusque s-1 faire
      b:=P[j];
      b2:=b^2;
      pour k de j+1 jusque s faire
        c:=P[k];
        si type(sqrt(b2+c^2))==integer alors 
          L:=L,[a,b,c]; 
        fsi;
       fpour;
     fpour;
   fpour;
   retourne L;
}:;
</pre><p>
0n tape : <span style="font-family:monospace">L:=paralparfait(1000)</span><br>
On obtient (c’est 2 fois moins long !): <br>
<span style="font-family:monospace">[44,117,240],[85,132,720],[88,234,480],[132,351,720],</span><br>
<span style="font-family:monospace">[140,480,693],[160,231,792],[176,468,960],[240,252,275],</span><br>
<span style="font-family:monospace">[480,504,550],[720,756,825]</span></p><p><span style="font-weight:bold">Remarque</span><br>
On peut facilement avoir les couples <span style="font-style:italic">a</span>,<span style="font-style:italic">b</span> tel que <span style="font-style:italic">a</span><sup>2</sup>+<span style="font-style:italic">b</span><sup>2</sup> soit un carré.<br>
On tape :
</p><pre class="verbatim">sommecarre(n):={
  local a,b,L,P;
  L:=NULL;
  pour a de 1 jusque n faire
    P:=a;
    pour b de a+1 jusque n faire
      si type(sqrt(a^2+b^2))==integer  alors
        P:=P,b;
      fsi;
    fpour;
    si size(P)&gt;1 alors L:=L,[P];fsi;
  fpour;
  retourne L;
}:;
</pre><p>
On tape : <span style="font-family:monospace">sommecarre(100)</span><br>
On obtient : <br>
<span style="font-family:monospace">[3,4],[5,12],[6,8],[7,24],[8,15],[9,12,40],[10,24],</span><br>
<span style="font-family:monospace">[11,60],[12,16,35],[13,84],[14,48],[15,20,36],</span><br>
<span style="font-family:monospace">[16,30,63],[18,24,80],[20,21,48,99],[21,28,72],</span><br>
<span style="font-family:monospace">[24,32,45,70],[25,60],[27,36],[28,45,96],[30,40,72],</span><br>
<span style="font-family:monospace">[32,60],[33,44,56],[35,84],[36,48,77],[39,52,80],</span><br>
<span style="font-family:monospace">[40,42,75,96],[42,56],[45,60],[48,55,64,90],[51,68],</span><br>
<span style="font-family:monospace">[54,72],[56,90],[57,76],[60,63,80,91],[63,84],[65,72],</span><br>
<span style="font-family:monospace">[66,88],[69,92],[72,96],[75,100],[80,84]</span>
Par exemple, on voit que :<br>
20<sup>2</sup>+15<sup>2</sup> est un carré : c’est 25<sup>2</sup>,<br>
20<sup>2</sup>+21<sup>2</sup> est un carré : c’est 29<sup>2</sup>,<br>
20<sup>2</sup>+48<sup>2</sup> est un carré : c’est 52<sup>2</sup>,<br>
20<sup>2</sup>+99<sup>2</sup> est un carré : c’est 101<sup>2</sup>.<br>
ou encore<br>
60<sup>2</sup>+11<sup>2</sup> est un carré : c’est 61<sup>2</sup>,<br>
60<sup>2</sup>+25<sup>2</sup> est un carré : c’est 65<sup>2</sup>,<br>
60<sup>2</sup>+32<sup>2</sup> est un carré : c’est 68<sup>2</sup>,<br>
60<sup>2</sup>+45<sup>2</sup> est un carré : c’est 75<sup>2</sup>,<br>
60<sup>2</sup>+63<sup>2</sup> est un carré : c’est 87<sup>2</sup>,<br>
60<sup>2</sup>+80<sup>2</sup> est un carré : c’est 100<sup>2</sup>.<br>
60<sup>2</sup>+91<sup>2</sup> est un carré : c’est 109<sup>2</sup>.<br>
On peut aussi en déduire que :<br>
60<sup>2</sup>+144<sup>2</sup> est un carré : c’est 156<sup>2</sup> (car 15<sup>2</sup>+36<sup>2</sup>=39<sup>2</sup>).<br>
60<sup>2</sup>+175<sup>2</sup> est un carré : c’est 185<sup>2</sup> (car 12<sup>2</sup>+35<sup>2</sup>=37<sup>2</sup>).<br>
60<sup>2</sup>+297<sup>2</sup> est un carré : c’est 303<sup>2</sup>.(car 20<sup>2</sup>+99<sup>2</sup>=101<sup>2</sup>).<br>
Mais si on veut tous les nombres <span style="font-style:italic">b</span>≤ 300 tels que <span style="font-style:italic">n</span><sup>2</sup>+<span style="font-style:italic">b</span><sup>2</sup> soit un 
carré il est préférable d’écrire le programme :
</p><pre class="verbatim">n2plusb2(n,N):= {
local b,P;
P:=n;
pour b de 1 jusque N faire 
si type(sqrt(n^2+b^2))==integer  alors 
P:=P,b; 
fsi;
fpour ;
P;
}:;
</pre><p>
On tape : <span style="font-family:monospace">n2plusb2(20,1000)</span><br>
On obtient :<br>
<span style="font-family:monospace">20,15,21,48,99</span><br>
On tape : <span style="font-family:monospace">n2plusb2(60,300)</span><br>
On obtient :<br>
<span style="font-family:monospace">60,11,25,32,45,63,80,91,144,175,221,297</span><br>
seul 60<sup>2</sup>+221<sup>2</sup>=229<sup>2</sup> n’avait pas été trouvé précédemment car 229 
est un nombre premier !<br>
On tape : <span style="font-family:monospace">n2plusb2(60,1000)</span><br>
On obtient :<br>
<span style="font-family:monospace">60,11,25,32,45,63,80,91,144,175,221,297,448,899</span>
</p>
<h2 id="sec291" class="section">8.26  Les nombres heureux</h2>
<h3 id="sec292" class="subsection">8.26.1  L’énoncé</h3>
<p>
On se propose d’écrire un programme qui donne la suite des nombres heureux
inférieurs ou égaux à un entier <span style="font-style:italic">n</span>. Voici un algorithme définissant 
cette suite :
</p><ul class="itemize"><li class="li-itemize">
On écrit la suite des nombres entiers de 2 à <span style="font-style:italic">n</span>,
</li><li class="li-itemize">On entoure 2 et on supprime les nombres de 2 en 2,
</li><li class="li-itemize">On entoure 3 et on supprime les nombres de 3 en 3,
</li><li class="li-itemize">On continue de la même façon : à chaque fois, on entoure <span style="font-style:italic">m</span> le 
premier nombre non entouré et on supprime les nombres de <span style="font-style:italic">m</span> en <span style="font-style:italic">m</span>,
</li><li class="li-itemize">On s’arrête quand il ne reste que des nombres entourés : ce sont les nombres heureux
</li></ul><p>
Par exemple :<br>
après la première étape on a : 2,3,5,7,9,11,13,15,17...<br>
après la deuxième étape on a : 2,3,5,7,11,17...<br>
</p>
<h3 id="sec293" class="subsection">8.26.2  La solution</h3>
<p>
Ce programme ressemble au crible d’Eratosthène, mais si <span style="font-style:italic">m</span> est le
nombre que l’on vient d’entourer et qu’il est d’indice <span style="font-style:italic">p</span>, on supprime les 
nombres d’indices <span style="font-style:italic">p</span>+<span style="font-style:italic">m</span>,<span style="font-style:italic">p</span>+2<span style="font-style:italic">m</span>...<span style="font-style:italic">p</span>+<span style="font-style:italic">km</span> mais dans la liste <span style="font-family:monospace">tab</span> modifiée
et non les multiples du nombre <span style="font-style:italic">m</span>.<br>
On tape avec les instructions françaises :
</p><pre class="verbatim">heureux(n):={
  local tab,heur,m,j,p,k;
  tab:=j$(j=2..n);
  tab:=concat([0,0],[tab]);
  heur:=[];
  p:=2;
  tantque (p&lt;=n) faire
    m:=p;
    k:=0;
    pour j de p+1 jusque n faire
      si tab[j]!=0 alors k:=k+1; fsi;
      si irem(k,m)==0 alors tab[j]:=0 fsi;
    fpour;
    p:=p+1;
    si p&lt;=n alors 
      tantque tab[p]==0 and p&lt;n faire p:=p+1 ftantque;
      si p==n and tab[p]==0 alors p:=n+1;fsi;
    fsi;
  ftantque; 
  pour p de 2 jusque n faire
    si (tab[p]!=0) alors 
      heur:=append(heur,p);
    fsi;
  fpour;
  retourne(heur);
}:;
</pre><p>
Dans ce programme on peut se passer de la liste <span style="font-family:monospace">heur</span> : il suffit de
supprimer la dernière instruction <span style="font-family:monospace">pour</span> et de mettre :<br>
<span style="font-family:monospace">retourne remove(x-&gt;x==0,tab);</span> à la place de <span style="font-family:monospace">retourne heur</span>
On tape : <span style="font-family:monospace">heureux(100)</span><br>
On obtient :<br>
<span style="font-family:monospace">[2,3,5,7,11,13,17,23,25,29,37,41,43,47,53,61,67,71,77,83,89,91,97]</span></p><p>On peut aussi et ce sera plus rapide, modifier la liste <span style="font-family:monospace">tab</span> au fur et 
à mesure en supprimant à chaque étape les valeurs barrées c’est à 
dire les valeurs mises à 0 en utilisant l’instruction <span style="font-family:monospace">remove</span> et en 
mettant au fur et à mesure les nombres heureux dans <span style="font-family:monospace">heur</span>.<br>
On tape avec les instructions françaises :
</p><pre class="verbatim">//renvoie la liste des nombres heureux&lt;=n
heureux2(n):={
  local tab,heur,m,j,k,s;
  tab:=[j$(j=2..n)];
  heur:=[];
  s:=dim(tab);
  k:=0;
  tantque (s&gt;0) faire
    j:=0;
    m:=tab[0];
    heur[k]:=m;
    tantque j&lt;s faire
      tab[j]:=0;
      j:=j+m;
    ftantque;
      tab:=remove(x-&gt;x==0,tab);
      s:=dim(tab);
      k:=k+1;
  ftantque;
  retourne(heur);
}:;
</pre><p>
On tape : <span style="font-family:monospace">heureux2(100)</span><br>
On obtient :<br>
<span style="font-family:monospace">[2,3,5,7,11,13,17,23,25,29,37,41,43,47,53,61,67,71,77,<br>
 83,89,91,97]</span>
</p>
<h2 id="sec294" class="section">8.27  L’équation de Pell</h2>
<h3 id="sec295" class="subsection">8.27.1  Les proriétés</h3>
<p>
Résoudre l’équation de Pell c’est trouver les plus petits entiers <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span> qui
sont solutions de <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">n</span>*<span style="font-style:italic">y</span><sup>2</sup>=1 lorsque <span style="font-style:italic">n</span> est un entier.<br>
Euler à montré que l’on pouvait résoudre cette équation à l’aide du 
développement en fraction continue de √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> (par exemple <span style="font-family:monospace">dfc(n,20)</span>).
Supposons que le développement en fraction continue de √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> soit de 
période <span style="font-style:italic">k</span>. On a :
</p><ul class="itemize"><li class="li-itemize">
pour <span style="font-style:italic">k</span>=2<span style="font-style:italic">h</span>−1,<br>
 √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>=[<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,..,<span style="font-style:italic">a</span><sub>1</sub>,2<span style="font-style:italic">a</span><sub>0</sub>],[<span style="font-style:italic">a</span><sub>1</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,..,<span style="font-style:italic">a</span><sub>1</sub>,2<span style="font-style:italic">a</span><sub>0</sub>]].<br>
<span style="font-weight:bold">Par exemple</span><br>
<span style="font-family:monospace">dfc(sqrt(13),20)=[3,1,1,1,1,6,[1,1,1,1,6]]</span><br>
</li><li class="li-itemize">pour <span style="font-style:italic">k</span>=2<span style="font-style:italic">h</span>,<br>
√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>=[<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span></sub>, <span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,..,<span style="font-style:italic">a</span><sub>1</sub>,2<span style="font-style:italic">a</span><sub>0</sub>],[<span style="font-style:italic">a</span><sub>1</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span></sub>,<span style="font-style:italic">a</span><sub><span style="font-style:italic">h</span>−1</sub>,..,<span style="font-style:italic">a</span><sub>1</sub>,2<span style="font-style:italic">a</span><sub>0</sub>]] (ici <span style="font-style:italic">k</span>=5,)<br>
<span style="font-weight:bold">Par exemple</span><br>
<span style="font-family:monospace">dfc(sqrt(23),20)=[4,1,3,1,8,[1,3,1,8]]</span> (ici <span style="font-style:italic">k</span>=4)<br>
</li></ul><p>
Soit le développement en fraction continue de √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> :<br>
√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>=[<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,....<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>]<br>
Soient :<br>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell">=[<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,....<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>]</td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td></tr>
</table><p>
On a les relations :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub>2</sub>=0, <span style="font-style:italic">A</span><sub>1</sub>=1, <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub>+<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−2</sub></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span><sub>2</sub>=1, <span style="font-style:italic">B</span><sub>1</sub>=0, <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub>+<span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−2</sub></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>=floor(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell">)</td></tr>
</table><p>
Puisque <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>=1/(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>) on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub>0</sub>=0, <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span><sub>0</sub>=1, <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>(<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>−1</sub>)+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span>−1</sub></td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>+1</sub></td></tr>
</table></td><td class="dcell">=(−1)<sup><span style="font-style:italic">k</span>+1</sup></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>+1</sub></td></tr>
</table></td></tr>
</table><p>
On a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−2</sub></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">+<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−2</sub></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> +<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−2</sub></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−2</sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub>=<span style="font-style:italic">n</span> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−2</sub>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub>=<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub></td></tr>
</table><p>
On a donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−2</sub><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub>−<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−2</sub>)<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">nB</span><sub><span style="font-style:italic">k</span>−1</sub><sup>2</sup>−<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub><sup>2</sup>=(−1)<sup><span style="font-style:italic">k</span>−1</sup><span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table><p>Si (<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> +√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>)/<span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> est le <span style="font-style:italic">n</span>-ième quotient du développement en 
fraction continue de √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> alors si <span style="font-style:italic">Q</span><sub><span style="font-style:italic">h</span></sub>= <span style="font-style:italic">Q</span><sub><span style="font-style:italic">h</span>−1</sub> 
(resp <span style="font-style:italic">P</span><sub><span style="font-style:italic">h</span></sub>= <span style="font-style:italic">P</span><sub><span style="font-style:italic">h</span>−1</sub>) on a <span style="font-style:italic">k</span>=2<span style="font-style:italic">h</span>−1 (resp <span style="font-style:italic">k</span>=2<span style="font-style:italic">h</span>−2).<br>
On en déduit donc la valeur <span style="font-style:italic">k</span> de la période.<br>
La plus petite solution de <span style="font-style:italic">x</span><sup>2</sup> − <span style="font-style:italic">ny</span><sup>2</sup> =1 est donnée par :<br>
<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub> + <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>−1</sub>√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> où <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">B</span><sub><span style="font-style:italic">n</span></sub> est la <span style="font-style:italic">n</span>-ième fraction convergeant
vers √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>.<br>
<span style="font-weight:bold">Remarque</span><br>
Soit <span style="font-style:italic">n</span> un entier. Si <span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">y</span><sub>0</sub> sont solutions de <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">n</span>*<span style="font-style:italic">y</span><sup>2</sup>=1 alors 
<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub> sont d’autres solutions grace à la formule :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">=(<span style="font-style:italic">x</span><sub>0</sub>+<span style="font-style:italic">y</span><sub>0</sub></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">)<sup><span style="font-style:italic">k</span></sup></td></tr>
</table><p>
En effet, par récurrence si on a <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>=(<span style="font-style:italic">x</span><sub>0</sub>+<span style="font-style:italic">y</span><sub>0</sub>√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>)<sup><span style="font-style:italic">k</span></sup> et
(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>) solution de <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">ny</span><sup>2</sup>=1 alors :<br>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>+<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span>+1</sub>√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>=(<span style="font-style:italic">x</span><sub>0</sub>+<span style="font-style:italic">y</span><sub>0</sub>√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>)*(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>) donc <br>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">x</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">ny</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub> et<br>
<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">x</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">y</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> donc <br>
<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub><sup>2</sup>=(<span style="font-style:italic">x</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">ny</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>)<sup>2</sup>=<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+<span style="font-style:italic">n</span><sup>2</sup><span style="font-style:italic">y</span><sub>0</sub><sup>2</sup><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+2<span style="font-style:italic">nx</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">y</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>=<br>
<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+(1+<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup>)(1+<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>)+2<span style="font-style:italic">nx</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">y</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>=2<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup>+1+<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+2<span style="font-style:italic">nx</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">y</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub><br>
<span style="font-style:italic">ny</span><sub><span style="font-style:italic">k</span>+1</sub><sup>2</sup>=<span style="font-style:italic">n</span>(<span style="font-style:italic">x</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">y</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>)<sup>2</sup>=<span style="font-style:italic">nx</span><sub>0</sub><sup>2</sup><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+<span style="font-style:italic">ny</span><sub>0</sub><sup>2</sup><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+2<span style="font-style:italic">nx</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">y</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>=<br>
=<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup>(1+<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>)+(1+<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup>)<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+2<span style="font-style:italic">nx</span><sub>0</sub><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">y</span><sub>0</sub><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>=2<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup>+<span style="font-style:italic">x</span><sub>0</sub><sup>2</sup>+<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><sup>2</sup><br>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub><sup>2</sup>−<span style="font-style:italic">ny</span><sub><span style="font-style:italic">k</span>+1</sub><sup>2</sup>=1</td></tr>
</table>
<h3 id="sec296" class="subsection">8.27.2  Le programme</h3>
<p>
Le programme ci dessous trouve les plus petits entiers <span style="font-style:italic">A</span>,<span style="font-style:italic">B</span> qui sont solutions 
de <span style="font-style:italic">A</span><sup>2</sup>−<span style="font-style:italic">n</span>*<span style="font-style:italic">B</span><sup>2</sup>=1 lorsque <span style="font-style:italic">n</span> est entier qui n’est pas un carré parfait.<br>
Les différentes valeurs de <span style="font-style:italic">a</span> sont le développement en fraction continue
de √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>.
<span style="font-style:italic">A</span><sub><span style="font-style:italic">p</span></sub>/<span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span></sub> sont les réduites de rang <span style="font-style:italic">p</span> (<span style="font-style:italic">A</span><sub><span style="font-style:italic">p</span></sub>/<span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span></sub>=[<span style="font-style:italic">a</span><sub>0</sub>,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>])
On a <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> qui sont tels que:<br>
√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>=[<span style="font-style:italic">a</span>−0,<span style="font-style:italic">a</span>−1,...<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>−1</sub>+<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>/(√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>+<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>)]</p><pre class="verbatim">Pell(n):={
local A,B,P,Q,R,a,sn,AA,BB,NA,NB;
if (type(n)!=DOM_INT) {return "erreur"};
if (round(sqrt(n))^2==n) {return "erreur"};
R:=0;
Q:=1;
P:=0;
sn:=floor(sqrt(n));
a:=sn;
AA:=1;A:=a;
BB:=0;B:=1;
print(a,P,Q,R,A,B);
while (A^2-n*B^2!=1) {
P:=sn-R;
Q:=(n-P^2)/Q;
a:=floor((P+sn)/Q);
R:=irem(P+sn,Q);
NA:=a*A+AA;
NB:=a*B+BB;
AA:=A;
BB:=B;
A:=NA;
B:=NB;
print(a,P,Q,R,A,B);
}
return (A,B);
}
:;
</pre><p>
On tape :<br>
<span style="font-family:monospace">Pell(13)</span><br>
On obtient :<br>
<span style="font-family:monospace">649,180</span><br>
En effet : 649<sup>2</sup>−13*180<sup>2</sup>=1
On tape :<br>
<span style="font-family:monospace">Pell(43)</span><br>
On obtient :<br>
<span style="font-family:monospace">3482,531</span><br>
En effet : 3482<sup>2</sup>−43*531<sup>2</sup>=1</p>
<hr>
<a href="casrouge007.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="casrouge009.html"><img src="next_motif.gif" alt="Next"></a>
</body>
</html>
