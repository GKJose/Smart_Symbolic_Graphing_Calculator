<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="cassim.css">
<TITLE>Le tableur</TITLE>
</HEAD>
<BODY >
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="cassim002.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc1">Chapitre 1</A>  Le tableur</H1><H2 CLASS="section"><A NAME="toc1"></A><A NAME="htoc2">1.1</A>  Généralités</H2><H3 CLASS="subsection"><A NAME="htoc3">1.1.1</A>  Pour ouvrir un niveau contenant un tableur</H3><P>
Pour avoir un tableur, il faut utiliser le menu <TT>Edit</TT>, puis <TT>Ajouter</TT>,
puis <TT>Tableur,statistiques</TT> ou le raccourci <TT>Alt+t</TT>.<BR>
On vous demande un nom, pour la sauvegarde ultérieure de ce tableur. 
C’est ce nom de variable qui servira à sauver la matrice définie par le 
tableur et c’est ce nom suivi du suffixe <TT>.tab</TT> qui sera de nom du fichier
contenant le tableur et ses formules. Par exemple, si vous donnez comme nom 
<TT>M</TT>, la variable <TT>M</TT> 
contiendra la matrice définie par le tableur 
et lorsque vous appuyez sur le bouton <TT>Save M.tab</TT>, le fichier <TT>M.tab</TT> 
sera le fichier qui contiendra le tableur avec toutes ses 
formules et que l’on pourra retrouver lors de séances ultérieures.<BR>
<B>Attention</B> 
Si vous ne donnez pas de nom, le bouton <TT>Save</TT> ne sera pas visible et il le
deviendra si vous utilisez <TT>Table-&gt;Sauver tableur comme du texte</TT> et vous 
donnez, par exemple,comme nom <TT>M</TT>.<BR>
Si le contenu du tableur change, la matrice <TT>M</TT> change sans
avoir besoin de sauver, par contre le fichier <TT>M.tab</TT> ne changera que si 
l’on sauve c’est à dire si on appuie sur <TT>Save M.tab</TT>.
On peut aussi sauver la sélection par exemple <TT>A0:C3</TT> vers une variable 
(menu <TT>Table</TT>), cette variable contiendra une matrice qui ne changera pas 
même si le tableur change.<BR>
La <TT>Configuration generale</TT> du menu <TT>Configuration</TT> permet de 
déterminer le nombre de lignes et de colonnes que l’on aura lors de 
l’ouverture du tableur. </P><H3 CLASS="subsection"><A NAME="htoc4">1.1.2</A>  Déscription d’un niveau contenant un tableur</H3><P>
Dans un niveau contenant un tableur nous avons :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
en haut la barre de menu de ce niveau :<BR>
<SPAN CLASS="textboxed"><TT>Table Edit Maths</TT></SPAN>.<BR>
On peut retrouver ces menus avec un click droit de la souris n’importe où
dans le tableur et on retrouve aussi ces menus dans le 
menu <TT>Tableur</TT> du menu général.<BR>
À coté de cette barre de menus les boutons :<BR>
<TT>eval val init 2-d 3-d</TT> ou par exemple<BR>
<TT>eval val init 2-d 3-d Save M.tab</TT>,
</LI><LI CLASS="li-itemize">une ligne composée de deux cases :
<UL CLASS="itemize"><LI CLASS="li-itemize">
la case de sélection qui permet soit de sélectionner une cellule (en 
tapant par exemple <TT>B0</TT>) ou un sous tableau (en tapant par exemple 
<TT>B0..D3</TT> ou <TT>B0:D3</TT>), ou un sous tableau avec des colonnes non 
contigües (en tapant par exemple <TT>B0..3,D</TT>), soit de savoir ce qui est 
sélectionné avec la souris. 
</LI><LI CLASS="li-itemize">une ligne de commande qui permet de modifier une cellule du tableur ou 
de savoir ce qui se trouve dans cette cellule.<BR>
<TT>Attention</TT><BR>
Il faut savoir que si le curseur est dans cette ligne de commande, lorsqu’on 
clique dans une case, c’est le nom de cette case qui va s’afficher dans cette 
ligne, sans changer la case de sélection. Pour enlever le curseur de la ligne
de commande tapez sur <TT>Echap</TT> ou <TT>Escap</TT> ou encore sur la touche 
d’effacement ⇐ qui effacera ce qui se trouve dans cette
ligne y compris le curseur.
Si le curseur n’est pas dans la ligne de commande, lorsqu’on clique dans une 
case, c’est la valeur de cette case qui va s’afficher dans cette ligne, en
mettant son nom dans la case de sélection. 
</LI></UL>
</LI><LI CLASS="li-itemize">la ligne d’état rappelant la configuration choisie : c’est aussi un 
bouton qui permet de configurer le tableur.<BR>
 On détermine la configuration soit en appuyant sur la ligne d’état soit on utilise le menu :<BR>
<TT>Edit</TT><TT>▸</TT><TT>Configuration</TT> du tableur.<BR>
On a par exemple dans la ligne d’état :<BR>
<TT>* Spreadsheet M R40C6 auto down fill</TT><BR>
cela veut dire que l’on a un tableur qui a été modifié depuis la 
dernière sauvegarde (<TT>*</TT>), de nom de variable <TT>A</TT> qui a 40 lignes
et 6 colonnes, il est réévalué automatiquement, le curseur se déplace 
vers le bas lorsqu’on vient de remplir une cellule et une matrice remplit 
plusieurs cellules.<BR>
On peut aussi avoir par exemple :<BR>
<TT>- Matrix &lt;&gt; R4C6 manual right cell</TT><BR>
cela veut dire que l’on a une matrice qui n’a pas été modifiée depuis la 
dernière sauvegarde (<TT>-</TT>), il ne lui correspond pas de nom de variable 
(<TT>&lt;&gt;</TT>), elle a 4 lignes et 6 colonnes, elle n’est réévaluée que si on 
appuie sur le bouton <TT>eval</TT>, le curseur se déplace vers la droite 
lorsqu’on vient de remplir une cellule et une matrice remplit une seule 
cellule.
</LI><LI CLASS="li-itemize">le tableur ou l’éditeur de matrice. Si on a coché <TT>Graphe</TT> dans 
la configuration du tableur, on aura aussi un écran de représentation 
graphique du tableur : cet écran se 
trouve soit en dessous du tableur si on a coché <TT>Paysage</TT>, soit à sa 
droite si on a décoché <TT>Paysage</TT>. C’est dans cet écran que 
s’afficheront toutes les commandes graphiques situées dans les cellules du 
tableur. Par exemple, on met <TT>1</TT> dans 
<TT>A0</TT>, <TT>2</TT> dans <TT>B0</TT>, <TT>=cercle(A0,B0)</TT> dans <TT>C0</TT> et 
<TT>=cercle(B0,A0)</TT> dans <TT>D0</TT>. On obtient le tracé de deux cercles et 
une modification de l’une des cases <TT>A0</TT> ou <TT>B0</TT> modifira ce tracé. 
</LI></UL><H3 CLASS="subsection"><A NAME="htoc5">1.1.3</A>  Tableur et éditeur de matrice</H3><P>
Le tableur est une feuille de calculs ayant la forme d’un tableau composé de 
lignes et de colonnes qui déterminent des cases appelées cellules. Les 
cellules contiennent des valeurs ou des commandes ou encore des formules 
qui font références aux autres cellules.<BR>
Un éditeur de matrice a aussi la forme d’un tableau composé de 
lignes et de colonnes qui déterminent des cases, mais ces cases ne peuvent 
contenir que des scalaires.<BR>
Dans le menu <TT>Edit</TT><TT>▸</TT><TT>Configuration</TT> du tableur, l’item 
<TT>Format</TT> permet d’avoir soit un tableur, soit un éditeur de matrice 
permettant d’entrer facilement des matrices quelconques ou symétriques ou 
etc...On a donc la possibilité lorsque l’on veut mettre dans le tableur une 
matrice particulière (par exemple une matrice symétrique) de choisir de le 
faire dans l’éditeur de matrice associé au tableur (on choisit par exemple 
<TT>matrice symétrique</TT> dans <TT>Format</TT>), on entre la matrice 
(les éléments symétriques sont mis automatiquement) puis, on repasse en 
mode tableur en choisissant <TT>Tableur</TT> dans <TT>Format</TT>.
</P><H4 CLASS="subsubsection">Description de l’écran du tableur</H4><P>
Le tableur est un tableau composé de colonnes désignées par 
les lettres majuscules <TT>A,B,C,...</TT> et de lignes numérotées par 
<TT>0,1,2,...</TT>.<BR>
Les cases du tableur sont appelées cellules.<BR>
Ainsi, <TT>A0</TT> désigne la première cellule du tableur.</P><H4 CLASS="subsubsection">Description de l’éditeur de matrice</H4><P>
L’éditeur de matrice est un tableau composé de lignes et de colonnes 
numérotées par <TT>0,1,2,...</TT><BR>
Les cases de l’éditeur de matrice sont les éléments de la matrice.<BR>
Si on sauve la matrice en lui donnant comme nom <TT>M</TT>, <TT>M[0,1]</TT>
désigne la case située dans la ligne de numéro <TT>0</TT> et dans la colonne
de numéro <TT>1</TT>.
</P><H3 CLASS="subsection"><A NAME="htoc6">1.1.4</A>  Principe et configuration du tableur</H3><P>
Le menu <TT>Edit</TT><TT>▸</TT><TT>Configuration</TT> du tableur permet de
configurer le tableur (tableur se traduit en anglais par <TT>Spreadsheet</TT>).<BR>
Le tableur est une feuille de calculs ayant la forme d’un tableau composé de 
lignes et de colonnes. Lorsqu’on a choisit <TT>Recalculer automatiquement</TT> 
dans le menu <TT>Edit</TT><TT>▸</TT><TT>Configuration</TT> du tableur, 
les cases ou cellules sont mises à jour automatiquement lorsque l’on modifie 
une des cases et sinon il faut utiliser le bouton <TT>eval</TT> ou utiliser dans
le menu <TT>Edit</TT><TT>▸</TT><TT>Configuration</TT> du tableur, la commande 
<TT>Evaluer le tableur</TT> (à exécution directe) ou encore utiliser le 
raccourci clavier en appuyant sur <TT>F9</TT>.<BR>
L’item <TT>Format</TT> de ce menu configuration permet d’avoir soit un tableur, 
soit un éditeur de matrice permettant d’entrer facilement des matrices
quelconques ou symétriques ou etc..<BR>
On peut préciser le nombre de lignes et de colonnes avec lesquelles on veut 
travailler : par exemple pour entrer une matrice symétrique il faut avoir le 
même nombre de lignes et de colonnes, on change ce nombre avec les items 
<TT>Changer le nombre de lignes</TT> et <TT>Changer le nombre de colonnes</TT> dans 
le menu <TT>Edit</TT><TT>▸</TT><TT> Configuration</TT> du tableur.<BR>
On pourra bien sûr modifier ces nombres au cours du travail, par 
exemple en utilisant le menu :<BR>
<TT>Edit</TT><TT>▸</TT><TT>Configuration</TT><TT>▸</TT><TT>Ajouter/effacer</TT> du tableur ou en utilisant la <TT>case de sélection</TT> (si on met <TT>G50</TT>
dans cette case, il y aura alors création d’un nombre suffisant de
lignes et de colonnes pour pouvoir sélectionner <TT>G50</TT>)
Toutes les fonctions (même graphiques) de <TT>Xcas</TT> sont utilisables dans le
tableur.<BR>
Le bouton <TT>STOP</TT> permet d’interrompre un calcul trop long.
</P><H3 CLASS="subsection"><A NAME="htoc7">1.1.5</A>  La <TT>case de sélection</TT></H3><P>
La <TT>case de sélection</TT> est la case située en dessous du menu 
<TT>Table</TT>.<BR>
La <TT>case de sélection</TT> est une case interactive :<BR>
- elle permet de connaitre le nom de la (ou des) cellule(s) sélectionnée(s)
avec la souris (si on sélectionne <TT>A3</TT>, <TT>A3</TT> se note automatiquement dans cette case, si on sélectionne <TT>A2,A3,A4,B2,B3,B4</TT>, <TT>A2:B4</TT> se note automatiquement dans cette case),<BR>
- elle permet aussi d’aller directement sur une cellule dont on spécifie le 
nom : en effet lorsqu’on appuie sur cette case le curseur apparait, et on peut 
remplacer, par exemple, <TT>A3</TT> par <TT>A30</TT> : les lignes (et les colonnes) 
nécessaires sont créées et la cellule <TT>A30</TT> se trouve 
sélectionnée.<BR>
- elle permet aussi de sélectionner une ou plusieurs colonnes, par exemple,
en tapant dans cette case <TT>A0:C9</TT> ou <TT>A0..C9</TT> cela sélectionnera 
les 10 premières lignes des colonnes <TT>A,B</TT> et <TT>C</TT> ou encore
en tapant dans cette case <TT>A0..9,C</TT> cela sélectionnera les 10 
premières lignes des colonnes <TT>A</TT> et <TT>C</TT>. Grâce à cette case 
de sélection on peut donc sélectionner des colonnes non contigües, ce que 
l’on ne peut pas faire avec la souris.
</P><H3 CLASS="subsection"><A NAME="htoc8">1.1.6</A>  Les différents boutons d’un tableur</H3><P><A NAME="sec:sauver"></A>
Les différents boutons du tableur sont :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>eval</TT> pour évaluer le tableur lorsqu’on n’est pas en mode 
automatique. On peut aussi utiliser le menu, 
<TT>Edit</TT><TT>▸</TT><TT>Configuration</TT><TT>▸</TT><TT>Recalculer automatiquement</TT>. Cela permet de passer en mode automatique de façon à ce que
le tableur soit évalué après chacune de ses modifications,
</LI><LI CLASS="li-itemize"><TT>val</TT> pour avoir la valeur de la cellule dans la ligne de commande
à la place de la formule,
</LI><LI CLASS="li-itemize"><TT>init</TT> pour avoir, par exemple, une variable qui compte le nombre 
d’évaluation du tableur : on met par exemple :
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>j:=0</TT> dans la case <TT>Init sheet</TT> de la configuration du tableur et
</LI><LI CLASS="li-itemize"><TT>=(j:=j+1)</TT> dans une cellule du tableur.<BR>
À chaque évaluation la cellule contiendra <TT>1,2...</TT>. En appuyant sur 
<TT>init</TT> on réinitialise la valeur de <TT>j</TT> et on remet la cellule à 
<TT>1</TT> 
</LI></UL>
</LI><LI CLASS="li-itemize"><TT>Save</TT> si vous n’avez pas donné de nom à l’ouverture, ce bouton 
n’existe pas. pour le créer, utiliser 
<TT>Table-&gt;Sauver tableur comme du texte</TT>. Si vous avez donné un nom à 
l’ouverture par exemple <TT>toto</TT>, le bouton <TT>Save</TT> 
sauve alors à la fois le tableur et ses formules dans le fichier 
<TT>toto.tab</TT> (d’extension <TT>.tab</TT>) et les valeurs dans la matrice 
<TT>toto</TT>. La matrice <TT>toto</TT> pourra alors être reutilisée et le 
fichier <TT>toto.tab</TT> pourra être inséré dans un tableur lors de 
séances ultérieures.
</LI><LI CLASS="li-itemize"><TT>2-d 3-d</TT> ouvre un écran de gépmétrie 2-d ou 3-d pour que l’on 
puisse voir les commandes graphiques du tableur
</LI></UL><H2 CLASS="section"><A NAME="toc2"></A><A NAME="htoc9">1.2</A>  La barre de menu d’un tableur</H2><H3 CLASS="subsection"><A NAME="htoc10">1.2.1</A>  Le menu <TT>Table</TT> d’un tableur</H3><P>
Le menu <TT>Fich</TT> est composé de :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si vous avez donné un nom à l’ouverture, <TT>Sauver</TT> est identique 
au bouton <TT>Save</TT> et sauve le tableur dans un fichier d’extension <TT>.tab</TT>. L’extension <TT>.tab</TT> est rajoutée 
automatiquement. Si vous n’avez pas donné de nom à l’ouverture, 
<TT>Sauver</TT> vous en 
demande un, par exemple <TT>toto</TT> et <TT>Sauver</TT> crée le bouton <TT>Save</TT> et il sauve à la 
fois le tableur et ses formules dans le fichier <TT>toto.tab</TT> (d’extension 
<TT>.tab</TT>) et les valeurs dans la matrice <TT>toto</TT>. La matrice <TT>toto</TT> 
pourra alors être reutilisée et le fichier <TT>toto.tab</TT> pourra être inserer dans un tableur lors de séances ultérieures.
</LI><LI CLASS="li-itemize"><TT>Sauver comme</TT> sauve le tableur sous un nom (d’extension
<TT>.tab</TT>) différent de celui noté à coté du bouton <TT>Save</TT>,
</LI><LI CLASS="li-itemize"><TT>Sauver selection vers variable</TT> pour stocker dans une variable
la matrice mise en surbrillance et pouvoir ainsi utiliser cette variable 
ailleurs (calcul formel par exemple). Par exemple si le nom de la variable est
<TT>a</TT>, <TT>a[0,2]</TT> donnera dans une ligne de commandes la valeur située 
à la ligne 0 et à la colonne 2 de la sous-matrice selectionnée,
</LI><LI CLASS="li-itemize"><TT>Inserer</TT> pour mettre à partir de la cellule mise en surbrillance 
un tableur sauvé précédemment,
</LI><LI CLASS="li-itemize"><TT>Nom de variable</TT> pour donner un nom de variable au tableur 
différent du nom de fichier sans son suffixe <TT>.tab</TT>. Ce nom est noté 
dans la ligne d’état située en dessous de la ligne de commande. Par exemple
si le nom de la variable est <TT>M</TT>, <TT>M[0,1]</TT> renvera la valeur située 
en <TT>B0</TT>,
</LI><LI CLASS="li-itemize"><TT>Imprimer</TT> pour imprimer le tableur. Vous pouvez prévisualiser 
avant d’imprimer.
</LI></UL><H3 CLASS="subsection"><A NAME="htoc11">1.2.2</A>  Le menu <TT>Edit</TT> d’un tableur</H3><P>
On trouve dans ce menu :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Evaluer le tableur F9</TT> pour recalculer le tableur lorsqu’on n’est 
pas en mode automatique : pour que le recalcul soit automatique, il faut passer
en mode automatique avec le menu <TT>Edit</TT><TT>▸</TT><TT>Configuration</TT><TT>▸</TT><TT>Recalculer automatiquement</TT>. Le raccourci clavier de cet item
<TT>Evaluer le tableur</TT> est <TT>F9</TT> et il a le même effet que le bouton 
<TT>eval</TT> : cela permet 
de recalculer les cellules du tableur après une modification.
</LI><LI CLASS="li-itemize"><TT>Copier la cellule</TT> (en anglais <TT>Cell copy</TT>) permet de recopier 
une cellule dans une autre cellule : on sélectionne à la souris la cellule 
que l’on veut recopier. On clique ensuite sur <TT>Copier la cellule</TT> puis, on 
clique sur la cellule à remplir et on clique sur le bouton <TT>coller</TT> du 
bandeau général ou on utillise l’item <TT>Coller</TT> ci-après.
</LI><LI CLASS="li-itemize"><TT>Coller</TT> sert à copier ce qui a été auparavant sélectionné.
</LI><LI CLASS="li-itemize"><TT>Configuration</TT> contient les items suivants :
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Format</TT> permet de choisir d’avoir un tableur ou un éditeur de 
matrice permettant d’éditer facilement des matrices symétriques, 
antisymétriques, hermitiennes, antihermitiennes,quelconques,
</LI><LI CLASS="li-itemize"><TT>Changer le nombre de lignes</TT> permet de spécifier le nombre
de lignes du tableur ou de la matrice,
</LI><LI CLASS="li-itemize"><TT>Changer le nombre de colonnes</TT> permet de spécifier le nombre
de colonnes du tableur ou de la matrice,
</LI><LI CLASS="li-itemize"><TT>Déplacer -&gt;</TT> la surbrillance ira automatiquement sur la cellule 
située à droite de la cellule que l’on vient de remplir,
</LI><LI CLASS="li-itemize"><TT>Déplacer vers le bas</TT> : la surbrillance ira automatiquement sur la
cellule située en dessous, de la cellule que l’on vient de remplir,
</LI><LI CLASS="li-itemize"><TT>Recalculer automatiquement</TT> pour que le tableur soit recalculé
automatiquement après chaque modification,
</LI><LI CLASS="li-itemize"><TT>Ne pas recalculer automatiquement</TT> pour que le tableur ne soit 
pas recalculé automatiquement : le recalcul ne se fait alors que si on appuie
sur le bouton <TT>eval</TT>,
</LI><LI CLASS="li-itemize"><TT>Distribuer une matrice sur plusieurs cellules</TT> pour remplir 
plusieurs cellules avec une matrice : par exemple si on sélectionne <TT>A0</TT>
et que l’on tape dans la ligne de commandes du tableur <TT>[1,2,3]</TT>, cela 
remplira 3 cellules, en mettant 1 dans <TT>A0</TT>, 2 dans <TT>B0</TT> et 3 dans 
<TT>C0</TT>, par contre si on tape dans la ligne de commandes du tableur
<TT>=[1,2,3]</TT> cela mettra [1,2,3] dans <TT>A0</TT>.
</LI><LI CLASS="li-itemize"><TT>Conserver une matrice dans une seule cellule</TT> permet de remplir une
cellule avec une matrice : par exemple si on sélectionne <TT>A0</TT>
et que l’on tape dans la ligne de commandes du tableur <TT>[1,2,3]</TT> ou 
<TT>=[1,2,3]</TT>, cela mettra [1,2,3] dans <TT>A0</TT>.
</LI></UL>
</LI><LI CLASS="li-itemize"><TT>Trier</TT> permet de trier plusieurs lignes (resp colonnes) selon 
l’ordre croissant (resp décroissant) d’une colonne (resp ligne).<BR>
Par exemple on a dans les colonnes <TT>A</TT> et <TT>B</TT> :<BR>
<TT>[[3,9],[5,12],[2,14],[4,8],[1,11]]</TT>
qui represente le numéro d’une copie et sa note.<BR>
On peut alors :<BR>
- soit trier ce tableau pour ordonner le numéro des copies par ordre
croissant (c’est à dire par rapport à la colonne <TT>A</TT>) on demande
alors : <TT>Col/crois</TT> puis on marque <TT>A</TT>. 
On obtient alors le tableau :<BR>
<TT>[[1,11],[2,14],[3,9],[4,8],[5,12]]</TT><BR>
- soit trier ce tableau pour ordonner les notes des copies par ordre
décroissant (c’est à dire par rapport à la colonne <TT>B</TT>) on demande
alors : <TT>Col/décrois</TT> puis on marque <TT>B</TT>.
On obtient alors le tableau :<BR>
<TT>[[2,14],[5,12],[1,11],[3,9],[4,8]]</TT><BR>
<B>Attention</B><BR>
Pour trier une colonne dans une autre colonne du tableur,
on ne peut pas le faire directement, car 
quand on écrit une formule dans le tableur, elle ne peut remplir que la case 
courante (sinon cela poserait trop de problèmes pour les dépendances des 
cellules).<BR>
Le remplissage par une matrice n’est possible qu’en évaluation directe sans 
dépendances.<BR>
Si on veut trier la colonne <TT>A</TT> dans <TT>B</TT>, on crée une cellule
par exemple <TT>C0</TT> avec <TT>=sort(A0:A10)</TT>, <TT>C0</TT> contient alors la 
liste <TT>A0:A10</TT> triée.<BR>
Puis dans <TT>B0</TT> on écrit <TT>=($C$0)[Row()]</TT> et on recopie <TT>B0</TT> 
vers le bas : on obtient alors la recopie de la liste <TT>C0</TT> dans <TT>B</TT>
puisque <TT>Row()</TT> désigne l’indice de la cellule dans laquelle la formule 
est recopiée, indice qui est aussi l’indice des éléments de la liste 
<TT>C0</TT>.</LI><LI CLASS="li-itemize"><TT>Remplir</TT> contient les items suivants :
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Remplir sélection de 0</TT> remplit la sélection par des zéros,
</LI><LI CLASS="li-itemize"><TT>Copier vers la droite</TT> recopie sur toutes les cellules situées 
à droite de la cellule mise en surbrillance, le contenu (ou la formule) qui 
s’y trouve, 
</LI><LI CLASS="li-itemize"><TT>Copier vers le bas</TT> recopie sur toutes les cellules situées 
en dessos de la cellule mise en surbrillance, le contenu (ou la formule) qui 
s’y trouve,
</LI><LI CLASS="li-itemize"><TT>Remplir la sélection avec la cellule enfoncée</TT>, recopie le 
contenu (ou la formule) de la cellule qui a débuté la 
sélection faite avec la souris de la zone rectangulaire dans laquelle on veut
faire une recopie (la cellule que l’on copie est donc un des quatre coins de la
zone rectangulaire),
</LI><LI CLASS="li-itemize"><TT>Remplir sélection de 0</TT> remplit la sélection avec des zéros,
</LI><LI CLASS="li-itemize"><TT>Remplir le tableur de 0</TT> remplit le tableur avec des zéros,
</LI><LI CLASS="li-itemize"><TT>tablefunc</TT> permet d’avoir une table numérique des valeurs d’une 
expression (voir <A HREF="#sec:tablefunc">1.6.1</A>),
</LI><LI CLASS="li-itemize"><TT>tableseq</TT> permet d’avoir les valeurs numériques des termes
d’une suite récurrente (voir <A HREF="#sec:tableseq">1.6.2</A>),
</LI></UL>
</LI><LI CLASS="li-itemize"><TT>Ajouter/effacer</TT> contient les items suivants :
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Inserer ligne</TT> rajoute une ligne juste avant la ligne où se trouve
la cellule mise en surbrillance,
</LI><LI CLASS="li-itemize"><TT>Ligne+ en fin</TT> rajoute une ligne à la fin du tableur,
</LI><LI CLASS="li-itemize"><TT>Inserer colonne</TT> rajoute une colonne juste avant la colonne où se 
trouve la cellule mise en surbrillance,
</LI><LI CLASS="li-itemize"><TT>Col+ en fin</TT> rajoute une colonne à la fin de tableur,
</LI><LI CLASS="li-itemize"><TT>Effacer ligne courante</TT> supprime la ligne où se trouve la cellule
mise en surbrillance,
</LI><LI CLASS="li-itemize"><TT>Effacer selection lignes</TT> efface le contenu des lignes 
sélectionnées,
</LI><LI CLASS="li-itemize"><TT>Effacer col courante</TT> supprime la colonne où se trouve la cellule 
mise en surbrillance,
</LI><LI CLASS="li-itemize"><TT>Effacer sélection cols</TT> efface le contenu des colonnes 
sélectionnées,
</LI></UL></LI><LI CLASS="li-itemize"><TT>Col+grande</TT> agrandit ou diminue la taille des colonnes,
</LI><LI CLASS="li-itemize"><TT>Col+petite</TT> diminue la taille des colonnes,
</LI></UL><H3 CLASS="subsection"><A NAME="htoc12">1.2.3</A>  Le menu <TT>Maths</TT> d’un tableur</H3><H4 CLASS="subsubsection">Le menu <TT>Maths</TT><TT>▸</TT><TT>stats 1-d</TT> d’un tableur</H4><P>
Le menu <TT>Statistics</TT> ouvre pour chaque item une boite de dialogue où l’on
peut préciser : la sélection, la cellule cible (c’est dans cette cellule 
que s’inscrira la commande choisie), si comme argument de la commande
choisie, on doit considérer les lignes ou les colonnes de la sélection et 
si on doit mettre les valeurs ou les références de la sélection .<BR>
Voici les différents items du menu 
<TT>Maths</TT><TT>▸</TT><TT>stats 1-d</TT> :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>camembert</TT><BR>
On peut faire plusieurs camemberts sur le même graphique en sélectionnant 
toute une plage.<BR>
 <B>Exemple pour faire deux camemberts</B><BR>
On sélectionne la plage <TT>A0:C3</TT>.<BR>
On met 
<UL CLASS="itemize"><LI CLASS="li-itemize">
dans <TT>A0</TT> n’importe quoi sauf une chaine vide par exemple 2
</LI><LI CLASS="li-itemize">dans <TT>A1,A2,A3</TT> : <TT>"A","B","C"</TT><BR>
</LI><LI CLASS="li-itemize">dans <TT>B0</TT> le titre du premier camembert par exemple <TT>"xyz"</TT>,<BR>
</LI><LI CLASS="li-itemize">dans <TT>B1,B2,B3</TT> : les valeurs du premier camembert par exemple 
<TT>2,5,7</TT><BR>
</LI><LI CLASS="li-itemize">dans <TT>C0</TT> le titre du second camembert par exemple <TT>"xyz"</TT>,<BR>
</LI><LI CLASS="li-itemize">dans <TT>C1,C2,C3</TT> : les valeurs du second camembert par exemple 
<TT>5,6,7</TT>
</LI></UL>
Puis on met dans <TT>D0</TT> : <TT>=camembert(matrix(4,3,(A0):(C3)))</TT> à l’aide 
du menu <TT>Math</TT><TT>▸</TT><TT>Proba_stats</TT><TT>▸</TT><TT>1-d</TT><TT>▸</TT><TT>camembert</TT>.<BR>
On obtient :
<DIV CLASS="center"><SPAN CLASS="textboxed"><IMG SRC="cassim001.png"></SPAN></DIV>
</LI><LI CLASS="li-itemize"><TT>batons</TT><BR>
On peut faire plusieurs diagrammes en batons sur le même graphique en 
sélectionnant toute une plage.<BR>
 <B>Exemple pour faire deux diagrammes en batons</B><BR>
Avec l’exemple ci-dessus, on met dans <TT>D0</TT> : 
<TT>=diagramme_batons(matrix(4,3,(A0):(C3)))</TT> à l’aide 
du menu <TT>Math</TT><TT>▸</TT><TT>Proba_stats</TT><TT>▸</TT><TT>1-d</TT><TT>▸</TT><TT>batons</TT>.<BR>
On obtient :
<DIV CLASS="center"><SPAN CLASS="textboxed"><IMG SRC="cassim002.png"></SPAN></DIV></LI><LI CLASS="li-itemize"><TT>plotlist</TT><BR>
Si <TT>plotlist</TT> a comme argument une liste <TT>L=[y1,...,yn]</TT>, cela trace 
la ligne reliant les points d’abscisse <TT>1,...,n</TT> et d’ordonnée 
<TT>L=[y1,...,yn]</TT> et si <TT>plotlist</TT> a comme argument une matrice 
<TT>M=[[x1,y1],...,[xn,yn]]</TT>, cela trace la ligne reliant les points de 
coordonnées <TT>xn,yn</TT>.<BR>
<B>Exemple</B>
On met dans <TT>A</TT> : <TT>1,2,5,7,9</TT> et dans <TT>B</TT> : <TT>3,5,6,9,4</TT>
On tape dans <TT>C0</TT> : <TT>=plotlist((A0):(B4),’affichage’=1)</TT><BR>
On tape dans <TT>C1</TT> ou on utilise le menu 
<TT>Math</TT><TT>▸</TT><TT>Proba_stats</TT><TT>▸</TT><TT>1-d</TT><TT>▸</TT><TT>plotlist</TT> avec pour plage <TT>A0:B4</TT> et pour cellule cible <TT>C1</TT> : 
<TT>=plotlist(matrix(5,2,(A0):(B4)))</TT><BR>
<B>Attention !</B>
Lorsqu’on met <TT>=plotlist((A0):(B4))</TT> la plage <TT>(A0):(B4)</TT> est applatie 
en une liste (ici la liste <TT>1,3,2,5,4,6,7,9,9,4</TT>)
On obtient en rouge la ligne correspondant à la liste et en noir celle
correspondant à la matrice :
<DIV CLASS="center"><SPAN CLASS="textboxed"><IMG SRC="cassim003.png"></SPAN></DIV></LI><LI CLASS="li-itemize"><TT>Boite à moustaches</TT> (en anglais <TT>Boxwhiskers</TT>)<A NAME="@default0"></A><A NAME="@default1"></A><BR>
<TT>Boite à moustaches</TT> permet de dessiner, dans 
l’écran graphique associé au tableur, les 
boites à moustaches des colonnes (ou des lignes si <TT>Lignes</TT> est 
cochée) des données qui ont été sélectionnées. C’est dans la 
cellule cible que s’inscrit la commande <TT>moustache</TT> avec comme argument
les valeurs ou les références de la plage sélectionnée selon que 
l’on coche ou non <TT>valeur</TT>.</LI><LI CLASS="li-itemize"><TT>Classes (donnees ou donnees/eff)</TT><BR>
<TT>Classes</TT> permet de définir des classes : on sélectionne une 
colonne du tableur contenant la série que l’on veut regrouper en classes (ou 
si on a des effectifs, on sélectionne deux colonnes du tableur representant 
les données et leurs effectifs) puis, on sélectionne <TT>Classes</TT> dans le 
menu <TT>Statistiques</TT> sous-menu <TT>1-d</TT> : il faut vérifier la valeur 
minimum de la classe, la largeur des classes (ces deux cases sont déjà 
remplies avec les valeurs spécifiées dans la configuration du graphique 
(bouton rouge <TT>geo</TT>) et aussi la cellule cible qui est la 
première cellule à partir de laquelle on écrira les classes sur deux 
colonnes,
Les intervalles des classes s’inscrivent dans la colonne de la cellule cible 
et commencent par <TT>classe_min</TT> et la longueur des
intervalles est égale à <TT>classe_size</TT> : ces valeurs peuvent être 
spécifiées dans la configuration du graphique (bouton rouge <TT>geo</TT>). 
La colonne suivante contient les effectifs des classes obtenues dans la 
précédente colonne,
</LI><LI CLASS="li-itemize"><TT>Histogramme (intervalles/eff)</TT> (en anglais <TT>Histogram</TT>)<BR>
<TT>Histogramme</TT> permet de dessiner dans l’écran 
graphique associé au tableur l’histogramme de deux colonnes sélectionnées
representant les intervalles de données et leurs effectifs, et
inscrit la commande <TT>histogram</TT> correspondante dans la cellule cible.
</LI></UL><H4 CLASS="subsubsection">Le menu <TT>Maths</TT><TT>▸</TT><TT>stats 2-d</TT> d’un tableur</H4><P>
Le menu <TT>Maths</TT><TT>▸</TT><TT>stats 2-d</TT> contient les items suivants :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Scatterplot</TT> permet de tracer sur l’écran graphique les points 
d’abscisse la première colonne sélectionnée et d’ordonnée les autres 
colonnes sélectionnées si <TT>lignes</TT> n’est pas coché ou de tracer sur 
l’écran graphique les points d’abscisse la première ligne sélectionnée 
et d’ordonnée les autres lignes sélectionnées si <TT>lignes</TT> est 
coché. Les couleurs seront différentes pour les points
dont les ordonnées sont dans des colonnes (resp lignes) différentes.<BR>
Par exemple,
<UL CLASS="itemize"><LI CLASS="li-itemize">
si <TT>lines</TT> n’est pas coché, on remplit :<BR>
<TT>A0,A1,A2,A3</TT> avec <TT>1,2,3,4</TT> et<BR>
<TT>B0,B1,B2,B3</TT> avec <TT>1,4,9,16</TT>, puis<BR>
on sélectionne la matrice <TT>A0:B3</TT> et on ouvre le menu 
<TT>Statistiques 2-d Scatterplot</TT>.
</LI><LI CLASS="li-itemize">si <TT>lines</TT> est coché, on remplit :<BR>
<TT>A0,B0,C0,D0</TT> avec <TT>1,2,3,4</TT> et<BR>
<TT>A1,B1,C1,D1</TT> avec <TT>1,4,9,16</TT>, puis<BR>
on sélectionne la matrice <TT>A0:D1</TT> et on ouvre le menu 
<TT>Statistiques 2-d Scatterplot</TT>.
</LI></UL>
Une boite de dialogue s’ouvre où la plage sélectionnée est marquée 
(si vous n’avez rien sélectionné il faut remplir cette case) puis,
il faut donner le nom de la <TT>cellule cible</TT> là où la commande 
<TT>scatterplot</TT> va s’inscrire. Les valeurs ou les références de la plage 
sélectionnée seront en argument de la commande <TT>scatterplot</TT> selon que 
l’on coche ou non <TT>valeur</TT>.<BR>
Supposons que <TT>lignes</TT> n’est pas coché.
<UL CLASS="itemize"><LI CLASS="li-itemize">
Si <TT>valeur</TT> n’est pas coché dans la boite de dialogue et si la 
cellule cible est <TT>C0</TT>, dans la ligne de 
commande du tableur et dans <TT>C0</TT> il s’inscrit alors :<BR>
<TT>=scatterplot(matrix(4,2,(A0):(B3)))</TT>
</LI><LI CLASS="li-itemize">Si <TT>valeur</TT> est coché dans la
boite de dialogue et si la cellule cible est <TT>C1</TT>, dans la ligne de 
commande du tableur et dans <TT>C1</TT> il s’inscrit alors :<BR>
<TT>=scatterplot([[1,1],[2,4],[3,9],[4,16]])</TT>.
</LI></UL>
Ainsi une modification des 
valeurs de <TT>A0:B3</TT> modifira, lors d’une réévaluation du tableur,le 
graphique commandé par la case <TT>C0</TT> 
mais ne modifira pas le graphique commandé par la case <TT>C1</TT>. Autrement 
dit, si vous ne travaillez pas en valeur, c’est à dire avec des 
références, à chaque modification, on aura
une modification du graphique et si vous travailler en valeur à chaque 
modification il faudra inscrire dans une nouvelle cellule cible la commande 
<TT>scatterplot</TT> et on aura alors plusieurs graphiques correspondant chacun 
aux commandes <TT>scatterplot</TT> des cellules cibles.<BR>
<TT>Attention</TT><BR>
Lorsqu’on sélectionne une plage avec la souris on ne peut sélectionner que 
des colonnes contigües. On peut néanmoins remplir la plage de sélection
de la boite de dialogue avec des colonnes non contigües par exemple :<BR>
<TT>C0..5,A,D</TT> pour dire, si <TT>lines</TT> n’est pas coché, que les points que
l’on veut représenter ont pour abscisses la colonnes <TT>C</TT> et pour 
ordonnées la colonne <TT>A</TT> d’une part et pour abscisses la colonnes <TT>C</TT>
et pour ordonnées la colonne <TT>D</TT> d’autre part.
Mais dans ce cas <TT>scatterplot</TT> s’affichera comme si 
<TT>valeur</TT> etait coché (même si ce n’est pas le cas). </LI><LI CLASS="li-itemize"><TT>Polygonplot</TT> permet de tracer sur l’écran graphique les points 
d’abscisse la première colonne sélectionnée et d’ordonnée les autres 
colonnes sélectionnées, en reliant entre eux les points dont les 
ordonnées sont dans une même colonne.<BR>
La même boite de dialogue que pour <TT>scatterplot</TT> s’ouvre. Dans la ligne
de commande du tableur il s’inscrit alors, par exemple, dans <TT>D5</TT> :<BR>
<TT>=polygonplot(matrix(3,3,A0:C2))</TT> si ni <TT>lignes</TT> ni <TT>valeur</TT> ne 
sont cochés, si la cellule cible est <TT>D5</TT> et si la plage selectionnée
est <TT>A0:C2</TT>.
</LI></UL><H2 CLASS="section"><A NAME="toc3"></A><A NAME="htoc13">1.3</A>  Pour remplir le tableur</H2><H3 CLASS="subsection"><A NAME="htoc14">1.3.1</A>  Comment remplir une cellule</H3><P>
Dans une cellule on peut mettre :<BR>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
une chaine de caractère, ou une expression
numérique ou formelle : pour cela il suffit de sélectionner la cellule 
à remplir et de taper dans la ligne de commande ce que l’on veut mettre 
dans la cellule, puis de valider avec <TT>enter</TT>,
</LI><LI CLASS="li-itemize">une formule faisant référence aux autres cellules, dans ce cas il 
faut faire précéder la formule du signe <TT>=</TT> (voir la section 
<A HREF="#sec:references">1.3.3</A> références absolues et relatives).<BR>
<B>Attention</B><BR>
1/ Si le curseur ne se trouve pas dans la ligne de commande, lorsqu’on clique 
sur une cellule, la ligne de commande s’efface et le contenu de la cellule
(valeur ou formule) s’affiche dans la ligne de commande.<BR>
2/ Si le curseur se trouve dans la ligne de commande, il faut que 
la ligne de commande soit vide, pour que, lorsqu’on clique sur une cellule
son contenu s’affiche dans la ligne de commande.<BR>
3/ Si le curseur se trouve dans la ligne de commande, et que celle-ci contient
quelque chose (par exemple <TT>=</TT>), alors lorsqu’on clique sur une cellule
c’est son nom qui s’affiche dans la ligne de commande (ce qui facilite
l’édition d’une formule).<BR>
4/ On enlève le curseur de la ligne de commande avec <TT>Esc</TT> ou <TT>Echap</TT>.<BR>
Ainsi, si la ligne de commande est vide et si, par exemple, on clique sur 
<TT>A1</TT> (qui contient <TT>3</TT>) alors le contenu de <TT>A1</TT> (<TT>3</TT>) 
s’affiche dans la ligne de commande :<BR>
- on peut cliquer dans une autre cellule et alors ligne de commande s’efface 
et son contenu s’affiche dans la ligne de commande.<BR>
- on peut cliquer dans la ligne de commande, taper quelque chose (par exemple 
<TT>+</TT>), puis cliquer sur une autre cellule (par exemple <TT>A2</TT>) et alors 
le nom de la cellule <TT>A2</TT> apparaità la suite du contenu précédent 
(<TT>3+</TT>).<BR>
Donc quand on édite le contenu d’une case, si on clique dans le tableur
alors, le nom ou la plage des noms selectionnés, s’affichent dans la
ligne de commande.<BR>
<B>Exemple</B><BR>
On veut remplir la case <TT>A1</TT> avec la formule <TT>1+A2</TT> :<BR>
- on efface la ligne de commande,<BR>
- on clique sur <TT>A1</TT>,<BR>
- on clique sur la ligne de commande et on tape <TT>=1+</TT>,<BR>
- on clique sur la cellule <TT>A0</TT> puis, <TT>Enter</TT>.<BR>
Cela marque <TT>1+A0</TT> dans la cellule <TT>A1</TT>.<BR>
Pour annuler une modification en mode édition, il n’est donc pas possible de
simplement cliquer sur une autre cellule du tableur puisque cela recopierait 
le nom de cette autre cellule.
En ligne de commande, c’est la touche <TT>Esc</TT> qui annule l’édition.
</LI><LI CLASS="li-itemize">une liste ou une matrice à condition de faire précéder la liste ou la matrice du signe <TT>=</TT> car, si on ne met pas le signe <TT>=</TT> cela aura pour effet de remplir plusieurs cellules (voir ci-dessous).<BR>
On peut remplir d’un seul coup plusieurs cellules à partie d’une cellule
lorsque l’on met dans cette cellule une liste ou une matrice.<BR>
Par exemple :<BR>
Dans <TT>A0</TT> on met : <TT>[1,2,3]</TT>, cela a pour effet de remplir 
<TT>A0</TT> avec <TT>1</TT>, <TT>B0</TT> avec <TT>2</TT> et <TT>C0</TT> avec <TT>3</TT>.<BR>
Dans <TT>A0</TT> on met : <TT>[[1,2],[3,4]]</TT>, cela a pour effet de
remplir <TT>A0</TT> avec <TT>1</TT>, <TT>B0</TT> avec <TT>2</TT>, <TT>A1</TT> avec <TT>3</TT> 
et <TT>B1</TT> avec <TT>4</TT>.<BR>
<B>Attention</B><BR>
Le remplissage de plusieurs cellules à l’aide d’une matrice ou d’une liste 
n’est possible qu’en évaluation directe sans dépendance.
Par exemple :<BR>
On ne peut pas mettre <TT>[A0,B0]</TT> dans <TT>C0</TT>, mais on peut mettre 
<TT>=[A0,B0]</TT> dans <TT>C0</TT>.
Le signe <TT>=</TT> est necessaire pour remplir <B>une seule</B> cellule avec
une liste ou une matrice.<BR>
<B>Exemple</B><BR>
 Pour mettre une liste ou une matrice dans une case il 
faut mettre le signe <TT>=</TT> devant la liste ou la matrice.<BR>
On tape dans la case <TT>A0</TT> :<BR>
<TT>=[[1,2],[3,4]]</TT><BR>
On obtient dans la case <TT>A0</TT> :<BR>
<TT>[[1,2],[3,4]]</TT><BR>
Si l’on ne met pas le signe égal on peut remplir d’un seul coup plusieurs 
cases du tableur par les éléments de la liste ou de la matrice à 
condition que la formule mise ne fasse pas référence aux autres cellules.<BR>
On tape dans la case <TT>A0</TT>:<BR>
<TT>[[1,2],[3,4]]</TT><BR>
On obtient :<BR>
<TT>A0=1</TT>, <TT>B0=2</TT>, <TT>A1=3</TT>, <TT>B1=4</TT><BR>
<B>Autre exemple</B><BR>
Dans <TT>A0</TT> je tape :<BR>
<TT>ranm(2,3,4)</TT><BR>
Je remplis alors d’un seul coup les 6 cases : <TT>A0,B0,C0,A1,B1,C1</TT> avec 
les éléments de la matrice <TT>[[1,3,1],[2,1,2]]</TT> (en effet 
<TT>ranm(2,3,4)</TT> renvoie une matrice de 2 lignes et 3 colonnes 
d’entiers pris au hasard de façon équirépartie dans l’ensemble des 4 
nombres <TT>0,1,2,3</TT>.<BR>
Cette matrice est définie une fois pour toute car la formule 
<TT>ranm(2,3,4)</TT> est évaluée puis oubliée.<BR>
Dans <TT>A0</TT> je tape :<BR>
<TT>=ranm(2,3,4)</TT><BR>
Cette fois, seule la cellule <TT>A0</TT> est remplie avec la matrice :<BR>
<TT>[[1,2,3],[3,2,2]]</TT>.<BR>
Cette matrice changera à chaque modification du tableur sauf, si on a 
choisi <TT>Ne pas recalculer automatiquement</TT> dans la configuration du tableur
(avec le menu <TT>Edit</TT><TT>▸</TT><TT>Configuration</TT>).
</LI></UL><H3 CLASS="subsection"><A NAME="htoc15">1.3.2</A>  Pour voir le contenu d’une cellule</H3><P>
Lorsqu’on consulte le tableur, toutes les cellules sont évaluées. 
Pour voir le contenu évalué d’une cellule située hors du champ de vision,
on utilise, soit le curseur vertical (situé à droite du tableur) qui permet
de voir les dernières lignes, soit le curseur horizontal (situé à la 
dernière ligne du tableur) qui permet de voir les dernières colonnes.<BR>
<B>Remarque</B><BR>
Lorsque toutes les cellules sont visibles, ces deux curseurs ne sont pas 
présents.<BR>
Pour voir le contenu non évalué d’une cellule (c’est à dire ce que l’on 
a mis, initialement, dans la cellule comme formule ou comme valeur), 
il suffit de cliquer sur 
cette cellule : il apparait alors dans la ligne de commande la formule (ou 
la valeur) qui a été mise dans cette cellule.<BR>
Pour faire apparaitre dans la ligne de commande, le contenu évalué de 
la cellule, il suffit d’appuyer sur le bouton <TT>eval</TT>.<BR>
Lorsque le résultat est trop grand (ou trop petit) en taille on peut avoir 
besoin d’agrandir une colonne pour voir ce résultat entièrement (ou de 
diminuer la colonne pour gagner de la place). Par exemple, on veut modifier 
la taille de la colonne <TT>B</TT>, on 
déplace la souris sur le trait vertical qui sépare <TT>B</TT> de <TT>C</TT> : 
le curseur devient ↔. On clique avec la souris et, sans 
relacher le bouton de la souris, on déplace ce trait vertical pour agrandir 
ou diminuer la largeur de la colonne <TT>B</TT>.
Lorsque le résultat est trop grand, on peut aussi appuyer sur le bouton 
<TT>eval</TT> pour faire apparaitre ce résultat dans la ligne de commande.
</P><H3 CLASS="subsection"><A NAME="htoc16">1.3.3</A>  Références absolues et relatives</H3><P><A NAME="sec:references"></A>
Dans une cellule on peut mettre :<BR>
- une chaine de caractères,<BR>
- une expression algébrique,<BR>
- une formule faisant référence à d’autres cellules. Ces références
peuvent être absolues ou relatives à la cellule qui contient la formule. 
Les références absolues sont obtenues en rajoutant <TT>$</TT> devant la 
lettre désignant la colonne ou devant le numéro de la ligne de la cellule 
référence.<BR>
Les références relatives permettent de désigner les cellules par 
rapport à une autre : ainsi <TT>A0</TT> mis dans la cellule <TT>B1</TT> désigne 
la cellule située dans la colonne précédente et à la ligne 
précédente et c’est cette information qui sera recopiée quand on
recopiera la formule vers le bas ou vers la droite.<BR>
Exemples :<BR>
Dans <TT>A0</TT> il y a 1 et je tape dans <TT>B1</TT> la formule :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>$A$0+2</TT> : dans <TT>B1</TT> il y aura 3, et si je recopie cette 
formule vers le bas, j’obtiens des 3 dans la colonne <TT>B</TT> car je recopie 
dans toutes les cases de la colonne <TT>B</TT> la formule <TT>$A$0+2</TT>. Si je 
recopie cette formule vers la droite, j’obtiens aussi des 3 dans la 
première ligne, car je recopie dans toutes les cases de la première ligne 
la formule <TT>$A$0+2</TT> puisque <TT>$A$0</TT> est la référence absolue 
de la case <TT>A0</TT>.
</LI><LI CLASS="li-itemize"><TT>$A0+2</TT> : dans <TT>B1</TT> il y aura 3, et si je recopie cette formule 
vers le bas cette formule deviendra <TT>$A1+2</TT> dans <TT>B2</TT>, <TT>$A2+2</TT> 
dans <TT>B3</TT>. La valeur de <TT>B2</TT> dépend donc de la valeur de <TT>A1</TT>, 
la valeur de <TT>B3</TT> dépend donc de la valeur de <TT>A2</TT> etc...<BR>
Si je recopie cette formule vers la droite, cette formule deviendra 
<TT>$A0+2</TT> dans <TT>C1</TT>, <TT>$A0+2</TT> dans <TT>D1</TT> ...j’obtiens 
donc une ligne de 3. <TT>$A0</TT> fait toujours référence à la colonne 
<TT>A</TT> : <TT>A</TT> est une référence absolue mais <TT>0</TT> désigne ici la 
ligne précédente puisque <TT>$A0</TT> a été mis dans <TT>B1</TT>. 
</LI><LI CLASS="li-itemize"><TT>A$0+2</TT> : dans <TT>B1</TT> il y aura 3, et si je recopie cette formule
vers le bas, j’obtiens des 3 dans la colonne <TT>B</TT> mais si je recopie cette 
formule vers la droite, cette formule deviendra <TT>B$0+2</TT> dans <TT>C1</TT>, 
<TT>C$0+2</TT> dans <TT>D1</TT> etc... 
</LI><LI CLASS="li-itemize"><TT>A0+2</TT> : dans <TT>B1</TT> il y aura 3, et si je recopie cette formule 
vers le bas, cette formule deviendra <TT>A1+2</TT> dans <TT>B2</TT>, <TT>A2+2</TT> dans 
<TT>B3</TT> etc...si je recopie cette formule vers la droite, cette formule 
deviendra <TT>B0+1</TT> dans <TT>C1</TT>, <TT>C0+1</TT> dans <TT>D1</TT> etc... 
</LI></UL><H3 CLASS="subsection"><A NAME="htoc17">1.3.4</A>  Référence d’un sous-tableau</H3><P>
Il y a deux façons de désigner un morceau du tableur selon que l’on veut 
remplir une cellule ou le sélectionner dans la <TT>case de sélection</TT>.<BR>
 Il sera désigné par :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
dans une cellule, par la référence de sa première case puis 
"deux points" (<TT>:</TT>), puis la référence de sa dernière case.<BR>
Les références de la première ou de la dernière case seront selon les 
cas, absolues ou relatives, mais <B>attention</B> cela est valable pour des 
colonnes contigües et représente une liste i.e. le tableau est aplati,
</LI><LI CLASS="li-itemize">dans la <TT>case de sélection</TT> par
référence de sa première case puis "point point" (<TT>..</TT>), puis le
numéro de la dernière ligne, puis virgule (<TT>,</TT>) suivi de la séquence 
des lettres désignant les colonnes. Cette fois cela représente une matrice
est on peut facilement désigner des colonnes non contigües.
</LI></UL><P>
<B>Remarque</B>
Dans la <TT>case de sélection</TT>, on ne peut pas utiliser "deux points" 
(<TT>:</TT>) comme séparateur entre les deux références.<BR>
<B>Exemple</B><BR>
Dans une cellule <TT>A0:B5</TT> représente la liste des valeurs de
<TT>[A0,B0,A1,B1,..,A5,B5]</TT> constituée par la matrice "aplatie".<BR>
Dans la <TT>case de sélection</TT>, <TT>A0..B5</TT> désigne le tableau de 6 
lignes (lignes 0,1..5) et 2 colonnes (colonnes <TT>A</TT> et <TT>B</TT>).<BR>
On a aussi la possibilité de désigner dans la 
<TT>case de sélection</TT> des colonnes non consécutives, on écrira par 
exemple <TT>A0..10,C,E</TT> pour sélectionner 
les 11 premières lignes des colonnes <TT>A</TT>, <TT>C</TT> et <TT>E</TT>.<BR>
<B>Attention!!!</B><BR>
Seule la <TT>case de sélection</TT> permet de définir un 
sous-tableau ou une matrice.<BR>
Donc dans une cellule pour désigner un sous-tableau on peut reconstituer la 
matrice à l’aide de la commande <TT>list2mat</TT> (qui transforme une liste en 
matrice selon le nombre de colonnes spécifié) si les colonnes sont 
consécutives ou en utilisant la commande 
<TT>tran</TT> (qui transforme une matrice en sa transposée).<BR>
Dans la cellule <TT>F0</TT> on tape par exemple :<BR>
 <TT>=list2mat(A0:B5,2)</TT> pour avoir une matrice avec 2 colonnes et 6 lignes
Dans la cellule <TT>F0</TT> on tape par exemple :<BR>
<TT>=list2mat(A0:D5,4)</TT> pour avoir une matrice avec 4 colonnes et 6 
lignes dans la cellule <TT>F0</TT>.<BR>
Dans la cellule <TT>F0</TT> on tape par exemple :<BR>
 <TT>=tran([A0:A3,C0:C3])</TT> pour avoir une matrice avec 2 colonnes et 4
lignes dans la cellule <TT>F0</TT>.<BR>
Dans la cellule <TT>F0</TT> on tape par exemple :<BR>
 <TT>=tran([A0:A3,B0:B3,C0:C3])</TT> pour avoir une matrice avec 3 colonnes et 4
lignes dans la cellule <TT>F0</TT>.<BR>
<B>Attention!!!</B><BR>
On ne peut pas remplir plusieurs cellules d’un seul coup avec une matrice
contenant des références à d’autres cellules : quand il y a une formule
faisant des références à d’autres cellules on ne peut remplir qu’une 
seule cellule et il faut mettre le signe <TT>=</TT> devant la formule.
</P><H2 CLASS="section"><A NAME="toc4"></A><A NAME="htoc18">1.4</A>  Pour sauver l’écran du tableur</H2><H3 CLASS="subsection"><A NAME="htoc19">1.4.1</A>  Pour sauver une matrice</H3><P>
Vous avez rempli l’écran du tableur avec une matrice.</P><P>Pour sauver cette matrice vous pouvez utiliser le bouton <TT>Save</TT> de la barre
de boutons cela sauvera la matrice sous le nom inscrit dans la ligne d’état 
après <TT>Spreadsheet</TT> (en général le même nom que le nom du fichier 
sans son extension <TT>.tab</TT> ou vous pouvez utiliser le menu <TT>Fich</TT> 
sous-menu <TT>Nom de variable</TT> en donnant un autre nom de variable.</P><P>Pour sauver une sous-matrice, il faut la sélectionner soit avec la souris, 
soit en utilisant la case de sélection et ensuite 
utiliser le menu <TT>Fich</TT> sous-menu <TT>Sauver selection vers variable</TT> 
puis donner le nom de la variable qui stockera la matrice sélectionnée 
(cf <A HREF="#sec:sauver">1.1.6</A>).<BR>
La format est celui d’une matrice. On aura donc dans la variable designée
une matrice par exemple : <TT>[[1,2,3,4,5],[1,0,2,0,1],[...]]</TT>
</P><H3 CLASS="subsection"><A NAME="htoc20">1.4.2</A>  Pour sauver un tableur</H3><P><A NAME="sec:sauve"></A>
Vous avez rempli un tableur avec différentes formules. Pour sauver ce 
tableur il suffit d’utiliser le bouton <TT>sauver</TT> de la barre de boutons ou 
on utilise le menu <TT>Fich</TT> sous-menu <TT>Sauver comme</TT> (cf <A HREF="#sec:sauver">1.1.6</A>).<BR>
Lorsque vous sauvez ainsi, vous sauvez à la fois les formules et les valeurs.
En effet, le format de sauvetage est une matrice dont chaque coefficient est 
une liste de trois éléments : le premier élément est la formule qui 
définit la cellule, le deuxième élément est la valeur prise par la 
cellule et le troisième est une variable détat interne.<BR>
On aura par exemple <TT>spreadsheet[[[3,3,2],[=A0+1,4,2]],[...]]</TT>,
cela vaut dire que <TT>A0=3</TT>, que <TT>B0=A0+1</TT> et que la valeur de 
<TT>B0</TT> est <TT>4</TT>.<BR>
Lors d’une évaluation du tableur, la troisième valeur vaut :<BR>
<TT>0</TT> si la cellule n’a pas encore été recalculée,
<TT>1</TT> si la cellule est en cours de calcul,<BR>
 <TT>2</TT> si la cellule a été calculée.</P><P>L’algorithme est le suivant :<BR>
1/ On fait toutes les cellules de la gauche vers la droite
et du haut vers le bas,<BR>
2/ Si le troisième argument de la cellule vaut 2, c’est fini.
Si le troisième argument de la cellule vaut 1, on envoie une erreur :
"évaluation récursive",<BR>
3/ le troisième argument de la cellule vaut 0, on le met à 1 et
on cherche toutes les cellules dépendant de cette cellule,
on calcule leurs valeurs et on remplace puis, on met à 2 le troisième 
argument de la cellule.
</P><H2 CLASS="section"><A NAME="toc5"></A><A NAME="htoc21">1.5</A>  Pour copier une partie du tableur dans une ligne d’enrée</H2><H3 CLASS="subsection"><A NAME="htoc22">1.5.1</A>  Pour copier une seule cellule du tableur dans une ligne d’enrée</H3><P>
Il faut sélectionner la cellule à recopier avec la 
souris et se servir du bouton <TT>copier</TT> du tableur.<BR>
Puis, on met le curseur dans une ligne d’enrée, puis on appuie sur la touche 
<TT>coller</TT>, et la cellule est recopiée dans la ligne de commande.
</P><H3 CLASS="subsection"><A NAME="htoc23">1.5.2</A>  Pour copier plusieurs cellules du tableur dans une ligne d’entrée</H3><P>
Si les cellules sont consécutives, on peut les sélectionner avec la 
souris, sinon on utilisera la <TT>case de sélection</TT>.<BR>
On tape par exemple dans la <TT>case de sélection</TT> :<BR>
<TT>A0..3,D</TT><BR>
les quatre premières cellules des colonnes <TT>A</TT> et <TT>D</TT> sont alors 
sélectionnées.<BR>
Puis, on met le curseur dans une ligne de commande et on appuie sur la touche 
<TT>coller</TT>, et les quatre 
premières cellules des colonnes <TT>A</TT> et <TT>D</TT> sont recopiées dans la
ligne de commande.</P><H2 CLASS="section"><A NAME="toc6"></A><A NAME="htoc24">1.6</A>  Les fonctions spécifiques du tableur</H2><H3 CLASS="subsection"><A NAME="htoc25">1.6.1</A>  Tableau de valeurs de <I>f</I>(<I>x</I>) : <TT>tablefunc</TT></H3><P><A NAME="@default2"></A><A NAME="sec:tablefunc"></A>
On peut avoir, dans le tableur, le tableau des valeurs numériques d’une 
expression <I>f</I>(<I>x</I>) pour <I>x</I>=<I>x</I>0, <I>x</I>0+<I>h</I>, <I>x</I>0+2*<I>h</I>.... en tapant dans la ligne 
de commande du tableur :<BR>
<TT>tablefunc(f(x),x,x0,h)</TT> ou <TT>tablefunc(f(x),x)</TT>.<BR>
Après avoir selectionné <TT>A0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :<BR>
</P><DIV CLASS="center"><TT>tablefunc(x</TT><CODE><TT>^</TT></CODE><TT>2,x,-1,0.2)</TT></DIV><P>
On obtient si on a 15 lignes :<BR>
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><TT>&nbsp;</TT></TD><TD ALIGN=left NOWRAP><TT>A</TT></TD><TD ALIGN=left NOWRAP><TT>B</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>0</TT></TD><TD ALIGN=left NOWRAP><TT><I>x</I></TT></TD><TD ALIGN=left NOWRAP><TT><I>x</I></TT><SUP><TT>2</TT></SUP></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>1</TT></TD><TD ALIGN=left NOWRAP><TT>0.2.0</TT></TD><TD ALIGN=left NOWRAP><TT>"Tablefunc"</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>2</TT></TD><TD ALIGN=left NOWRAP><TT>-1</TT></TD><TD ALIGN=left NOWRAP><TT>1.0</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>3</TT></TD><TD ALIGN=left NOWRAP><TT>-0.8</TT></TD><TD ALIGN=left NOWRAP><TT>0.64</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>4</TT></TD><TD ALIGN=left NOWRAP><TT>-0.6</TT></TD><TD ALIGN=left NOWRAP><TT>0.36</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>..</TT></TD><TD ALIGN=left NOWRAP><TT>..</TT></TD><TD ALIGN=left NOWRAP><TT>..</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>14</TT></TD><TD ALIGN=left NOWRAP><TT>1.4</TT></TD><TD ALIGN=left NOWRAP><TT>1.96</TT></TD></TR>
</TABLE></DIV><P>
Dans le cas où les valeurs du point de départ <TT>x0</TT> et du pas <TT>h</TT> ne
sont pas précisées, ces valeurs valent par défaut <TT>x0=X-</TT> et 
<TT>h=((X+)-(X-))/10</TT> où <TT>X-</TT> et <TT>X+</TT> sont définis dans la 
configuration du graphique (bouton rouge <TT>geo</TT>) et valent au démarrage
<TT>X-=-5.0</TT> et <TT>X+=5.0</TT> et donc <TT>x0=-5.0</TT> et <TT>h=1.0</TT>.<BR>

On peut donc avoir aussi dans le tableur, les valeurs numériques des termes
d’une suite <I>u</I><SUB><I>n</I></SUB>=<I>f</I>(<I>n</I>) pour <I>n</I>=<I>n</I>0, <I>n</I>0+1, <I>n</I>0+2,.... en tapant dans la 
ligne de commande du tableur :<BR>
<TT>tablefunc(f(n),n,n0)</TT>.<BR>
Après avoir selectionné <TT>A0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :<BR>
</P><DIV CLASS="center"><TT>tablefunc(n</TT><CODE><TT>^</TT></CODE><TT>2,n,5,1)</TT></DIV><P>
On obtient si on a 15 lignes :<BR>
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><TT>&nbsp;</TT></TD><TD ALIGN=left NOWRAP><TT>A</TT></TD><TD ALIGN=left NOWRAP><TT>B</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>0</TT></TD><TD ALIGN=left NOWRAP><TT><I>n</I></TT></TD><TD ALIGN=left NOWRAP><TT><I>n</I></TT><SUP><TT>2</TT></SUP></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>1</TT></TD><TD ALIGN=left NOWRAP><TT>1.0</TT></TD><TD ALIGN=left NOWRAP><TT>"Tablefunc"</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>2</TT></TD><TD ALIGN=left NOWRAP><TT>5</TT></TD><TD ALIGN=left NOWRAP><TT>25.0</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>3</TT></TD><TD ALIGN=left NOWRAP><TT>6.0</TT></TD><TD ALIGN=left NOWRAP><TT>36.0</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>4</TT></TD><TD ALIGN=left NOWRAP><TT>7.0</TT></TD><TD ALIGN=left NOWRAP><TT>49.0</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>..</TT></TD><TD ALIGN=left NOWRAP><TT>..</TT></TD><TD ALIGN=left NOWRAP><TT>..</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>14</TT></TD><TD ALIGN=left NOWRAP><TT>17.0</TT></TD><TD ALIGN=left NOWRAP><TT>289.0</TT></TD></TR>
</TABLE></DIV><P>
<B>Remarque</B><BR>
 Lorsque la colonne <TT>A</TT> est sélectionnée, <TT>tablefunc(f(x),x,x0,h)</TT>
a pour effet de placer, dans la colonne <TT>A</TT> et à partir de la ligne 
<TT>0</TT> :<BR>
<TT>x,h,x0,A2+A$1</TT> et,<BR>
dans la colonne <TT>B</TT> et à partir de la ligne <TT>0</TT> :<BR>
<TT>f(x),"Tablefunc",evalf(subst(B$0,A$0,A2))</TT>
</P><H3 CLASS="subsection"><A NAME="htoc26">1.6.2</A>  Termes d’une suite récurrente : <TT>tableseq</TT></H3><P><A NAME="@default3"></A><A NAME="sec:tableseq"></A>
On peut avoir, dans le tableur, les valeurs numériques des termes d’une suite
récurrente (<TT><I>u</I></TT><SUB><TT>0</TT></SUB><TT>=<I>u</I>0,  <I>u</I></TT><SUB><TT><I>n</I></TT></SUB><TT>=<I>f</I>(<I>u</I></TT><SUB><TT><I>n</I>-1</TT></SUB><TT>)</TT>) grâce à la commande :<BR>
<TT>tableseq(f(n),n,u0)</TT>.<BR>
Après avoir selectionné <TT>A0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>tableseq(0.5*(n+3/n),n,3)</TT></DIV><P>
On obtient, si on a 7 lignes :
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><TT>&nbsp;</TT></TD><TD ALIGN=left NOWRAP><TT>A</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>0</TT></TD><TD ALIGN=left NOWRAP><TT>0.5*(n+3/n)</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>1</TT></TD><TD ALIGN=left NOWRAP><TT>n</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>2</TT></TD><TD ALIGN=left NOWRAP><TT>3</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>3</TT></TD><TD ALIGN=left NOWRAP><TT>2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>4</TT></TD><TD ALIGN=left NOWRAP><TT>1.75</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>..</TT></TD><TD ALIGN=left NOWRAP><TT>..</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>7</TT></TD><TD ALIGN=left NOWRAP><TT>1.73205080757</TT></TD></TR>
</TABLE></DIV><P>
Après avoir selectionné <TT>B0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>tableseq(x+y,[x,y],[1,1])</TT></DIV><P>
On obtient, les premiers termes de la suite de Fibonacci :
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><TT>&nbsp;</TT></TD><TD ALIGN=left NOWRAP><TT>B</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>x+y</TT></TD><TD ALIGN=left NOWRAP><TT>&nbsp;</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>1</TT></TD><TD ALIGN=left NOWRAP><TT>x</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>2</TT></TD><TD ALIGN=left NOWRAP><TT>y</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>3</TT></TD><TD ALIGN=left NOWRAP><TT>1</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>4</TT></TD><TD ALIGN=left NOWRAP><TT>1</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>5</TT></TD><TD ALIGN=left NOWRAP><TT>2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>..</TT></TD><TD ALIGN=left NOWRAP><TT>..</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>7</TT></TD><TD ALIGN=left NOWRAP><TT>5</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>..</TT></TD><TD ALIGN=left NOWRAP><TT>..</TT></TD></TR>
</TABLE></DIV><P>
<B>Remarque</B><BR>
 Lorsque la colonne <TT>E</TT> est sélectionnée, 
<TT>tableseq(f(n),n,u0)</TT> a pour effet de placer,
dans la colonne <TT>E</TT> et à partir de la ligne <TT>0</TT> :<BR>
<TT>f(n),n,u0,evalf(subst(E$0,E$1,E2))</TT>.
</P><H2 CLASS="section"><A NAME="toc7"></A><A NAME="htoc27">1.7</A>  Références de la cellule active : <TT>Row</TT> et <TT>Col</TT></H2><P><A NAME="@default4"></A><A NAME="@default5"></A>
<TT>Row</TT> et <TT>Col</TT> sont des fonctions qui sont utilisables essentiellement
dans le tableur, en dehors du tableur <TT>Row</TT> et <TT>Col</TT> sont le numéro 
de la ligne et de la colonne de la cellule sélectionnée du dernier tableur
évalué.<BR>
<TT>Row</TT> n’a pas des paramètre et renvoie le numéro de la ligne 
de la cellule courrante.<BR>
On tape quand la cellule <TT>C4</TT> est mise en surbrillance :<BR>
<TT>Row()</TT><BR>
On obtient :<BR>
<TT>4</TT><BR>
<TT>Col</TT> n’a pas des paramètre et renvoie le numéro de la colonne 
de la cellule courrante (la colonne <TT>A</TT> a pour numéro 0, 
la colonne <TT>B</TT> a pour numéro 1 etc...)<BR>
On tape quand la cellule <TT>C4</TT> est mise en surbrillance :<BR>
<TT>Col()</TT><BR>
On obtient :<BR>
<TT>3</TT><BR>
Ainsi si dans la cellule <TT>A0</TT> je mets :<BR>
<TT>=Row()+Col()</TT>
puis je recopie cette formule vers le bas et j’obtiens :<BR>
dans la colonne <TT>A</TT> :<BR>
 <TT>0,1,2,3,4...</TT><BR>
puis je recopie cette formule vers la droite depuis <TT>A0</TT> et j’obtiens :<BR>
dans la ligne <TT>0</TT> :<BR>
 <TT>0,1,2,3,4...</TT><BR>
puis je recopie cette formule vers la droite depuis <TT>A1</TT> et j’obtiens :<BR>
dans la ligne <TT>1</TT> :<BR>
<TT>1,2,3,4,5...</TT> etc...<BR>
<B>Attention</B> Bien mettre le signe <TT>=</TT> car <TT>Row()</TT> et <TT>Col()</TT>
font références à la ligne et à la colonne de la cellule dans laquelle 
se trouve la formule.
</P><H2 CLASS="section"><A NAME="toc8"></A><A NAME="htoc28">1.8</A>  Nommer une cellule par une variable : <TT>current_sheet</TT></H2><P><A NAME="@default6"></A><A NAME="sec:currentsheet"></A>
<TT>current_sheet</TT> est une fonction qui est utilisable
essentiellement dans le tableur, en dehors du tableur <TT>current_sheet</TT>
permet d’avoir accès aux cellules du dernier tableur évalué.<BR>
<TT>current_sheet</TT> s’utilise soit avec :<BR>
- aucun paramètre : <TT>current_sheet()</TT> renvoie le tableur tout entier,<BR>
- un paramètre entier : <TT>current_sheet(j)</TT> renvoie la ligne <TT>j</TT> 
du tableur,<BR>
- deux paramètres entiers : <TT>current_sheet(j,k)</TT> renvoie la cellule du 
tableur située à la ligne <TT>j</TT> et à la colonne <TT>k</TT>.<BR>
Ainsi <TT>current_sheet(3,1)</TT> désigne la cellule <TT>B3</TT>.<BR>
Cela permet de désigner une cellule par deux variables entières, 
par exemple :<BR>
<TT>j:=3;k:=1;current_sheet(j,k)</TT><BR>
<B>Remarque</B><BR>
Pour avoir la colonne <TT>k</TT> du tableur dans une ligne de commande, il faut 
taper :<BR>
<TT>tran(current_sheet())[k]</TT> (puisque <TT>tran(current_sheet())</TT> 
désigne la transposée du tableur).<BR>
On peut bien sûr utiliser <TT>current_sheet</TT> dans le tableur.<BR>
On tape :<BR>
<TT>=current_sheet(1,2)</TT><BR>
ou encore, on peut prendre la valeur d’une case comme indice :<BR>
si <TT>A0</TT> contient 1 et <TT>B1</TT> contient 2 on peut taper,
<TT>=current_sheet(A0,B1)</TT>.<BR>
<B>Exemple d’utilisation</B> :<BR>
On tape la suite des nombres entiers dans la colonne <TT>A</TT>.<BR>
On tape dans <TT>A0</TT> :<BR>
<TT>1</TT><BR>
 puis on tape dans <TT>A1</TT> :<BR>
<TT>=A0+1</TT><BR>
formule que l’on recopie avec avec le menu 
<TT>Edit</TT> du tableur, puis, <TT>Remplir</TT> et <TT>Copier vers le bas</TT>.<BR>
Dans la colonne <TT>B</TT> on met, par exemple, la suite 
<I>u</I><SUB><I>n</I></SUB>=∑<SUB><I>k</I>=0</SUB><SUP><I>n</I></SUP>(−1)<SUP><I>k</I></SUP>/(<I>k</I>+1).<BR>
On tape dans <TT>B0</TT> :<BR>
<TT>1</TT><BR>
puis on tape dans <TT>B1</TT> :<BR>
<TT>=B0+(-1)</TT><CODE><TT>^</TT></CODE><TT>A1/(A1+1)</TT>, formule que l’on recopie avec le menu 
<TT>Edit</TT> du tableur, puis, <TT>Remplir</TT> et <TT>Copier vers le bas</TT>.<BR>
On veut extraire de cette suite, les termes d’indice pair dans la colonne 
<TT>C</TT>, on tape dans <TT>C0</TT> :<BR>
<TT>=current_sheet(2*A0,1)</TT>, formule que l’on recopie 
avec <TT>remplir</TT> et <TT>vers le bas</TT>.<BR>
On veut extraire de cette suite les termes d’indice impair dans la colonne 
<TT>D</TT>, on tape dans <TT>D0</TT> :<BR>
 <TT>=current_sheet(2*A0+1,1)</TT>, formule que l’on recopie avec le menu 
<TT>Edit</TT> du tableur, puis, <TT>Remplir</TT> et <TT>Copier vers le bas</TT>.<BR>
Ou encore on utilise <TT>Row</TT> et on n’a besoin que de 3 colonnes .<BR>
On tape dans <TT>A0</TT> :<BR>
<TT>1</TT><BR>
 puis on tape dans <TT>A1</TT> :<BR>
<TT>=A0+(-1)</TT><CODE><TT>^</TT></CODE><TT>Row()/(Row()+1)</TT>, formule que l’on recopie avec le menu 
<TT>Edit</TT> du tableur, puis, <TT>Remplir</TT> et <TT>Copier vers le bas</TT>.<BR>
On veut extraire de cette suite, les termes d’indice pair dans la colonne 
<TT>B</TT>, on tape dans <TT>B0</TT> :<BR>
<TT>=current_sheet(2*Row(),0)</TT>, formule que l’on recopie 
avec <TT>remplir</TT> et <TT>vers le bas</TT>.<BR>
On veut extraire de cette suite les termes d’indice impair dans la colonne 
<TT>C</TT>, on tape dans <TT>C0</TT> :<BR>
 <TT>=current_sheet(2*Row()+1,0)</TT>, formule que l’on recopie avec le menu 
<TT>Edit</TT> du tableur, puis, <TT>Remplir</TT> et <TT>Copier vers le bas</TT>.</P><H2 CLASS="section"><A NAME="toc9"></A><A NAME="htoc29">1.9</A>  Compter les éléments du tableur vérifiant une propriété</H2><P>
On suppose que dans la colonne <TT>A</TT> il y a <TT>1,2,3,4</TT>, dans la colonne
<TT>B</TT> il y a <TT>2,4,6,8</TT> et dans la colonne <TT>C</TT> il y a 
<TT>4,8,12,16</TT>.<BR>
<B>Attention !</B><BR>
Pour désigner une plage du tableur, on tape <TT>A0:C3</TT>, mais <TT>Xcas</TT> le 
raplatit en une liste : dans l’exemple ci-dessus <TT>A0:C3=[1,2,2,4,3,6]</TT> 
<B>Remarque</B><BR>
Pour avoir une méthode rapide pour compter, par exemple, les sommes obtenues
lorsqu’on lance 101 fois deux dés. On remplit aléatoirement les colonnes
<TT>A</TT> et <TT>B</TT> en tapant <TT>ranm(101,1)</TT> comme valeur pour <TT>A0</TT> et 
<TT>B0</TT>.
Il faut créer une cellule tampon, qui contiendra le tableau des
valeurs de la zone à analyser. On place simplement dans
cette cellule la definition de la plage précédée de =, par exemple
si <TT>A0</TT> à <TT>B100</TT> contient des jets de deux dés, et que 
<TT>C</TT> contient la somme de la colonne <TT>A</TT> et de la colonne <TT>B</TT>,
on met dans <TT>D0</TT> : <TT>= C0:C100</TT>.<BR>
Ensuite dans <TT>D2</TT> à <TT>D12</TT> on ecrit :<BR>
<TT>=count_eq(2,D0)</TT>... <TT>count_eq(12,D0)</TT><BR>
Ainsi le calcul de la plage <TT>C0:C100</TT> qui est long n’est fait qu’une
fois. C’est le meme principe qu’en programmation, on utilise une
variable intermediaire (la cellule tampon <TT>D0</TT>).
</P><H3 CLASS="subsection"><A NAME="htoc30">1.9.1</A>  Compter les éléments d’un sous tableau vérifiant une propriété : <TT>count</TT></H3><P><A NAME="@default7"></A>
<TT>count</TT> a deux ou trois paramètres : une fonction réelle 
<TT>f</TT> et une liste ou un sous-tableau éventuellement un paramètre 
optionnel <TT>row</TT> ou <TT>col</TT>.<BR>

<B>Attention</B> dans le tableur les paramètre optionnels <TT>row</TT> ou 
<TT>col</TT> ne servent pas, car dans une ligne du tableur 
un sous-tableau (par exemple <TT>A0:C3</TT>) désigne une liste : en effet
si dans une cellule on met <TT>=A0:C3</TT>, la cellule contient la liste obtenue 
en mettant les lignes du sous tableau <TT>A0:C3</TT> bout à bout.<BR>
Si vous voulez utiliser le sous tableau (par exemple <TT>A0:C3</TT>) comme une 
matrice il faut mettre dans une cellule <TT>=list2mat(A0:C3),3)</TT> (car <TT>3</TT> 
est le nombre de colonnes de <TT>A0:C3</TT>). On peut aussi sauver la sélection 
<TT>A0:C3</TT> vers une variable (menu <TT>Table</TT>), car lors de cette affectation
la matrice n’est pas aplati et donc cette variable contient une matrice.<BR>

<TT>count</TT> applique la fonction aux éléments de la 
liste ou du sous-tableau et en renvoie la somme.<BR>
Si <TT>f</TT> est une fonction boolénne <TT>count</TT> renvoie le nombre 
d’éléments de la liste ou du sous-tableau pour lesquels la fonction 
boolénne est vraie.<BR>
On tape dans une cellule :
</P><DIV CLASS="center"><TT>=count((x)-&gt;x,A0:C3)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>70</TT></DIV><P>
En effet, la somme des éléments de <TT>A0:C3</TT> vaut <TT>(1+2+3+4)*7=70</TT>
car dans A il y a 1,2,3,4 dans B il y a 2*A soit 2,4,6,8 et dans C il y a 4*A 
soit 4,8,12,16 donc en tout il y a 7*A.<BR>
On tape dans une cellule :
</P><DIV CLASS="center"><TT>=count((x)-&gt;(x&lt;10 and x&gt;5),A0:C3)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>3</TT></DIV><P>
En effet, il y a <TT>6,8,8</TT>, soit 3 éléments qui sont entre 5 et 10.
</P><H3 CLASS="subsection"><A NAME="htoc31">1.9.2</A>  Compter les éléments ayant une valeur donnée : <TT>count_eq</TT></H3><P><A NAME="@default8"></A>
<TT>count_eq</TT> a deux ou trois paramètres : une nombre et une liste
réelle ou un sous-tableau et éventuellement un paramètre 
optionnel <TT>row</TT> ou <TT>col</TT>.<BR>
<B>Attention</B> dans le tableur les paramètre optionnels <TT>row</TT> ou 
<TT>col</TT> ne servent pas, car dans le tableur car un sous-tableau est aplati en
une liste.<BR>
<TT>count_eq</TT> renvoie le nombre d’éléments de la liste ou du sous-tableau
qui sont égaux au premier argument.<BR>
On tape dans une cellule :
</P><DIV CLASS="center"><TT>=count_eq(4,A0:C3)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>3</TT></DIV><P>
car dans A il y a 1,2,3,4 dans B il y a 2*A soit 2,4,6,8 et dans C il y a 4*A 
soit 4,8,12,16.
</P><H3 CLASS="subsection"><A NAME="htoc32">1.9.3</A>  Compter les éléments plus petits qu’une valeur donnée : <TT>count_inf</TT></H3><P><A NAME="@default9"></A>
<TT>count_inf</TT> a deux ou deux paramètres : une nombre et une liste
réelle ou un sous-tableau et éventuellement un paramètre 
optionnel <TT>row</TT> ou <TT>col</TT>.<BR>
<B>Attention</B> dans le tableur les paramètre optionnels <TT>row</TT> ou 
<TT>col</TT> ne servent pas, car dans le tableur car un sous-tableau est aplati en
une liste.<BR>
<TT>count_inf</TT> renvoie le nombre d’éléments de la liste (ou du 
sous-tableau qui sont strictement inférieurs au premier argument.<BR>
On tape dans une cellule :
</P><DIV CLASS="center"><TT>=count_inf(4,A0:C3)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>4</TT></DIV><P>
car dans A il y a 1,2,3,4 dans B il y a 2*A soit 2,4,6,8 et dans C il y a 4*A 
soit 4,8,12,16.</P><H3 CLASS="subsection"><A NAME="htoc33">1.9.4</A>  Compter les éléments plus grands qu’une valeur donnée : <TT>count_sup</TT></H3><P><A NAME="@default10"></A>
<TT>count_sup</TT> a deux ou trois paramètres : une nombre et une 
liste réelle ou un sous-tableau et éventuellement un paramètre 
optionnel <TT>row</TT> ou <TT>col</TT>.<BR>
<B>Attention</B> dans le tableur les paramètre optionnels <TT>row</TT> ou 
<TT>col</TT> ne servent pas, car dans le tableur car un sous-tableau est aplati en
une liste.<BR>
<TT>count_sup</TT> renvoie le nombre d’éléments de la liste 
ou du sous-tableau qui sont strictement supérieurs au premier argument.<BR>
On tape dans une cellule :
</P><DIV CLASS="center"><TT>=count_sup(4,A0:C3)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>5</TT></DIV><P>
car dans A il y a 1,2,3,4 dans B il y a 2*A soit 2,4,6,8 et dans C il y a 4*A 
soit 4,8,12,16.
</P><H2 CLASS="section"><A NAME="toc10"></A><A NAME="htoc34">1.10</A>  Les fonctions statistiques à une variable du tableur</H2><H3 CLASS="subsection"><A NAME="htoc35">1.10.1</A>  Les fonctions graphiques</H3><P>
On peut utiliser directement le graphique depuis le tableur : les fonctions 
graphiques peuvent être utilisées dans une cellule. Pour avoir 
l’histogramme, la boite à moustaches, un nuage de points ou une ligne 
polygonale depuis le tableur on peut se servir du menu <TT>Maths</TT> du
tableur (puis <TT>stats 1-d</TT>) après avoir sélectionné dans le 
tableur l’argument avec la souris ou avec la <TT>case de sélection</TT>.
Dans ce cas, une boite de dialogue s’ouvre, vous devez choisir la cellule cible
(c’est dans cette cellule que s’inscrira la commande graphique), vous pouvez
éventuellement modifier la sélection (en mettant par exemple <TT>A1..B6</TT>
dans <TT>cellules entrée</TT>), vous pouvez cocher (resp ne pas cocher) 
<TT>valeur</TT> pour que la commande graphique ait pour argument les valeurs 
(resp les références) de la sélection : donc si <TT>valeur</TT> n’est pas 
cochée un changement de valeur dans une cellule de la sélection aura pour 
conséquence un changement du graphique, si on est en mode automatique ou si 
on appuie sur le bouton <TT>eval</TT>.<BR>
Ou encore, on peut taper la commande correspondante (ou se servir du menu 
<TT>Math</TT><TT>▸</TT><TT>Proba_stats</TT><TT>▸</TT><TT>1-d</TT>) dans la 
ligne de commande du tableur en recopiant les arguments en se servant de la 
souris (ou en se servant de la <TT>case de sélection</TT> et de la touche 
<TT>coller</TT> lorsque les colonnes que l’on veut recopier ne sont pas 
consécutives), ou encore on peut sauver la sélection dans une variable en 
utilisant le menu du tableur 
<TT>Table</TT><TT>▸</TT><TT>Sauver sélection vers variable</TT> on 
donne un nom par exemple <TT>A</TT>, puis on tape <TT>moustache(A)</TT> ou... Dans ce
cas on travaille avec les valeurs de la sélection.<BR>

</P><H3 CLASS="subsection"><A NAME="htoc36">1.10.2</A>  Centre d’un intervalle : <TT>interval2center</TT></H3><P><A NAME="@default11"></A>
<TT>interval2center</TT> a comme argument un intervalle ou une liste
(resp séquence) d’intervalles (utile pour définir les centres des classes).<BR>
<TT>interval2center</TT> renvoie le centre de l’intervalle ou la liste 
(resp séquence) des centres de ces intervalles.<BR>
<TT>interval2center</TT> est utile pour définir les centres des classes.<BR>
On tape :
</P><DIV CLASS="center"><TT>interval2center(3..5)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>4</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>interval2center([2..4,4..6,6..10])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[3,5,8]</TT></DIV><H3 CLASS="subsection"><A NAME="htoc37">1.10.3</A>  Centre d’un intervalle : <TT>center2interval</TT></H3><P><A NAME="@default12"></A>
<TT>center2interval</TT> a comme argument un vecteur de réels <TT>V</TT>
d’au moins deux composantes et éventuellement un réel comme deuxième 
argument.<BR>
<TT>center2interval</TT> renvoie un vecteur d’intervalles ayant pour centres 
les composantes de l’argument <TT>V</TT> : ces intervalles sont définis en 
commençant le premier intervalle, par le deuxième argument ou à 
défaut par <TT>(3*V[0]-V[1])/2</TT>.<BR>
<TT>center2interval</TT> est utile pour définir des classes à partir de leurs
centres et du minimum des classes.<BR>
On tape :
</P><DIV CLASS="center"><TT>center2interval([3,5,8])</TT></DIV><P>
Ou on tape car la valeur par défaut du deuxième argument est 2=(3*3-5)/2 :
</P><DIV CLASS="center"><TT>center2interval([3,5,8],2)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[2..4,4..6,6..10]</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>center2interval([3,5,8],2.5)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[2.5..3.5,3.5..6.5,6.5..9.5]</TT></DIV><P>
<B>Attention</B><BR>
On ne peut pas mettre n’importe quoi comme deuxème argument!!!<BR>
On tape :
</P><DIV CLASS="center"><TT>center2interval([5,7,8],4)</TT></DIV><P>
Ou on tape, car la valeur par défaut du deuxième argument est 4=(3*5-7)/2 :
</P><DIV CLASS="center"><TT>center2interval([5,7,8])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>"center2interval Bad Argument Value"</TT></DIV><P>
La fonction suivante peut vous permettre de trouver l’intervalle dans lequel 
il faut choisir le deuxème argument, quand il y a une solution!!!<BR>
En effet on doit pouvoir trouver <I>a</I>0,<I>a</I>1,<I>a</I>2... vérifiant :<BR>
<I>a</I>0&lt;<I>a</I>1&lt;<I>a</I>2.... et<BR>
<I>a</I>0+<I>a</I>1=2*<I>c</I>0=<I>b</I>0,<I>a</I>1+<I>a</I>2=2*<I>c</I>1=<I>b</I>1,<I>a</I>2+<I>a</I>3=2*<I>c</I>2=<I>b</I>2.... quand <I>L</I>=[<I>c</I>0,<I>c</I>1,<I>c</I>2...] avec
<I>c</I>0&lt;<I>c</I>1&lt;<I>c</I>2....<BR>
On a donc :<BR>
<I>a</I>1=<I>b</I>0−<I>a</I>0,<BR>
<I>a</I>2=<I>b</I>1−<I>a</I>1=<I>b</I>1−<I>b</I>0+<I>a</I>0,<BR>
<I>a</I>3=<I>b</I>2−<I>a</I>2=<I>b</I>2−<I>b</I>1+<I>b</I>0−<I>a</I>0<BR>
<I>a</I>4=<I>b</I>3−<I>a</I>3 ...<BR>
comme on doit avoir <I>a</I>0&lt;<I>a</I>1 et <I>a</I>1&lt;<I>a</I>2 (c’est à dire <I>a</I>1&lt;<I>c</I>1) il faut donc 
trouver <I>a</I>0 vérifiant <I>a</I>0&lt;<I>c</I>0 et <I>b</I>0−<I>c</I>1&lt;<I>a</I>0 puis<BR>
<I>a</I>2&lt;<I>a</I>3 i.e. <I>a</I>0&lt;<I>c</I>2−<I>c</I>1+<I>c</I>0 et<BR>
<I>a</I>3&lt;<I>a</I>4 i.e.<I>a</I>3&lt;<I>c</I>3 <I>b</I>0−<I>b</I>1+<I>b</I>2−<I>c</I>3&lt;<I>a</I>0...<BR>
On construit donc deux listes :<BR>
<TT>l1=[c0,c2-2*c1+2*c0...]</TT> et<BR>
<TT>l2=[2*c0-c1,2*c0-2*c1+2*c2-c3,..]</TT>.<BR>
La condition que doit vérifier <TT>a0</TT> est alors :<BR>
 <TT>max(l1)&lt;a0&lt;min(l2)</TT>.
</P><PRE CLASS="verbatim">debut_classes(L):={
local l1,l2, n,j, a, b;
n:=size(L);
L:=sort(L);
l1:=[L[0]];
l2:=[2*L[0]-L[1]];
for (j:=1;2*j+1&lt;n;j++) {
l1:=concat(l1,l2[j-1]-L[2*j-1]+L[2*j]);
l2:=concat(l2,l1[j]+L[2*j]-L[2*j+1]);
}
if (irem(n,2)==1) {
j:=quo(n-1,2);
l1:=concat(l1,l2[j-1]-L[2*j-1]+L[2*j]);
}
a:=max(l2);
b:=min(l1);
if (a&lt;b) return(]a,b[); else return ("impossible");
}
</PRE><P>On tape :
</P><DIV CLASS="center"><TT>debut_classes([5,7,8])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>]3,4[</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>center2interval([5,7,8],3.5)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[3.5 .. 6.5,6.5 .. 7.5,7.5 .. 8.5]</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>interval2center([3.5 .. 6.5,6.5 .. 7.5,7.5 .. 8.5])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[5.0,7.0,8.0]</TT></DIV><H3 CLASS="subsection"><A NAME="htoc38">1.10.4</A>  Somme des cellules d’un sous-tableau : <TT>sum</TT></H3><P><A NAME="@default13"></A><A NAME="sec:sumex"></A>
La commande <TT>sum</TT> permet de calculer la somme des éléments d’une
liste.<BR>
Si on a une matrice ou un sous-tableau définie dans un tableur, on sait 
qu’en désignant ses éléments par :<BR>
"référence de la première case de la matrice" <TT>:</TT> 
"référence de sa dernière case de la matrice", on obtient la liste des 
éléments de la matrice (par ex <TT>A0:B1</TT> est la liste <TT>[A0,B0,A1,B1]</TT>
formée par la matrice aplatie).<BR>
<B>Attention</B><BR>
Pour traiter les exemples qui suivront, on remplit par exemple la colonne 
<TT>A</TT> par <TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT>.<BR>
Pour cela on met <TT>0</TT> dans <TT>A0</TT>, et<BR>
<TT>=A0</TT><CODE><TT>^</TT></CODE><TT>2</TT> dans <TT>B0</TT>, <TT>=A0+1</TT> dans <TT>A1</TT> puis on utilise le
bouton <TT>remplir</TT> et <TT>vers le bas</TT> pour recopier les 2 formules dans 
chacune des colonnes 
<TT>A</TT> et <TT>B</TT>.<BR>
Après avoir selectionné <TT>C0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=sum(A0:B5)</TT></DIV><P>
On obtient dans <TT>C0</TT> :
</P><DIV CLASS="center"><TT>70</TT></DIV><P>
en effet : 1+2+3+4+5+1+4+9+16+25=3*5+5*11=70<BR>
Mais dans une ligne d’entrée, si on tape :<BR>
<TT>sum([[0,0],[1,1],[2,4],[3,9],[4,16],[5,25]])</TT><BR>
On obtient :<BR>
<TT>[15,55]</TT><BR>
qui est la somme des colonnes de la matrice.<BR>
Après avoir selectionné <TT>D0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=sum(A0:B5)+B8</TT></DIV><P>
On obtient dans <TT>D0</TT>:
</P><DIV CLASS="center"><TT>134</TT></DIV><P>
en effet : 1+2+3+4+5+1+4+9+16+25+64=3*5+5*11+64=134
</P><H3 CLASS="subsection"><A NAME="htoc39">1.10.5</A>  Somme de <I>n</I> cellules : <TT>sum</TT></H3><P><A NAME="@default14"></A><A NAME="sec:sum"></A>
On tape dans <TT>D0</TT> :
</P><DIV CLASS="center"><TT>10</TT></DIV><P>
On tape dans <TT>D1</TT> :
</P><DIV CLASS="center"><TT>=sum(current_sheet(j,1),j,1,D0)</TT></DIV><P>
On obtient dans <TT>D1</TT> la somme des cellules <TT>B1</TT> à <TT>B10</TT> :
</P><DIV CLASS="center"><TT>385</TT></DIV><P>
En effet <TT>current_sheet(j,1)</TT> désigne la cellule de la colonne <TT>B</TT> 
(colonne 1) et de la ligne <TT>j</TT> et puisque <TT>j</TT> varie de <TT>1</TT>
à <TT>D0</TT> qui vaut <TT>10</TT>, donc dans 
<TT>D1</TT> on a la somme des cellules de <TT>B1</TT> à <TT>B10</TT>.
</P><H3 CLASS="subsection"><A NAME="htoc40">1.10.6</A>  Moyenne des cellules d’un sous-tableau : <TT>mean</TT></H3><P><A NAME="@default15"></A><A NAME="sec:mean"></A>
Si <TT>mean</TT> a comme argument une liste, <TT>mean</TT> calcule la
moyenne des éléments de cette liste.<BR>
Si <TT>mean</TT> a comme argument deux listes, <TT>mean</TT> calcule la 
moyenne des éléments de la première listes, pondérés par les 
éléments de la seconde liste.<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>)<BR>
<B>Remarque</B><BR>
Une cellule remplie avec une chaine de caractères vide n’est pas prise en 
compte : on peut ainsi faire les calculs sur les réponses effectives à un 
questionnaire, par exemple, et ainsi de ne pas tenir compte des questionnaires 
non complètement remplis. 
</P><H4 CLASS="subsubsection">Moyenne des cellules d’un sous-tableau d’effectif 1</H4><P>
La commande <TT>mean</TT> permet de calculer la moyenne de plusieurs cellules
situées dans un sous-tableau.<BR>
Après avoir selectionné <TT>C0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=mean(A0:B5)</TT></DIV><P>
On obtient dans <TT>C0</TT> :
</P><DIV CLASS="center"><TT>35/6</TT></DIV><P>
en effet : <TT>A0:B5</TT> désigne la liste <TT>[0,0,1,1,2,4...,5,25]</TT>
<TT>mean(A0:B5)</TT> renvoie donc la valeur de :<BR>
 (1+2+3+4+5+1+4+9+16+25)/12=70/12=35/6=5.83333333333.<BR>
Mais dans une ligne d’entrée, si on tape :<BR>
<TT>mean([[0,0],[1,1],[2,4],[3,9],[4,16],[5,25]])</TT><BR>
On obtient :<BR>
<TT>[5/2,55/6]</TT>
</P><H4 CLASS="subsubsection">Moyenne des cellules d’un sous-tableau avec effectifs</H4><P>
La commande <TT>mean</TT> permet de calculer la moyenne des valeurs de cellules
situées dans un sous-tableau pondérée par un autre sous-tableau.<BR>
Après avoir selectionné <TT>D0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=mean(A3:B5,A0:B2)</TT></DIV><P>
On obtient dans <TT>D0</TT> :
</P><DIV CLASS="center"><TT>65/4</TT></DIV><P>
en effet, <TT>mean(A3:B5,A0:B2)</TT> calcule :<BR>
(4*1+5*2+16*1+25*4)/(1+2+1+4)=130/8=65/4.
Mais dans une ligne d’entrée, si on tape :<BR>
<TT>mean([[3,9],[4,16],[5,25]],[[0,0],[1,1],[2,4]])</TT><BR>
On obtient :<BR>
<TT>[14/3,116/5]</TT><BR>
En effet :<BR>
<TT>mean([3,4,5],[0,1,2])=14/3</TT><BR>
<TT>mean([9,16,25],[0,1,4])=116/5</TT><BR>
ce sont les moyennes des colonnes du premier argument pondérée par les 
colonnes du deuxième argument.<BR>
Après avoir selectionné <TT>D0</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=mean(A0:A5,B0:B5)</TT></DIV><P>
On obtient dans <TT>D0</TT> :
</P><DIV CLASS="center"><TT>45/11</TT></DIV><P>
en effet, <TT>mean(A0:A5,B0:B5)</TT> calcule :<BR>
(1*1+2*4+3*9+4*16+5*25)/(1+4+9+16+25)=45/11.
</P><H3 CLASS="subsection"><A NAME="htoc41">1.10.7</A>  Écart-type des cellules d’un sous-tableau : <TT>stddev</TT></H3><P><A NAME="@default16"></A><A NAME="sec:stddev"></A>
Il y a deux cas :<BR>
Si <TT>stddev</TT> a comme argument une liste, <TT>stddev</TT> 
calcule l’écart-type des éléments de ce sous-tableau.<BR>
Si <TT>stddev</TT> a comme argument deux listes, <TT>stddev</TT> calcule 
l’écart-type des éléments de la première liste, pondérés par les 
éléments de la seconde liste.<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>) 
</P><H4 CLASS="subsubsection">Écart-type des cellules d’un sous-tableau d’effectif 1</H4><P>
La commande <TT>stddev</TT> permet de calculer l’écart type des valeurs de
cellules situées dans un sous-tableau.<BR>
 Après avoir selectionné <TT>C1</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=stddev(A0:B5)</TT></DIV><P>
On obtient dans <TT>C1</TT> :
</P><DIV CLASS="center"><TT>sqrt(1877/36)</TT></DIV><P>
Mais dans une ligne d’entrée, si on tape :<BR>
<TT>stddev([[0,0],[1,1],[2,4],[3,9],[4,16],[5,25]])</TT><BR>
On obtient :<BR>
<TT>[sqrt(35/12),sqrt(2849/36)]</TT>
</P><H4 CLASS="subsubsection">Écart-type des cellules d’un sous-tableau avec effectifs</H4><P>
La commande <TT>stddev</TT> permet de calculer l’écart-type des valeurs de
cellules situées dans un sous-tableau pondérées par un autre sous-tableau.<BR>
Après avoir selectionné <TT>D1</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=stddev(A3:B5,A0:B2)</TT></DIV><P>
On obtient dans <TT>D1</TT> :
</P><DIV CLASS="center"><TT>sqrt(1419/16)</TT></DIV><P>
Mais dans une ligne d’entrée, si on tape :<BR>
<TT>stddev([3,9],[4,16],[5,25]],[[0,0],[1,1],[2,4]])</TT><BR>
On obtient :<BR>
<TT>[sqrt(2/9),sqrt(324/25)]</TT>
</P><H4 CLASS="subsubsection">Estimation de l’écart-type de la population mère : <TT>stdDev</TT></H4><P><A NAME="stdDev"></A>
<TT>stdDev</TT> a les mêmes arguments que <TT>stddev</TT>.
Si le premier argument a comme dimension <I>n</I>, on a la relation :<BR>
<TT>n:=size(L);stdDev(L)=stddev(L)*sqrt(n/(n-1))</TT>
La commande <TT>stdDev</TT> permet de calculer une estimation de l’écart-type de
la population mère à partir d’un échantillon d’ordre <I>n</I> et dont les 
valeurs sont mises en argument.<BR>
Après avoir selectionné <TT>C2</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=stdDev(A0:B5)</TT></DIV><P>
On obtient dans <TT>C2</TT> :
</P><DIV CLASS="center"><TT>sqrt(1877/33) </TT></DIV><P>
ici <I>n</I>=6*2=12 et 12/11*1877/36=1877/33 
Après avoir selectionné <TT>D2</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=stdDev(A3:B5,A0:B2)</TT></DIV><P>
On obtient dans <TT>D2</TT> :
</P><DIV CLASS="center"><TT>sqrt(1419/14)</TT></DIV><P>
ici <I>n</I>=8 et 8/7*1419/16=1419/14
</P><H3 CLASS="subsection"><A NAME="htoc42">1.10.8</A>  Variance des cellules d’un sous-tableau : <TT>variance</TT></H3><P><A NAME="@default17"></A><A NAME="sec:variance"></A>
Il y a deux cas :<BR>
Si <TT>variance</TT> a comme argument une liste, <TT>variance</TT> calcule la 
variance des éléments de cette liste.<BR>
Si <TT>variance</TT> a comme argument deux listes, <TT>variance</TT> calcule 
la variance des éléments de la première liste, pondérés par les 
éléments de la seconde liste. La variance est le carré de 
l’écart-type.<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>). 
</P><H4 CLASS="subsubsection">Variance des cellules d’un sous-tableau d’effectif 1</H4><P>
La commande <TT>variance</TT> permet de calculer la variance des valeurs de
cellules situées dans un sous-tableau.<BR>
Après avoir selectionné <TT>C2</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=variance(A0:B5)</TT></DIV><P>
On obtient dans <TT>C2</TT> :
</P><DIV CLASS="center"><TT>187/36</TT></DIV><H4 CLASS="subsubsection">Variance des cellules d’un sous-tableau avec effectifs</H4><P>
La commande <TT>variance</TT> permet de calculer la variance des valeurs de
cellules
situées dans un sous-tableau pondérée par un autre sous-tableau.<BR>
Après avoir selectionné <TT>D2</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=variance(A3:B5,A0:B2)</TT></DIV><P>
On obtient dans <TT>C6</TT> :
</P><DIV CLASS="center"><TT>1419/16 </TT></DIV><H3 CLASS="subsection"><A NAME="htoc43">1.10.9</A>  La médiane : <TT>median</TT></H3><P><A NAME="@default18"></A>
Il y a deux cas :<BR>
Si <TT>median</TT> a comme argument une liste, <TT>median</TT> calcule la 
médiane des éléments de cette liste.<BR>
Si <TT>median</TT> a comme argument deux listes, <TT>median</TT> calcule la 
médiane des éléments de la première liste, pondérée par les 
éléments de la seconde liste.<BR>
 La médiane est l’élement <I>M</I><SUB><I>e</I></SUB> de la série
à partir du lequel la fréquence cumulée de <I>M</I><SUB><I>e</I></SUB> égale ou dépasse 
0.5 (on appelle fréquence cumulée d’une valeur <TT>a</TT> la somme des 
fréquences de <TT>t</TT> pour toutes les valeurs <TT><I>t</I> ≤ <I>a</I></TT>)<BR>
Un sous-tableau est transformé en une liste quand on le désigne dans 
un tableur par :<BR>
"référence de sa première case" <TT>:</TT> 
"référence de sa dernière case".<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>).
</P><H4 CLASS="subsubsection">Médiane des cellules d’un sous-tableau d’effectif 1</H4><P>
La commande <TT>median</TT> permet de calculer la médiane des valeurs de
cellules situées dans un sous-tableau.<BR>
Après avoir selectionné <TT>C3</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=median(A0:A10)</TT></DIV><P>
On obtient dans <TT>C3</TT> :
</P><DIV CLASS="center"><TT>5.0</TT></DIV><H4 CLASS="subsubsection">Médiane des cellules d’un sous-tableau avec effectifs</H4><P>
La commande <TT>median</TT> permet de calculer la médiane des valeurs de
cellules
situées dans un sous-tableau pondérée par un autre sous-tableau.<BR>
Après avoir selectionné <TT>D3</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=median(A0:A10,B0:B10)</TT></DIV><P>
On obtient dans <TT>C7</TT> :
</P><DIV CLASS="center"><TT>8</TT></DIV><H3 CLASS="subsection"><A NAME="htoc44">1.10.10</A>  Le premier quartile : <TT>quartile1</TT></H3><P><A NAME="@default19"></A>
Il y a deux cas :<BR>
Si <TT>quartile1</TT> a comme argument un sous tableau, <TT>quartile1</TT> calcule le
premier quartile des éléments de ce sous-tableau.<BR>
Si <TT>quartile1</TT> a comme argument deux sous tableaux, <TT>quartile1</TT> calcule
le premier quartile des éléments du premier sous-tableau, pondérés par
les éléments du second sous-tableau.<BR>
 Le premier quartile est l’élement 
<I>Q</I><SUB>1</SUB> de la série à partir du lequel la fréquence cumulée de <I>Q</I><SUB>1</SUB> 
égale ou dépasse 0.25.<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>).
</P><H4 CLASS="subsubsection">Le premier quartile des cellules d’un sous-tableau d’effectif 1</H4><P>
La commande <TT>quartile1</TT> permet de calculer le premier quartile
des valeurs de
cellules situées dans un sous-tableau.<BR>
Après avoir selectionné <TT>C4</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=quartile1(A0:A10)</TT></DIV><P>
On obtient dans <TT>C4</TT> :
</P><DIV CLASS="center"><TT>2.0</TT></DIV><H4 CLASS="subsubsection">Le premier quartile des cellules d’un sous-tableau avec effectifs</H4><P>
La commande <TT>quartile1</TT> permet de calculer le premier quartile des valeurs
de cellules
situées dans un sous-tableau pondérée par un autre sous-tableau.<BR>
Après avoir selectionné <TT>D4</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=quartile1(A0:A10,B0:B10)</TT></DIV><P>
On obtient dans <TT>D4</TT> :
</P><DIV CLASS="center"><TT>7</TT></DIV><H3 CLASS="subsection"><A NAME="htoc45">1.10.11</A>  Le troisième quartile : <TT>quartile3</TT></H3><P><A NAME="@default20"></A>
Il y a deux cas :<BR>
Si <TT>quartile3</TT> a comme argument un sous tableau, <TT>quartile3</TT> calcule le
troisième quartile des éléments de ce sous-tableau.<BR>
Si <TT>quartile3</TT> a comme argument deux sous tableaux, <TT>quartile3</TT> calcule
le troisième quartile des éléments du premier sous-tableau, 
pondérés par les éléments du second sous-tableau. Le troisième 
quartile est l’élement <I>Q</I><SUB>3</SUB> de la série à partir du lequel la 
fréquence cumulée de <I>Q</I><SUB>3</SUB> égale ou dépasse 0.75.<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>).
</P><H4 CLASS="subsubsection">Le troisième quartile des cellules d’un sous-tableau d’effectif 1</H4><P>
La commande <TT>quartile3</TT> permet de calculer le troisième quartile
des valeurs de cellules situées dans un sous-tableau.<BR>
Après avoir selectionné <TT>C5</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=quartile3(A0:A10)</TT></DIV><P>
On obtient dans <TT>C5</TT> :
</P><DIV CLASS="center"><TT>8.0</TT></DIV><H4 CLASS="subsubsection">Le troisième quartile des cellules d’un sous-tableau avec effectifs</H4><P>
La commande <TT>quartile3</TT> permet de calculer le troisième quartile
des valeurs de cellules situées dans un sous-tableau pondérées par un 
autre sous-tableau.<BR>
Après avoir selectionné <TT>D5</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=quartile3(A0:A10,B0:B10)</TT></DIV><P>
On obtient dans <TT>D5</TT> :
</P><DIV CLASS="center"><TT>10</TT></DIV><H3 CLASS="subsection"><A NAME="htoc46">1.10.12</A>  Les valeurs indiquant la répartition : <TT>quartiles</TT></H3><P><A NAME="@default21"></A>
Il y a deux cas :<BR>
Si <TT>quartiles</TT> a comme argument un sous tableau, <TT>quartiles</TT> calcule 
la matrice colonne contenant le minimum, le premier quartile, la médiane, 
le troisième quartile et le maximum des éléments de ce sous-tableau.<BR>
Si <TT>quartiles</TT> a comme argument deux sous tableaux, <TT>quartiles</TT> calcule
la matrice colonne contenant le minimum, le premier quartile, la médiane, 
le troisième quartile et le maximum des éléments du premier sous-tableau,
pondérés par les éléments du second sous-tableau.<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>).</P><H4 CLASS="subsubsection">Valeurs indiquant la répartition des cellules d’un sous-tableau d’effectif 1</H4><P>
La commande <TT>quartiles</TT> permet de calculer la matrice colonne contenant
le minimum, le premier quartile, la médiane, le troisième quartile et 
le maximum des valeurs de cellules situées dans un sous-tableau.<BR>
Après avoir selectionné <TT>C6</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=quartiles(A0:A10)</TT></DIV><P>
On obtient dans <TT>C6</TT> :
</P><DIV CLASS="center"><TT>[[0.0],[2.0],[5.0],[8.0],[10.0]]</TT></DIV><H4 CLASS="subsubsection">Valeurs indiquant la répartition des cellules d’un sous-tableau avec effectifs</H4><P>
La commande <TT>quartiles</TT> permet de calculer la matrice colonne contenant
le minimum, le premier quartile, la médiane, le troisième quartile et 
le maximum des valeurs de cellules
situées dans un sous-tableau pondérées par un autre sous-tableau.<BR>
 Après avoir selectionné <TT>D6</TT>, on tape, par exemple, dans la ligne de 
commande du tableur :
</P><DIV CLASS="center"><TT>=quartiles(A0:A10,B0:B10)</TT></DIV><P>
On obtient dans <TT>D6</TT> :
</P><DIV CLASS="center"><TT>[[1.0],[7.0],[8.0],[10.0],[10.0]]</TT></DIV><H2 CLASS="section"><A NAME="toc11"></A><A NAME="htoc47">1.11</A>  Les fonctions statistiques à deux variables du tableur</H2><H3 CLASS="subsection"><A NAME="htoc48">1.11.1</A>  Les fonctions graphiques</H3><P>
On peut utiliser directement le graphique depuis le tableur : toutes les 
fonctions graphiques peuvent être utilisées dans une cellule. Pour avoir un
nuage de points on utilise <TT>scatterplot</TT> et pour tracer une ligne 
polygonal on utilise <TT>polygonplot</TT>.<BR>
Depuis le tableur, on peut se servir du menu du tableur
<TT>Statistiques</TT><TT>▸</TT><TT>2-d</TT> et remplir la boite de dialogue 
correspondant à l’item choisi : vous devez choisir la cellule cible (c’est 
dans cette cellule que s’inscrira la commande graphique), vous pouvez
éventuellement modifier la sélection (en mettant par exemple <TT>A1..B6</TT>
dans <TT>cellules entrée</TT>), vous pouvez cocher (resp ne pas cocher) 
<TT>valeur</TT> pour que la commande graphique ait pour argument les valeurs (resp
les références) de la sélection : donc si <TT>valeur</TT> n’est pas cochée
un changement de valeur dans une cellule de la sélection aura pour 
conséquence un changement du graphique, si on est en mode automatique ou si 
on appuie sur le bouton <TT>eval</TT>.<BR>
Ou bien, dans la ligne de commande du tableur ou dans une ligne de commande, on
utilise <TT>scatterplot</TT> et <TT>polygonplot</TT> du menu 
<TT>Math</TT><TT>▸</TT><TT>Stats</TT><TT>▸</TT><TT>2-d</TT> et on recopie les 
arguments en les sélectionnant, soit en se servant de la souris (ou de la 
<TT>case de sélection</TT> et de la touche <TT>coller</TT> lorsque les colonnes 
que l’on veut recopier ne sont pas consécutives), soit on sauve cette 
sélection avec le menu du tableur <TT>Fich</TT><TT>▸</TT><TT>Sauver 
sélection vers variable</TT>, on donne un nom par exemple <TT>A</TT>, puis on tape 
<TT>polygonplot(A)</TT> ou <TT>scatterplot(A)</TT>: dans ce cas on travaille avec les
valeurs de la sélection.<BR>
</P><H3 CLASS="subsection"><A NAME="htoc49">1.11.2</A>  La covariance avec effectif 1 : <TT>covariance</TT></H3><P><A NAME="@default22"></A><A NAME="sec:cov"></A>
<TT>covariance</TT> calcule la covariance numérique de plusieurs cellules
situées dans deux sous-tableaux de même dimension.<BR>
Si <TT>T</TT>=<I>t</I><SUB><I>j</I></SUB> est le premier argument et <TT>B</TT>=<I>b</I><SUB><I>j</I></SUB> le 
deuxième argument, la covariance <TT>covariance(T,B)</TT> est alors définie 
par :<BR>
 <I>cov</I>(<I>T</I>,<I>B</I>)=1/<I>N</I>∑<SUB><I>j</I></SUB>(<I>t</I><SUB><I>j</I></SUB>−<I>m</I><SUB><I>T</I></SUB>)(<I>b</I><SUB><I>j</I></SUB>−<I>m</I><SUB><I>B</I></SUB>)<BR>
où  <I>m</I><SUB><I>T</I></SUB> (resp  <I>m</I><SUB><I>B</I></SUB>) est la moyenne des éléments <I>t</I><SUB><I>j</I></SUB> de <TT>T</TT> 
(resp <I>b</I><SUB><I>j</I></SUB> de <TT>B</TT>) et <I>N</I> le nombre d’éléments de <TT>T</TT>.<BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>).<BR>
On tape lorsque <TT>C0</TT> est en surbrillance :
</P><DIV CLASS="center"><TT>=covariance(A1:A4,B1:B4)</TT></DIV><P>
On obtient dans <TT>C0</TT> :
</P><DIV CLASS="center"><TT>25/4 </TT></DIV><P>
Dans une ligne d’entrée, on tape :
</P><DIV CLASS="center"><TT>covariance([1,2,3,4],[1,4,9,16])</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>covariance([[1,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>25/4 </TT></DIV><H3 CLASS="subsection"><A NAME="htoc50">1.11.3</A>  La corrélation linéaire avec effectif 1 : <TT>correlation</TT></H3><P><A NAME="@default23"></A><A NAME="sec:corr"></A>
<TT>correlation</TT> calcule la corrélation linéaire numérique de plusieurs 
cellules situées dans deux sous-tableaux de même dimension.<BR>
Si <TT>T</TT>=<I>t</I><SUB><I>j</I></SUB> est le premier argument et <TT>B</TT>=<I>b</I><SUB><I>j</I></SUB> le 
deuxième argument, la corrélation <TT>correlation(T,B)</TT> est alors :
 <I>cov</I>(<I>T</I>,<I>B</I>)/σ(<I>T</I>) σ(<I>B</I>)<BR>
où  σ(<I>T</I>) (resp  σ(<I>B</I>)) est l’écart-type des 
éléments de <TT>T</TT> (resp <TT>B</TT>) et <I>cov</I>(<I>T</I>,<I>B</I>) est la covariance de 
<TT>T</TT> et de <TT>B</TT>.</P><P><B>Dans le tableur</B><BR>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>).<BR>
On tape lorsque <TT>C1</TT> est en surbrillance :
</P><DIV CLASS="center"><TT>=correlation(A1:A4,B1:B4)</TT></DIV><P>
On obtient dans <TT>C1</TT> :
</P><DIV CLASS="center"><TT>25/sqrt(645) </TT></DIV><P>
on a en effet :<BR>
<TT>covariance(A1:A4,B1:B4)=25/4</TT>,<BR>
 <TT>stddev(A1:A4)=sqrt(5)/2</TT> et,<BR>
<TT>stddev(B1:B4)=sqrt(129)/2</TT><BR>
et <TT>129*5=645</TT></P><P><B>Dans une ligne d’entrée</B><BR>
On tape :
</P><DIV CLASS="center"><TT>correlation([1,2,3,4],[1,4,9,16])</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>correlation([[1,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>25/sqrt(645) </TT></DIV><H3 CLASS="subsection"><A NAME="htoc51">1.11.4</A>  La covariance et la corrélation linéaire avec effectifs : <TT>covariance</TT> et <TT>correlation</TT></H3><P><A NAME="@default24"></A><A NAME="@default25"></A><A NAME="sec:corre"></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si les couples <I>a</I>[<I>j</I>],<I>b</I>[<I>j</I>] ont pour 
effectif <I>n</I>[<I>j</I>] (<I>j</I>=0..<I>p</I>−1), <TT>covariance</TT> (resp <TT>correlation</TT>) a pour 
argument trois listes <I>a</I>, <I>b</I>, <I>n</I> de même longueur <I>p</I>, ou 
une matrice composée trois colonnes <I>a</I>, <I>b</I>, <I>n</I> et de <I>p</I> lignes 
[<I>a</I>[<I>j</I>],<I>b</I>[<I>j</I>],<I>n</I>[<I>j</I>]].<BR>
<TT>covariance</TT> (resp <TT>correlation</TT>) calcule la covariance (resp 
corrélation) numérique des deux premières 
listes pondérées par la liste donnée comme dernier argument ou 
des deux colonnes de cette matrice pondérées par la troisiéme colonne.<BR>
<B>Dans une ligne d’entrée</B><BR>
On tape dans une ligne d’entrée :
<DIV CLASS="center"><TT>covariance([1,2,3,4],[1,4,9,16],[3,1,5,2])</TT></DIV>
Ou on tape :
<DIV CLASS="center"><TT>covariance([[1,1,3],[2,4,1],[3,9,5],[4,16,2]])</TT></DIV>
On obtient : 
<DIV CLASS="center"><TT>662/121</TT></DIV>
On tape dans une ligne d’entrée :
<DIV CLASS="center"><TT>correlation([1,2,3,4],[1,4,9,16],[3,1,5,2])</TT></DIV>
Ou on tape :
<DIV CLASS="center"><TT>correlation([[1,1,3],[2,4,1],[3,9,5],[4,16,2]])</TT></DIV>
On obtient : 
<DIV CLASS="center"><TT>662/(180*sqrt(14))</TT></DIV>
<B>Dans le tableur</B><BR>
On remplit les colonnes <TT>A,B,C</TT>.<BR>
On tape dans <TT>A0</TT> :
<DIV CLASS="center"><TT>[[1,1,3],[2,4,1],[3,9,5],[4,16,2]]</TT></DIV> 
On tape dans <TT>D0</TT> :
<DIV CLASS="center"><TT>=covariance(list2mat(A0:C3,3))</TT></DIV>
On obtient dans <TT>D0</TT> : 
<DIV CLASS="center"><TT>662/121</TT></DIV>
On tape dans <TT>D1</TT> :
<DIV CLASS="center"><TT>=correlation(list2mat(A0:C3,3))</TT></DIV>
On obtient dans <TT>E1</TT> : 
<DIV CLASS="center"><TT>662/(180*sqrt(14))</TT></DIV></LI><LI CLASS="li-itemize">Si les couples <I>a</I>[<I>j</I>],<I>b</I>[<I>k</I>] ont pour effectif <I>N</I>[<I>j</I>,<I>k</I>] lorsque <I>j</I>=0..<I>p</I>−1 et
<I>k</I>=0..<I>q</I>−1, 
<TT>covariance</TT> (resp <TT>correlation</TT>) a pour argument deux listes <I>a</I>, <I>b</I> 
de longueurs respectives <I>p</I> et <I>q</I> et une matrice <I>N</I> de <I>p</I> lignes et <I>q</I> 
colonnes.<BR>
<TT>covariance</TT> (resp <TT>correlation</TT>) calcule la covariance (resp 
corrélation) numérique des éléments de deux listes pondérés par 
un tableau donné comme troisième argument.<BR>
</LI></UL><P>
<B>Exercice</B><BR>
Soient <TT>X=[1,2]</TT>, <TT>Y=[11,13,14]</TT> et <TT>N=[[3,4,5],[12,1,2]]</TT>.<BR>
 Calculer la covariance et la corrélation de <TT>X,Y</TT> sachant qu’il y a
<TT>N</TT>= <I>N</I><SUB><I>j</I>,<I>k</I></SUB> couples <I>X</I><SUB><I>j</I></SUB>,<I>Y</I><SUB><I>k</I></SUB>.<BR>
<B>Dans une ligne d’entrée</B><BR>
On tape :
</P><DIV CLASS="center"><TT>covariance([1,2],[11,13,14],[[3,4,5],[12,1,2]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>-83/243</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>correlation([1,2],[11,13,14],[[3,4,5],[12,1,2]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>-83/160</TT></DIV><P>
On a :<BR>
<TT>simplify(stddev([1,2],[12,15]))=2*sqrt(5)/9</TT><BR>
<TT>simplify(stddev([11,13,14],[15,5,7]))=16*sqrt(5)/27</TT><BR>
et on a bien :<BR>
<TT>-83/243=-83/160*(sqrt(20)/9)*(16*sqrt(5)/2)</TT><BR>
<B>Dans le tableur</B><BR>
On peut disposer les données selon un tableau à double entrée à 
condition de rajouter <TT>-1</TT> comme dernier argument aux fonctions
<TT>covariance</TT> et <TT>correlation</TT>.<BR>
On tape :<BR>
dans <TT>A0</TT> :<BR>
"X\ Y" (c’est pour l’esthétique)<BR>
dans <TT>A1</TT> :<BR>
1<BR>
dans <TT>A2</TT> :<BR>
 2<BR>
dans <TT>B0,C0,D0</TT> :<BR>
<TT>11,13,14</TT><BR>
dans <TT>B1,C1,D1</TT> :<BR>
 <TT>3,4,5</TT><BR>
dans <TT>B2,C2,D2</TT> :<BR>
<TT>12,1,2</TT><BR>
Calcul de la covariance ou de la corrélation dans le tableur :<BR>
On tape dans <TT>E0</TT> :
</P><DIV CLASS="center"><TT>=covariance(list2mat(A0:D2,4),-1)</TT></DIV><P>
On obtient dans <TT>E0</TT> : 
</P><DIV CLASS="center"><TT>-83/243</TT></DIV><P>
On tape dans <TT>E1</TT> :
</P><DIV CLASS="center"><TT>=correlation(list2mat(A0:D2,4),-1)</TT></DIV><P>
On obtient dans <TT>E1</TT> : 
</P><DIV CLASS="center"><TT>-83/160</TT></DIV><P>
<B>Remarque</B><BR>
On peut bien sûr faire le même calcul dans une ligne d’entrée :<BR>
On sélectionne avec la souris <TT>A0..2,B,C,D</TT>, puis on 
tape :<BR>
 <TT>covariance(,-1)</TT><BR>
puis, on met le curseur à l’endroit
de l’argument manquant, puis on appuie sur coller,
ou on tape :
</P><DIV CLASS="center"><TT>covariance([["x\y",11,13,14], [1,3,4,5],[2,12,1,2]],-1)</TT></DIV><P> 
On obtient : 
</P><DIV CLASS="center"><TT>-83/243</TT></DIV><P>
On tape :
</P><DIV CLASS="center"><TT>correlation([["x\y",11,13,14], [1,3,4,5],[2,12,1,2]],-1)</TT></DIV><P> 
On obtient : 
</P><DIV CLASS="center"><TT>-83/160</TT></DIV><P>
<B>Attention</B><BR>
Dans une cellule du tableur on ne peut pas désigner 
un sous-tableau ou une matrice par :<BR>
"référence de la première case de la matrice" <TT>:</TT> 
"référence de sa dernière case de la matrice".<BR>
en effet si dans la cellule <TT>C0</TT> on tape :<BR>
<TT>=A0:B4</TT> et on obtient dans la cellule <TT>C0</TT> la liste :<BR>
<TT>[A0,B0,A1,B1,A2,B2]</TT> c’est à dire la matrice "aplatie".<BR>
Pourtant, si les couples <TT>A</TT>=<I>a</I>[<I>j</I>] et <TT>B</TT>=<I>b</I>[<I>j</I>] ont pour 
effectif <TT>N</TT>=<I>n</I>[<I>j</I>] (<I>j</I>=0..<I>p</I>−1),
la covariance (resp la corrélation) de <TT>A,B</TT> avec effectifs <TT>N</TT> 
peuvent se calculer dans une ligne d’entrée, mais aussi dans le tableur 
même si 
les données ne figurent pas dans des colonnes consécutives.<BR>
Lorsque les colonnes sont consécutives, on peut 
reconstituer la matrice en utilisant <TT>list2mat</TT>, par exemple si on met 
les valeurs de <TT>A</TT> dans la colonne <TT>A</TT>, les valeurs de <TT>B</TT>
dans la colonne <TT>B</TT> et les
effectifs <TT>N</TT> dans la colonne <TT>C</TT> on tape dans la cellule 
<TT>E1</TT> <TT>=list2mat(A0:C5,6,3)</TT> et on obtient dans la cellule <TT>E1</TT> la 
matrice cherchée ayant 6 lignes et 3 colonnes <TT>A,B,C</TT>.<BR>
Lorsque les colonnes ne sont pas consécutives par exemple si on met les 
effectifs <TT>N</TT>=<I>n</I>[<I>j</I>] dans la colonne <TT>D</TT> on 
tape alors pour avoir une matrice dans la cellule <TT>E1</TT> :<BR>
<TT>=tran([A0:A5,B0:B5,D0:D5])</TT> et on obtient dans la cellule <TT>E1</TT> la 
matrice cherchée ayant 6 lignes et 3 colonnes <TT>A,B,D</TT>.</P><H3 CLASS="subsection"><A NAME="htoc52">1.11.5</A>  La régression linéaire : <TT>linear_regression</TT></H3><P><A NAME="@default26"></A><A NAME="sec:linreg"></A>
Pour approcher les données par la droite des moindres carrés qui a pour 
équation <I>y</I>=<I>mx</I>+<I>b</I>, on utilise <TT>linear_regression</TT>.<BR>
<TT>linear_regression</TT> a les mêmes arguments que <TT>covariance</TT>.<BR>
Si <TT>linear_regression</TT> a comme argument la liste <TT>X</TT> des <I>x</I><SUB><I>j</I></SUB> et la 
liste <TT>Y</TT> des <I>y</I><SUB><I>j</I></SUB>, <TT>linear_regression</TT> renvoie (<I>m</I>, <I>b</I>) tel que 
<I>y</I> ≃ <I>m</I>*<I>x</I>+<I>b</I>.<BR>
Pour traiter une régression linéaire à 2 ou plusieurs variables on se 
reportera à la section <A HREF="#sec:linreg2">1.11.8</A>.</P><P><B>Avec le tableur</B>
Pour traiter les exemples, on remplit la colonne <TT>A</TT> par 
<TT>0,1,2,..,n</TT> et la colonne 
<TT>B</TT> par <TT>0,1,4,..,n</TT><CODE><TT>^</TT></CODE><TT>2</TT> (cf <A HREF="#sec:sumex">1.10.4</A>).<BR>
Puis, on tape dans la case <TT>C0</TT> :
</P><DIV CLASS="center"><TT>linear_regression(A1:A4,B1:B4)</TT></DIV><P>
On obtient dans la case <TT>C0</TT> :
</P><DIV CLASS="center"><TT>5,-5 </TT></DIV><P>
<B>Dans une ligne d’entrée</B><BR>
On tape :
</P><DIV CLASS="center"><TT>linear_regression([[1,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
Ou on tape</P><DIV CLASS="center"><TT>linear_regression([1,2,3,4],[1,4,9,16])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>(5,-5) </TT></DIV><P>
ce qui veut dire que <I>y</I>=5<I>x</I>−5 est la droite qui approche au mieux les points 
de coordonnées : (1,1),(2,4),(3,9),(4,16).<BR>
<B>Remarques</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
La deuxième droite de régression<BR>
Si on tape (on échange <I>X</I> et <I>Y</I>) :
<DIV CLASS="center"><TT>linear_regression([1,4,9,16],[1,2,3,4])</TT></DIV>
Ou on tape :
<DIV CLASS="center"><TT>linear_regression([[1,1],[4,2],[9,3],[16,4]])</TT></DIV>
On obtient la deuxième droite de régression : 
<DIV CLASS="center"><TT>25/129,45/43</TT></DIV>
On tape :
<DIV CLASS="center"><TT>evalf(25/129,45/43)</TT></DIV>
On obtient : 
<DIV CLASS="center"><TT>(0.193798449612,1.04651162791)</TT></DIV>
</LI><LI CLASS="li-itemize">Ajustement linéaire et corrélation linéaire<BR>
Si <I>R</I>2 est le carré du coefficient de corrélation linéaire de <I>X</I> et de
<I>Y</I> si <I>m</I>1 (resp <I>m</I>2) est la pente de la première (resp deuxième) droite 
de régression linéaire on a :
<DIV CLASS="center"><TT>R2=m1*m2</TT></DIV>
On tape :
<DIV CLASS="center"><TT>normal(correlation([1,2,3,4],[1,4,9,16])</TT><CODE><TT>^</TT></CODE><TT>2)</TT></DIV>
On obtient : 
<DIV CLASS="center"><TT>125/129</TT></DIV>
On tape :
<DIV CLASS="center"><TT>5* 25/129</TT></DIV>
On obtient : 
<DIV CLASS="center"><TT>125/129</TT></DIV>
On tape :
<DIV CLASS="center"><TT>evalf(125/129)</TT></DIV>
On obtient : 
<DIV CLASS="center"><TT>0.968992248062</TT></DIV>
</LI></UL><P>
<B>Autre exemples</B>
On suppose que l’on a les couples (<I>x</I><SUB><I>j</I></SUB>,<I>y</I><SUB><I>j</I></SUB>) avec :<BR>
<I>x</I>=[0,1,2,3,4,5,6,7,8,9,10] et<BR>
<I>y</I>=[7.3,9.53,12.47,16.3,21.24,27.73,36.22,47.31,61.78,80.68,105]<BR>
On tape :
</P><DIV CLASS="center"><TT>X:=[0,1,2,3,4,5,6,7,8,9,10]</TT></DIV><DIV CLASS="center"><TT>Y:=[7.3,9.53,12.47,16.3,21.24,27.73,36.22,</TT></DIV><DIV CLASS="center"><TT>47.31,61.78,80.68,105]</TT></DIV><DIV CLASS="center"><TT>Z:=log(Y)</TT></DIV><DIV CLASS="center"><TT>linear_regression(X,Z)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>(0.266729219953,1.98904252589)</TT></DIV><P>
c’est donc la fonction linéaire d’équation <I>z</I>=ln(<I>y</I>)=0.267*<I>x</I>+1.99 
qui approche au mieux les données.<BR>

On suppose qu’il y a <I>n</I><SUB><I>j</I></SUB> couples (<I>x</I><SUB><I>j</I></SUB>,<I>y</I><SUB><I>j</I></SUB>) avec :<BR>
<I>x</I>=[1,2,3,4], <I>y</I>=[1,4,9,16], et <I>n</I>=[3,1,5,2]<BR>
On tape :
</P><DIV CLASS="center"><TT>linear_regression([1,2,3,4],[1,4,9,16],[3,1,5,2])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>(331/70, -22/5)</TT></DIV><P>
c’est donc la fonction linéaire d’équation <I>y</I>=331*<I>x</I>/70−22/5 
qui approche au mieux les données.<BR>

On suppose qu’il y a <I>n</I><SUB><I>j</I>,<I>k</I></SUB> couples (<I>x</I><SUB><I>j</I></SUB>,<I>y</I><SUB><I>k</I></SUB>) avec :<BR>
<I>x</I>=[1,2], <I>y</I>=[11,13,14], et <I>n</I>=[[3,4,5],[12,1,2]]<BR>
On tape :
</P><DIV CLASS="center"><TT>linear_regression([1,2],[11,13,14],[[3,4,5],[12,1,2]])</TT></DIV><P>
Ou on tape :
</P><DIV CLASS="center"><TT>linear_regression([["x\y",11,13,14],[1,3,4,5], [2,12,1,2]],-1)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>(-83/60,143/10)</TT></DIV><P>
c’est donc la fonction linéaire d’équation <I>y</I>=−83*<I>x</I>/60+143/10 
qui approche au mieux les données.
On calcule le coefficient de corrélation
On tape :
</P><DIV CLASS="center"><TT>normal(correlation([1,2],[11,13,14],[[3,4,5],[12,1,2]])</TT><CODE><TT>2</TT></CODE><TT>)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>6889/25600</TT></DIV><P>
Donc <I>R</I>2 ≃ 0.2691015625 ce qui ne justifie pas un ajustement linéaire.</P><H3 CLASS="subsection"><A NAME="htoc53">1.11.6</A>  Ajustement linéaire et corrélation linéaire</H3><P>
Si <I>R</I>2 est le carré du coefficient de corrélation linéaire de <I>X</I> et de
<I>Y</I> si <I>m</I>1 (resp <I>m</I>2) est la pente de la première (resp deuxième) droite 
de régression linéaire on a :
</P><DIV CLASS="center"><TT>R2=m1*m2</TT></DIV><P>
On sait que le coefficient de correlation est un réel entre -1 et 1 donc
0 ≤ <I>R</I>2 ≤ 1. La valeur de <I>R</I>2 va nous dire si la forme du nuage de 
points justifie un ajustement lineaire. Il y a une forte corrélation 
linéaire lorsque √<SPAN style="text-decoration:overline">1−<I>R</I>2</SPAN> ≤ 0.5 i.e. lorsque <I>R</I>2 ≥ 0.75.<BR>
On a :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>R</I>2=0, l’ajustement lineaire n’est pas justifié<BR>
cela n’exclut pas une dépendance entre <I>X</I> et <I>Y</I> l’ensemble des 
points <I>M</I>−<I>j</I>,<I>k</I> peut être voisin d’une courbe, mais l’ensemble des points ne
peut pas être ajusté par une droite,
</LI><LI CLASS="li-itemize">Si <I>R</I>2&lt;0.75, l’ajustement lineaire est bon<BR>
</LI><LI CLASS="li-itemize">Si <I>R</I>2 ≥ 0.75, l’ajustement lineaire n’est pas bon<BR>
</LI><LI CLASS="li-itemize">Si <I>R</I>2=1 les points sont alignés et les deux droites de régression sont confondues.
</LI></UL><H3 CLASS="subsection"><A NAME="htoc54">1.11.7</A>  Le graphe de la régression linéaire : <TT>linear_regression_plot</TT></H3><P><A NAME="@default27"></A>
Pour dessiner la droite des moindres carrés : la droite qui approche au mieux
les données et qui a pour 
équation <I>y</I>=<I>mx</I>+<I>b</I>, on utilise <TT>linear_regression_plot</TT>.<BR>
<TT>linear_regression_plot</TT> a les mêmes arguments que <TT>covariance</TT>.<BR>
On tape :
</P><DIV CLASS="center"><TT>linear_regression_plot([1,2,3,4],[1,4,9,16],[3,1,5,2])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Le graphe de la droite d’équation </TT><TT><I>y</I>=331*<I>x</I>/70-22/5</TT><TT> ou </TT><TT><I>y</I>=4.3*<I>x</I>-4.4</TT><TT> et </TT><TT><I>R</I>2=0.966</TT></DIV><P>
c’est donc la fonction linéaire d’équation <I>y</I>=331*<I>x</I>/70−22/5 qui approche 
au mieux les données.</P><H3 CLASS="subsection"><A NAME="htoc55">1.11.8</A>  La régression linéaire à 2 ou plusieurs variables</H3><P><A NAME="sec:linreg2"></A>
</P><H4 CLASS="subsubsection">Le principe</H4><P>
Supposons que l’on observe 3 variables <TT>(X,Y,Z)</TT>, et que l’on veut savoir 
comment <TT>Z</TT> dépend linéairement de <TT>X</TT> et de <TT>Y</TT>.<BR>
On a par exemple observé <I>n</I> triplés <I>x</I><SUB><I>j</I></SUB>,<I>y</I><SUB><I>j</I></SUB>,<I>z</I><SUB><I>j</I></SUB> pour <I>j</I>=0..<I>n</I>−1. On 
cherche <I>c</I>,<I>a</I>,<I>b</I> pour que le plan <I>z</I>=<I>a</I>*<I>x</I>+<I>b</I>*<I>y</I>+<I>c</I> approche au mieux les 
données.<BR>
Posons <I>E</I>=∑<SUB><I>j</I>=0</SUB><SUP><I>n</I>−1</SUP> (<I>z</I><SUB><I>j</I></SUB>−<I>a</I>*<I>x</I><SUB><I>j</I></SUB>−<I>b</I>*<I>y</I><SUB><I>j</I></SUB>−<I>c</I>)<SUP>2</SUP>.<BR>
On cherche <I>c</I>,<I>a</I>,<I>b</I> pour que <I>E</I> soit minimum c’est à dire pour que :<BR>
∂ <I>E</I>/∂ <I>a</I>=−2*∑<SUB><I>j</I>=0</SUB><SUP><I>n</I>−1</SUP> <I>x</I><SUB><I>j</I></SUB>*(<I>z</I><SUB><I>j</I></SUB>−<I>a</I>*<I>x</I><SUB><I>j</I></SUB>−<I>b</I>*<I>y</I><SUB><I>j</I></SUB>−<I>c</I>)=0<BR>
∂ <I>E</I>/∂ <I>b</I>=−2*∑<SUB><I>j</I>=0</SUB><SUP><I>n</I>−1</SUP> <I>y</I><SUB><I>j</I></SUB>*(<I>z</I><SUB><I>j</I></SUB>−<I>a</I>*<I>x</I><SUB><I>j</I></SUB>−<I>b</I>*<I>y</I><SUB><I>j</I></SUB>−<I>c</I>)=0<BR>
∂ <I>E</I>/∂ <I>c</I>=−2*∑<SUB><I>j</I>=0</SUB><SUP><I>n</I>−1</SUP> (<I>z</I><SUB><I>j</I></SUB>−<I>a</I>*<I>x</I><SUB><I>j</I></SUB>−<I>b</I>*<I>y</I><SUB><I>j</I></SUB>−<I>c</I>)=0<BR>
On a donc à résoudre un système de 3 équations à 3 inconnues 
<I>c</I>,<I>a</I>,<I>b</I>.<BR>
Soit <I>U</I> la matrice de <I>n</I> lignes et 3 colonnes ayant comme ligne <I>j</I> :
[1,<I>x</I><SUB><I>j</I></SUB>,<I>y</I><SUB><I>j</I></SUB>] avec <I>j</I>=0..<I>n</I>−1.<BR>
Le système à résoudre est :<BR>
[
</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>n</I></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>y</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB><SUP>2</SUP></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB><I>y</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>y</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB><I>y</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>y</I><SUB><I>j</I></SUB><SUP>2</SUP></TD></TR>
</TABLE><P>
]
[
</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>c</I></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>a</I></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>b</I></TD></TR>
</TABLE><P>
]
=
[
</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>z</I><SUB><I>j</I></SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB> <I>z</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>y</I><SUB><I>j</I></SUB> <I>z</I><SUB><I>j</I></SUB></TD></TR>
</TABLE><P>
]
=<TT>tran(U)</TT>
[
</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>z</I><SUB>0</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>....</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>z</I><SUB><I>n</I>−1</SUB></TD></TR>
</TABLE><P>
]</P><P>On remarque que la matrice associée au système précédent s’écrit :<BR>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT><I>A</I>=<I>tran</I>(<I>U</I>)*<I>U</I></TT>=</TD><TD CLASS="dcell">⎡<BR>
⎢<BR>
⎢<BR>
⎣</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>n</I></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>y</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB><SUP>2</SUP></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB><I>y</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>y</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>x</I><SUB><I>j</I></SUB><I>y</I><SUB><I>j</I></SUB></TD><TD ALIGN=center NOWRAP><FONT SIZE=6>∑</FONT><I>y</I><SUB><I>j</I></SUB><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎤<BR>
⎥<BR>
⎥<BR>
⎦</TD></TR>
</TABLE><P>
La solution <I>c</I>,<I>a</I>,<I>b</I> du système est donc :
<TT>inv(A)*tran(U)*Z</TT>
</P><H4 CLASS="subsubsection">Avec le tableur</H4><P>
Suppopsons que l’on a mis les données, dans le tableur (par exemple <I>n</I>=192)
comme ceci :<BR>
- en <TT>A</TT> une colonne remplit avec des <TT>1</TT>,<BR>
- en <TT>B</TT> une colonne remplit avec les <I>x</I><SUB><I>j</I></SUB> et représentant 
<TT>X</TT>,<BR>
- en <TT>C</TT> une colonne remplit avec les <I>y</I><SUB><I>j</I></SUB> et représentant 
<TT>Y</TT>,<BR>
- en <TT>D</TT> une colonne remplit avec les <I>z</I><SUB><I>j</I></SUB> et représentant 
<TT>Z</TT>.<BR>
Dans la case de sélection on marque :<BR>
<TT>A0..A191,B,C</TT><BR>
On utilise le menu du tableur 
<TT>Fich</TT><TT><I>blacktriangleright</I></TT><TT>Sauver selection vers variable</TT>
et on tape <TT>U</TT> comme nom de variable. Cela définira la matrice <TT>U</TT>
égale à la sélection.<BR>
Puis, on met dans la case de sélection <TT>D0..D191</TT> et on utilise à 
nouveau le menu du tableur 
<TT>Fich</TT><TT><I>blacktriangleright</I></TT><TT>Sauver selection vers variable</TT>
et on tape <TT>Z</TT> comme nom de variable. Cela définira le vecteur <TT>Z</TT>
égale à la sélection.<BR>
On définit <TT>A</TT> en tapant : <TT>A:=tran(U)*U</TT><BR>
Il ne reste plus qu’à taper dans une ligne de commande :<BR>
<TT>(c,a,b):=col(inv(A)*tran(U)*Z,0)</TT><BR>
pour définir <TT>c,a,b</TT>.<BR>
<B>Remarque</B><BR>
Bien sûr il faut que la matrice <TT>A=tran(U)*U</TT> soit inversible !!!!<BR>
On peut aussi taper :<BR>
<TT>B:=border(A,op(-tran(Z)*U))</TT> puis<BR>
<TT>C:=rref(B)</TT>,
puis résoudre <TT>C*[[c],[a],[b]]=0</TT>.</P><H3 CLASS="subsection"><A NAME="htoc56">1.11.9</A>  La régression exponentielle : <TT>exponential_regression</TT></H3><P><A NAME="@default28"></A><A NAME="sec:expreg"></A>
Pour approcher les données par une fonction exponnentielle qui a pour
équation <I>y</I>=<I>b</I>*exp(<I>m</I>*<I>x</I>)=<I>b</I>*<I>a</I><SUP><I>x</I></SUP>, on utilise <TT>exponential_regression</TT>.<BR>
 <TT>exponential_regression</TT> a les mêmes arguments que <TT>covariance</TT>.<BR>
Si <TT>exponential_regression</TT> a comme argument la liste <TT>X</TT> des <I>x</I><SUB><I>j</I></SUB> 
et la liste <TT>Y</TT>
des <I>y</I><SUB><I>j</I></SUB>, <TT>exponential_regression</TT> renvoie (<I>a</I>, <I>b</I>) tel que 
<I>y</I> ≃ <I>ba</I><SUP><I>x</I></SUP>.<BR>
On tape dans la case <TT>C1</TT> :
</P><DIV CLASS="center"><TT>evalf(exponential_regression(A1:A4,B1:B4))</TT></DIV><P>
ou on tape dans une ligne d’entrée :
</P><DIV CLASS="center"><TT>exponential_regression([[1.0,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>2.49146187923,0.5</TT></DIV><P>
On tape dans une ligne d’entrée :
</P><DIV CLASS="center"><TT>exponential_regression([0,1,2,3,4,5,6,7,8,9,10],[7.3, 9.53,12.47,16.3,21.24,27.73,36.22,47.31,61.78,80.68,105])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>(1.30568684451, 7.30853268031)</TT></DIV><P>
c’est donc la fonction expopnentielle d’équation :<BR>
<I>y</I>=7.30853268031*(1.30568684451)<SUP><I>x</I></SUP> qui approche au mieux les données.<BR>
<B>Remarque</B><BR>
On a :<BR>
exp(0.266729219953,1.989042525894)=(1.30568684451, 7.30853268031)
</P><H3 CLASS="subsection"><A NAME="htoc57">1.11.10</A>  Le graphe de la régression exponentielle : <TT>exponential_regression_plot</TT></H3><P><A NAME="@default29"></A>
Pour dessiner la fonction exponnentielle qui a pour
équation <I>y</I>=<I>b</I>*exp(<I>m</I>*<I>x</I>)=<I>b</I>*<I>a</I><SUP><I>x</I></SUP>, et qui approche au mieux les données, on 
utilise <TT>exponential_regression_plot</TT>.<BR>
 <TT>exponential_regression_plot</TT> a les mêmes arguments que 
<TT>covariance</TT>.<BR>
On tape dans l’écran <TT>geo</TT> :
</P><DIV CLASS="center"><TT>exponential_regression_plot([0,1,2,3,4,5,6,7,8,9,10],[7.3, 9.53,12.47,16.3,21.24,27.73,36.22,47.31,61.78,80.68,105])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Le graphe de la fonction expopnentielle d’équation 
</TT><TT><I>y</I>=7.30853268031*(1.30568684451)</TT><SUP><TT><I>x</I></TT></SUP></DIV><P>
car c’est la fonction expopnentielle d’équation :<BR>
<I>y</I>=7.30853268031*(1.30568684451)<SUP><I>x</I></SUP> qui approche au mieux les données.
</P><H3 CLASS="subsection"><A NAME="htoc58">1.11.11</A>  La régression logarithmique : <TT>logarithmic_regression</TT></H3><P><A NAME="@default30"></A>
Pour approcher les données par une fonction logarithmique qui a pour 
équation <I>y</I>=<I>m</I> ln<I>x</I>+<I>b</I>, on utilise <TT>logarithmic_regression</TT>.<BR>
<TT>logarithmic_regression</TT> a les mêmes arguments que <TT>covariance</TT>.<BR>
Si <TT>logarithmic_regression</TT> a comme argument la liste <TT>X</TT> des <I>x</I><SUB><I>j</I></SUB> et
la liste <TT>Y</TT> des <I>y</I><SUB><I>j</I></SUB>, <TT>logarithmic_regression</TT> renvoie (<I>m</I>, <I>b</I>) tel 
que <I>y</I> ≃ <I>m</I> *ln<I>x</I>+<I>b</I>.<BR>
On tape dans la case <TT>C2</TT> :
</P><DIV CLASS="center"><TT>evalf(logarithmic_regression(A1:A4,B1:B4))</TT></DIV><P>
ou on tape dans une ligne d’entrée :
</P><DIV CLASS="center"><TT>evalf(logarithmic_regression([[1,1],[2,4],[3,9],[4,16]]))</TT></DIV><P>
ou on tape dans une ligne d’entrée :
</P><DIV CLASS="center"><TT>logarithmic_regression([[1.0,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>10.1506450002,-0.564824055818</TT></DIV><P>
c’est donc la fonction logarithme d’équation :<BR>
<I>y</I>=10.1506450002ln(<I>x</I>)−0.564824055818<BR>
qui approche au mieux les données.
</P><H3 CLASS="subsection"><A NAME="htoc59">1.11.12</A>  Le graphe de la régression logarithmique : <TT>logarithmic_regression_plot</TT></H3><P><A NAME="@default31"></A>
Pour dessiner le graphe de la fonction logarithmique qui a pour 
équation <I>y</I>=<I>m</I> ln<I>x</I>+<I>b</I>, et qui approche au mieux les données, on utilise 
<TT>logarithmic_regression_plot</TT>.<BR>
<TT>logarithmic_regression_plot</TT> a les mêmes arguments que 
<TT>covariance</TT>.<BR>
On tape dans l’écran <TT>geo</TT> :
</P><DIV CLASS="center"><TT>logarithmic_regression_plot([[1.0,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Le graphe de la fonction logarithme d’équation </TT><TT><I>y</I>=10.1506450002</TT><TT>ln</TT><TT>(<I>x</I>)-0.564824055818</TT></DIV><P>
car c’est la fonction logarithme d’équation :<BR>
<I>y</I>=10.1506450002ln(<I>x</I>)−0.564824055818<BR>
qui approche au mieux les données.</P><H3 CLASS="subsection"><A NAME="htoc60">1.11.13</A>  La régression polynomiale : <TT>polynomial_regression</TT></H3><P><A NAME="@default32"></A>
Pour approcher les données par une fonction polynomiale d’équation
<I>y</I>=<I>a</I><SUB>0</SUB><I>x</I><SUP><I>n</I></SUP>+..+<I>a</I><SUB><I>n</I></SUB>, on utilise <TT>polynomial_regression</TT>.<BR>
<TT>polynomial_regression</TT> a les mêmes arguments que <TT>covariance</TT>.<BR>
Si <TT>polynomial_regression</TT> a comme arguments la liste des <I>x</I><SUB><I>j</I></SUB>, la liste
des <I>y</I><SUB><I>j</I></SUB> et le degré <I>n</I> du polynôme, <TT>polynomial_regression</TT>
renvoie [<I>a</I><SUB><I>n</I></SUB>,..., <I>a</I><SUB>0</SUB>]) tel que <I>y</I> ≃ <I>a</I><SUB><I>n</I></SUB>*<I>x</I><SUP><I>n</I></SUP>+....+<I>a</I><SUB>0</SUB>.<BR>
On tape dans le tableur :
</P><DIV CLASS="center"><TT>evalf(polynomial_regression(A1:A4,B1:B4,3))</TT></DIV><P>
ou on tape dans une ligne d’entrée :
</P><DIV CLASS="center"><TT>evalf(polynomial_regression([[1,1],[2,4],[3,9],[4,16]],3))</TT></DIV><P>
ou on tape dans une ligne d’entrée :
</P><DIV CLASS="center"><TT>polynomial_regression([[1.0,1],[2,4],[3,9],[4,16]],3)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[0.0,1.0,0.0,0.0]</TT></DIV><P>
c’est donc le polynôme d’équation <I>y</I>=<I>x</I><SUP>2</SUP> qui approche au mieux 
les données.
</P><H3 CLASS="subsection"><A NAME="htoc61">1.11.14</A>  La régression puissance : <TT>power_regression</TT></H3><P><A NAME="@default33"></A>
Pour approcher les données par une fonction puissance d’équation
<I>y</I>=<I>bx</I><SUP><I>m</I></SUP>, on utilise <TT>power_regression</TT>.<BR>
<TT>power_regression</TT> a les mêmes arguments que <TT>covariance</TT>.<BR>
Si <TT>power_regression</TT> a comme argument la liste des <I>x</I><SUB><I>j</I></SUB> et la liste
des <I>y</I><SUB><I>j</I></SUB>, <TT>power_regression</TT> renvoie (<I>m</I>, <I>b</I>) tel que <I>y</I> ≃ <I>bx</I><SUP><I>m</I></SUP>.<BR>
On tape dans le tableur :
</P><DIV CLASS="center"><TT>evalf(power_regression(A1:A4,B1:B4))</TT></DIV><P>
ou on tape ddans une ligne d’entrée :
</P><DIV CLASS="center"><TT>evalf(power_regression([[1,1],[2,4],[3,9],[4,16]]))</TT></DIV><P>
ou on tape dans une ligne d’entrée :
</P><DIV CLASS="center"><TT>power_regression([[1.0,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[2.0,1.0]</TT></DIV><P>
c’est donc la fonction puissace d’équation <I>y</I>=1*<I>x</I><SUP>2</SUP> qui approche au mieux 
les données.
</P><H3 CLASS="subsection"><A NAME="htoc62">1.11.15</A>  Le graphe de la régression puissance : <TT>power_regression_plot</TT></H3><P><A NAME="@default34"></A>
Pour approcher les données par une fonction puissance d’équation
<I>y</I>=<I>bx</I><SUP><I>m</I></SUP>, on utilise <TT>power_regression_plot</TT>.<BR>
<TT>power_regression_plot</TT> a les mêmes arguments que <TT>covariance</TT>.<BR>
On tape dans l’écran <TT>geo</TT> :
</P><DIV CLASS="center"><TT>power_regression_plot([[1.0,1],[2,4],[3,9],[4,16]])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>Le graphe de la fonction puissace d’équation </TT><TT><I>y</I>=1*<I>x</I></TT><SUP><TT>2</TT></SUP></DIV><P>
car c’est la fonction puissace d’équation <I>y</I>=1*<I>x</I><SUP>2</SUP> qui approche au mieux 
les données.
</P><H2 CLASS="section"><A NAME="toc12"></A><A NAME="htoc63">1.12</A>  Définition de fonctions de <TT>Xcas</TT></H2><H3 CLASS="subsection"><A NAME="htoc64">1.12.1</A>  Définition de fonction de répartition</H3><P>
<B>Définition</B><BR>
On appelle fonction de répartition d’une variable aléatoire <I>x</I> sur 
l’espace probabilisé Ω la fonction <I>F</I> définie pour tout <I>x</I> réel 
par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>(<I>x</I>)=<I>Prob</I>(<I>X</I>≤ <I>x</I>)</TD></TR>
</TABLE><P>
<B>Propriétés</B><BR>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>F</I> est croissante,
</LI><LI CLASS="li-itemize">lim<SUB><I>x</I>−&gt;−∞</SUB>=0,
</LI><LI CLASS="li-itemize">lim<SUB><I>x</I>−&gt;+∞</SUB>=1,
</LI><LI CLASS="li-itemize"><I>Prob</I>(<I>a</I>&lt; <I>X</I>≤ <I>b</I>)=<I>F</I>(<I>b</I>)−<I>F</I>(<I>a</I>).
</LI></UL><P>
<B>Définition</B><BR>
On dit qu’une variable aléatoire <I>X</I> est absolument continue si et seulement 
si il existe une fonction <I>f</I>, appelée densité de probabilité de <I>X</I>,
telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>(<I>x</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">−∞</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>f</I>(<I>t</I>)<I>dt</I></TD></TR>
</TABLE><H3 CLASS="subsection"><A NAME="htoc65">1.12.2</A>  Les fonctions de répartition et de répartition inverse</H3><P>
<B>Règle</B><BR>
Le nom de la fonction de répartition 
d’une loi est le nom de la loi, suivi par <TT>_cdf</TT>, et pour la fonction de 
répartition inverse par <TT>_icdf</TT> : <TT>cdf</TT> =cumulated distribution 
function = fonction de répartition.<BR>
Les premiers paramètres sont les paramètres de la loi et le dernier 
paramètre le nom de la variable.<BR>
On définit les fonctions suivantes :<BR>
<TT>normald(t)</TT> par  exp(−(<I>t</I><SUP>2</SUP>)/2)/√<SPAN style="text-decoration:overline">2*<I>pi</I></SPAN><BR>
<TT>normald(</TT><TT>µ,σ</TT><TT>,t)</TT> par  1/σ√<SPAN style="text-decoration:overline">2π</SPAN>exp(−1/2((<I>t</I>−µ)/σ)<SUP>2</SUP>)<BR>
<TT>normal_cdf(x)</TT>= <I>Proba</I>(<I>X</I>≤ <I>x</I>) avec <I>X</I>∈ <FONT COLOR=red><I>N</I></FONT>(0,1) : c’est la 
fonction de répartition de la loi normale centrée réduite.<BR>
<TT>normal_icdf(t)</TT> =<I>h</I> équivaut à <I>Proba</I>(<I>X</I>≤ <I>h</I>)=<I>t</I> avec 
<I>X</I>∈ <FONT COLOR=red><I>N</I></FONT>(0,1) : c’est l’inverse de la fonction de répartition de la 
loi normale centrée réduite.<BR>
<TT>normal_cdf(</TT><TT>µ,σ</TT><TT>,x)</TT>=<I>Proba</I>(<I>X</I>≤ <I>x</I>) avec <I>X</I>∈ <FONT COLOR=red><I>N</I></FONT>(µ,σ) :
c’est la fonction de répartition de la loi normale
de moyenne µ et d’écart-type σ.<BR>
<TT>normal_icdf(</TT><TT>µ,σ</TT><TT>,t)</TT> =<I>h</I> équivaut à <I>Proba</I>(<I>X</I>≤ <I>h</I>)=<I>t</I> avec
<I>X</I>∈ <FONT COLOR=red><I>N</I></FONT>(µ,σ) : c’est l’inverse de la fonction de 
répartition de la loi normale de moyenne µ et d’écart-type σ.<BR>
<TT>normal_cdf(a,b)</TT>=<TT>normal_cdf(b)-normal_cdf(a)</TT><BR>
<TT>normal_cdf(</TT><TT>µ,σ</TT><TT>,a,b)</TT>=<TT>normal_cdf(</TT><TT>µ,σ</TT><TT>,b)-normal_cdf(</TT><TT>µ,σ</TT><TT>,a)</TT><BR>
<TT>binomial(n,k,p)=comb(n,k)*p</TT><CODE><TT>^</TT></CODE><TT>k*(1-p)</TT><CODE><TT>^</TT></CODE><TT>n-k</TT><BR>
<TT>binomial_cdf(n,p,x)</TT>=<I>Proba</I>(<I>X</I> ≤ <I>x</I>) avec <I>X</I>∈ <FONT COLOR=red><I>B</I></FONT>(<I>n</I>,<I>p</I>) :
c’est la fonction de répartition de la loi binomiale
de paramètre <I>n</I>,<I>p</I> c’est à dire
de moyenne <I>np</I> et d’écart-type √<SPAN style="text-decoration:overline"><I>np</I>(1−<I>p</I>)</SPAN>.<BR>
<TT>binomial_icdf(n,p,t)</TT>= <I>h</I> équivaut à <I>Proba</I>(<I>X</I>≤ <I>h</I>)=<I>t</I> avec 
<I>X</I>∈ <FONT COLOR=red><I>B</I></FONT>(<I>n</I>,<I>p</I>) : c’est l’inverse de la 
fonction de répartition de la loi 
binomiale de paramètres <I>n</I> et <I>p</I> c’est à dire
de moyenne <I>np</I> et d’écart-type √<SPAN style="text-decoration:overline"><I>np</I>(1−<I>p</I>)</SPAN>.<BR>
<TT>poisson(m,k)= exp(-m)*m</TT><CODE><TT>^</TT></CODE><TT>k/k!</TT><BR>
<TT>poisson_cdf(</TT><TT>µ</TT><TT>,x)</TT>=<I>Proba</I>(<I>X</I>≤ <I>x</I>) avec <I>X</I>∈ <FONT COLOR=red><I>P</I></FONT>(µ) : 
c’est la fonction de répartition de la loi de Poisson de paramètre µ,
c’est à dire de moyenne µ et d’écart-type µ.<BR>
<TT>poisson_cdf(</TT><TT>µ</TT><TT>,x1,x2)=poisson_cdf(</TT><TT>µ</TT><TT>,x2)-poisson_cdf(</TT><TT>µ</TT><TT>,x1)</TT><BR>
<TT>poisson_icdf(</TT><TT>µ</TT><TT>,t)</TT>= <I>h</I> équivaut à <I>Proba</I>(<I>X</I>≤ <I>h</I>)=<I>t</I> avec 
<I>X</I>∈ <FONT COLOR=red><I>P</I></FONT>(µ) : c’est l’inverse de la fonction de répartition de 
la loi de Poisson de paramètre µ, c’est à dire de moyenne µ et 
d’écart-type µ.<BR>
<TT>student_cdf(n,x)</TT>=<I>Proba</I>(<I>X</I>≤ <I>x</I>) avec <I>X</I>∈ <FONT COLOR=red><I>T</I></FONT>(<I>n</I>) : c’est la 
fonction de répartition de la loi de Student
ayant <I>n</I> degrés de liberté.<BR>
<TT>student_icdf(n,t)</TT>=<I>h</I> équivaut à <I>Proba</I>(<I>X</I>≤ <I>h</I>)=<I>t</I> avec 
<I>X</I>∈ <FONT COLOR=red><I>T</I></FONT>(<I>n</I>) : c’est l’inverse de la fonction de répartition de la 
loi de Student ayant <I>n</I> degrés de liberté.<BR>
<TT>chisquare_cdf(n,x)</TT>=<I>Proba</I>(<I>X</I>≤ <I>x</I>) avec <I>X</I>∈ <FONT COLOR=red>χ</FONT><SUP>2</SUP>(<I>n</I>) : 
c’est la fonction de répartition de la loi du χ<SUP>2</SUP>
ayant <I>n</I> degrés de liberté.<BR>
<TT>chisquare_icdf(n,t)</TT>=<I>h</I> équivaut à <I>Proba</I>(<I>X</I>≤ <I>h</I>)=<I>t</I> avec 
<I>X</I>∈ <FONT COLOR=red>χ</FONT><SUP>2</SUP>(<I>n</I>) : c’est l’inverse de la fonction de répartition de 
la loi du χ<SUP>2</SUP> ayant <I>n</I> degrés de liberté.<BR>
<TT>fisher_cdf(n,k,x)</TT>=<TT>snedecor_cdf(n,k,x)</TT>=<I>Proba</I>(<I>X</I>≤ <I>x</I>) lorsque 
<I>X</I>∈ <FONT COLOR=red><I>F</I></FONT>(<I>n</I>,<I>k</I>) : c’est 
la fonction de répartition de la loi de Fisher ayant <I>n</I>,<I>k</I> degrés de 
liberté.<BR>
<TT>fisher_icdf(n,k,t)</TT>=<TT>snedecor_icdf(n,k,t)</TT>=<I>h</I> ce qui veut dire que
<I>Proba</I>(<I>X</I>≤ <I>h</I>)=<I>t</I> avec 
<I>X</I>∈ <FONT COLOR=red><I>F</I></FONT>(<I>n</I>,<I>k</I>) : c’est l’inverse de la fonction de répartition de la 
loi de Fisher ayant <I>n</I>,<I>k</I> degrés de liberté.<BR>
<TT>UTPC,UTPF,UTPN,UTPT</TT> avec <TT>C</TT> pour χ<SUP>2</SUP>, <TT>F</TT> pour Fisher, 
<TT>N</TT> pour Normale et <TT>S</TT> pour Student représentent le complément à
1 de la fonction de répartition correspondante.<BR>
Par exemple :<BR>
<TT>UTPN(x)=1-normal_cdf(x)</TT><BR>
Mais attention : <TT>UTPN(</TT><TT>µ ,σ</TT><SUP><TT>2</TT></SUP><TT>,x)=1-normal_cdf(</TT><TT>µ ,σ</TT><TT>,x)</TT> </P><HR>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="cassim002.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
