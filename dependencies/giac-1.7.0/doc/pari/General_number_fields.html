<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Catalogue of GP/PARI Functions: General number fields</title>

  <meta name="author"       content="Karim Belabas">
  <meta name="created"      content="Wed Jan 22 18:53:36 2020">
  <meta name="author-email" content="pari@math.u-bordeaux.fr">
  <meta name="keywords"     content="PARI, GP, DOC">
  
  <link rel="stylesheet" href="/pari.css">
  <link rel="stylesheet" href="./gphtml.css">
</head>
<body >
<h2 class="center">General number fields</h2>

<p></p>
<p></p>
<p>In this section, we describe functions related to general number fields.
Functions related to quadratic number fields are found in
Section <a href="Arithmetic_functions.html#se:arithmetic"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">se:arithmetic</a> (Arithmetic functions).</p>
<p>
<hr>
<div id="Number_field_structures"></div>
<h4>Number field structures</h4>
<p></p>
<p></p>
<p>Let K = &Qopf;[X] / (T) a number field, &Zopf;<sub>K</sub> its ring of integers, T &in; &Zopf;[X]
is monic. Three basic number field structures can be attached to K in
GP:</p>
<p>
<b>*</b> <em>nf</em> denotes a number field, i.e.&nbsp;a data structure output by
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>. This contains the basic arithmetic data attached to the
number field: signature, maximal order (given by a basis <code>nf.zk</code>),
discriminant, defining polynomial T, etc.</p>
<p>
<b>*</b> <em>bnf</em> denotes a "Buchmann's number field", i.e.&nbsp;a
data structure output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>. This contains
<em>nf</em> and the deeper invariants of the field: units U(K), class group
Cl(K), as well as technical data required to solve the two attached
discrete logarithm problems.</p>
<p>
<b>*</b> <em>bnr</em> denotes a "ray number field", i.e.&nbsp;a data structure
output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>, corresponding to the ray class group structure of
the field, for some modulus f. It contains a <em>bnf</em>, the modulus
f, the ray class group Cl<sub>f</sub>(K) and data attached to
the discrete logarithm problem therein.</p>
<p>

<hr>
<div id="Algebraic_numbers_and_ideals"></div>
<h4>Algebraic numbers and ideals</h4>
<p></p>
<p></p>
<p>An <em>algebraic number</em> belonging to K = &Qopf;[X]/(T) is given as</p>
<p>
<b>*</b> a <code>t_INT</code>, <code>t_FRAC</code> or <code>t_POL</code> (implicitly modulo T), or</p>
<p>
<b>*</b> a <code>t_POLMOD</code> (modulo T), or</p>
<p>
<b>*</b> a <code>t_COL</code>&nbsp;<code>v</code> of dimension N = [K:&Qopf;], representing
the element in terms of the computed integral basis, as
<code>sum(i = 1, N,&nbsp;v[i] * nf.zk[i])</code>. Note that a <code>t_VEC</code>
will not be recognized.</p>
<p></p>
<p>
An <em>ideal</em> is given in any of the following ways:</p>
<p>
<b>*</b> an algebraic number in one of the above forms, defining a principal ideal.</p>
<p>
<b>*</b> a prime ideal, i.e.&nbsp;a 5-component vector in the format output by
<code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> or <code><a href="General_number_fields.html#se:idealfactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealfactor</a></code>.</p>
<p>
<b>*</b> a <code>t_MAT</code>, square and in Hermite Normal Form (or at least
upper triangular with non-negative coefficients), whose columns represent a
&Zopf;-basis of the ideal.</p>
<p>
One may use <code><a href="General_number_fields.html#se:idealhnf"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealhnf</a></code> to convert any ideal to the last (preferred) format.</p>
<p>
<b>*</b> an <em>extended ideal</em>  is a 2-component
vector [I, t], where I is an ideal as above and t is an algebraic
number, representing the ideal (t)I. This is useful whenever <code><a href="General_number_fields.html#se:idealred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealred</a></code>
is involved, implicitly working in the ideal class group, while keeping track
of principal ideals. The following multiplicative ideal operations
update the principal part: <code><a href="General_number_fields.html#se:idealmul"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealmul</a></code>, <code>idealsqr</code>, <code><a href="General_number_fields.html#se:idealinv"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealinv</a></code>,
<code><a href="General_number_fields.html#se:idealpow"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealpow</a></code> and <code><a href="General_number_fields.html#se:idealred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealred</a></code>; e.g.&nbsp;using <code><a href="General_number_fields.html#se:idealmul"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealmul</a></code>
on [I,t], [J,u], we obtain [IJ, tu]. In all other
functions, the extended part is silently discarded, e.g.&nbsp;using
<code><a href="General_number_fields.html#se:idealadd"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealadd</a></code> with the above input produces I+J.</p>
<p>
The "principal part" t in an extended ideal may be
represented in any of the above forms, and <em>also</em> as a factorization
matrix (in terms of number field elements, not ideals!), possibly the empty
factorization matrix <code>factor(1)</code> representing 1; the empty matrix
<code>[;]</code> is also accepted as a synonym for 1. When t is such a
factorization matrix, elements stay in
factored form, or <em>famat</em> for <em>fa</em>ctorization <em>mat</em>rix, which
is a convenient way to avoid coefficient explosion. To recover the
conventional expanded form, try <code><a href="General_number_fields.html#se:nffactorback"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nffactorback</a></code>; but many functions
already accept <em>famat</em>s as input, for instance <code><a href="General_number_fields.html#se:ideallog"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallog</a></code>, so
expanding huge elements should never be necessary.</p>
<p>

<hr>
<div id="Finite_abelian_groups"></div>
<h4>Finite abelian groups</h4>
<p></p>
<p></p>
<p>A finite abelian group G in user-readable format is given by its Smith
Normal Form as a pair [h,d] or triple [h,d,g].
Here h is the cardinality of G, (d<sub>i</sub>) is the vector of elementary
divisors, and (g<sub>i</sub>) is a vector of generators. In short,
G = &bigoplus; <sub>i &leq; n</sub> (&Zopf;/d<sub>i</sub>&Zopf;) g<sub>i</sub>, with d<sub>n</sub> | ... | d<sub>2</sub> | d<sub>1</sub>
and &prod; d<sub>i</sub> = h. This information can also be retrieved as
G.<code>no</code>, G.<code>cyc</code> and G.<code>gen</code>.</p>
<p>
<b>*</b> a <em>character</em> on the abelian group
&bigoplus;  (&Zopf;/d<sub>j</sub>&Zopf;) g<sub>j</sub>
is given by a row vector &chi; = [a<sub>1</sub>,...,a<sub>n</sub>] such that
&chi;(&prod; g<sub>j</sub><sup>n<sub>j</sub></sup>) = exp(2&pi; i&sum; a<sub>j</sub> n<sub>j</sub> / d<sub>j</sub>).</p>
<p>
<b>*</b> given such a structure, a <em>subgroup</em> H is input as a square
matrix in HNF, whose columns express generators of H on the given generators
g<sub>i</sub>. Note that the determinant of that matrix is equal to the index (G:H).</p>
<p>

<hr>
<div id="Relative_extensions"></div>
<h4>Relative extensions</h4>
<p></p>
<p></p>
<p>We now have a look at data structures attached to relative extensions
of number fields L/K, and to projective &Zopf;<sub>K</sub>-modules. When defining a
relative extension L/K, the <em>nf</em> attached to the base field K
must be defined by a variable having a lower priority (see
Section se:priority) than the variable defining the extension. For example,
you may use the variable name y to define the base field K, and x to
define the relative extension L/K.</p>
<p>

<hr>
<div id="se:CFT"></div>
<div id="Class_field_theory"></div>
<h4>Class field theory</h4>
<p></p>
<p>
A <em>modulus</em>, in the sense of class field theory, is a divisor supported
on the non-complex places of K. In PARI terms, this means either an
ordinary ideal I as above (no Archimedean component), or a pair [I,a],
where a is a vector with r<sub>1</sub> {0,1}-components, corresponding to the
infinite part of the divisor. More precisely, the i-th component of a
corresponds to the real embedding attached to the i-th real root of
<code>K.roots</code>. (That ordering is not canonical, but well defined once a
defining polynomial for K is chosen.) For instance, <code>[1, [1,1]]</code> is a
modulus for a real quadratic field, allowing ramification at any of the two
places at infinity, and nowhere else.</p>
<p>
A <em>bid</em> or "big ideal" is a structure output by <code><a href="General_number_fields.html#se:idealstar"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealstar</a></code>
needed to compute in (&Zopf;<sub>K</sub>/I)<sup>*</sup>, where I is a modulus in the above sense.
It is a finite abelian group as described above, supplemented by
technical data needed to solve discrete log problems.</p>
<p>
Finally we explain how to input ray number fields (or <em>bnr</em>), using class
field theory. These are defined by a triple A, B, C, where the
defining set [A,B,C] can have any of the following forms:
[<em>bnr</em>],
[<em>bnr</em>,<em>subgroup</em>],
[<em>bnr</em>,<em>character</em>],
[<em>bnf</em>,<em>mod</em>],
[<em>bnf</em>,<em>mod</em>,<em>subgroup</em>]. The last two forms are kept for
backward compatibility, but no longer serve any real purpose (see example
below); no newly written function will accept them.</p>
<p>
<b>*</b> <em>bnf</em> is as output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, where units are mandatory
unless the modulus is trivial; <em>bnr</em> is as output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>. This
is the ground field K.</p>
<p>
<b>*</b> <em>mod</em> is a modulus &ffr;, as described above.</p>
<p>
<b>*</b> <em>subgroup</em> a subgroup of the ray class group modulo &ffr; of
K. As described above, this is input as a square matrix expressing
generators of a subgroup of the ray class group <code><em>bnr</em>.clgp</code> on the
given generators.</p>
<p>
The corresponding <em>bnr</em> is the subfield of the ray class field of K
modulo &ffr;, fixed by the given subgroup.</p>
<p></p>
<p>
</p><pre class="code">    ? K = bnfinit(y^2+1);
    ? bnr = bnrinit(K, 13)
    ? %.clgp
    %3 = [36, [12, 3]]
    ? bnrdisc(bnr); \\ discriminant of the full ray class field
    ? bnrdisc(bnr, [3,1;0,1]); \\ discriminant of cyclic cubic extension of K
    ? bnrconductor(bnr, [3,1]); \\ conductor of chi: g1-&gt;zeta_12^3, g2-&gt;zeta<sub>3</sub>
</pre><p></p>
<p>
We could have written directly</p>
<p>
</p><pre class="code">    ? bnrdisc(K, 13);
    ? bnrdisc(K, 13, [3,1;0,1]);
</pre><p></p>
<p>
avoiding one <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>, but this would actually be slower since the
<code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code> is called internally anyway. And now twice!</p>
<p>

<hr>
<div id="General_use"></div>
<h4>General use</h4>
<p></p>
<p></p>
<p>All the functions which are specific to relative extensions, number fields,
Buchmann's number fields, Buchmann's number rays, share the prefix <code>rnf</code>,
<code>nf</code>, <code>bnf</code>, <code>bnr</code> respectively. They take as first argument a
number field of that precise type, respectively output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code>,
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, and <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>.</p>
<p>
However, and even though it may not be specified in the descriptions of the
functions below, it is permissible, if the function expects a <em>nf</em>, to
use a <em>bnf</em> instead, which contains much more information. On the other
hand, if the function requires a <code>bnf</code>, it will <em>not</em> launch
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> for you, which is a costly operation. Instead, it will give you
a specific error message. In short, the types
 <code>nf</code> &leq; <code>bnf</code> &leq; <code>bnr</code>
are ordered, each function requires a minimal type to work properly, but you
may always substitute a larger type.</p>
<p>
The data types corresponding to the structures described above are rather
complicated. Thus, as we already have seen it with elliptic curves, GP
provides "member functions" to retrieve data from these structures (once
they have been initialized of course). The relevant types of number fields
are indicated between parentheses: </p>
<p></p>
<p></p>
<p></p>
<p>&nbsp;<code>bid</code>     (<em>bnr</em> ) :   bid ideal structure.</p>
<p></p>
<p>&nbsp;<code>bnf</code>     (<em>bnr</em>,  <em>bnf</em> ) :   Buchmann's number field.</p>
<p></p>
<p>&nbsp;<code>clgp</code>   (<em>bnr</em>,  <em>bnf</em> ) :   classgroup. This one admits the
following three subclasses:</p>
<p></p>
<p>&nbsp;        <code>cyc</code>  :     cyclic decomposition
 (SNF).</p>
<p></p>
<p>&nbsp;        <code>gen</code>  :  
   generators.</p>
<p></p>
<p>&nbsp;        <code>no</code>   :     number of elements.</p>
<p></p>
<p>&nbsp;<code>diff</code>   (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the different ideal.</p>
<p></p>
<p>&nbsp;<code>codiff</code> (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the codifferent
(inverse of the different in the ideal group).</p>
<p></p>
<p>&nbsp;<code>disc</code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   discriminant.</p>
<p></p>
<p>&nbsp;<code>fu</code>    (<em>bnr</em>,  <em>bnf</em> ) :   fundamental units.</p>
<p></p>
<p>&nbsp;<code>index</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :  
 index of the power order in the ring of integers.</p>
<p></p>
<p>&nbsp;<code>mod</code>    (<em>bnr</em> ) :   modulus.</p>
<p></p>
<p>&nbsp;<code>nf</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   number field.</p>
<p></p>
<p>&nbsp;<code>pol</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   defining polynomial.</p>
<p></p>
<p>&nbsp;<code>r1</code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the number
of real embeddings.</p>
<p></p>
<p>&nbsp;<code>r2</code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the number
of pairs of complex embeddings.</p>
<p></p>
<p>&nbsp;<code>reg</code>   (<em>bnr</em>,  <em>bnf</em> ) :   regulator.</p>
<p></p>
<p>&nbsp;<code>roots</code> (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   roots of the
polynomial generating the field.</p>
<p></p>
<p>&nbsp;<code><a href="Standard_monadic_or_dyadic_operators.html#se:sign"
    onClick="parent.itemFrame.location='cont_Standard_monadic_or_dyadic_operators.html'">sign</a></code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   signature [r1,r2].</p>
<p></p>
<p>&nbsp;<code>t2</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the T<sub>2</sub> matrix (see
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>).</p>
<p></p>
<p>&nbsp;<code>tu</code>    (<em>bnr</em>,  <em>bnf</em> ) :   a generator for the torsion
units.</p>
<p></p>
<p>&nbsp;<code>zk</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   integral basis, i.e.&nbsp;a
&Zopf;-basis of the maximal order.</p>
<p></p>
<p>&nbsp;<code>zkst</code>    (<em>bnr</em> ) :   structure of (&Zopf;<sub>K</sub>/m)<sup>*</sup>.</p>
<p>
The member functions <code>.codiff</code>, <code>.t2</code> and <code>.zk</code> perform a
computation and are relatively expensive in large degree: move them out of
tight loops and store them in variables.</p>
<p>
<b>Deprecated.</b> The following member functions are still available, but deprecated and should not be used in new scripts :</p>
<p>&nbsp;<code>futu</code>  (<em>bnr</em>,  <em>bnf</em>, ) :  
 [u<sub>1</sub>,...,u<sub>r</sub>,w], (u<sub>i</sub>) is a vector of fundamental units,</p>
<p>&nbsp;  w generates the torsion units.</p>
<p></p>
<p>&nbsp;<code>tufu</code>  (<em>bnr</em>,  <em>bnf</em>, ) :  
 [w,u<sub>1</sub>,...,u<sub>r</sub>], (u<sub>i</sub>) is a vector of fundamental units,</p>
<p>&nbsp;  w generates the torsion units.</p>
<p>
  For instance, assume that <em>bnf</em> = <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>(<em>pol</em>), for some
polynomial. Then <code><em>bnf</em>.clgp</code> retrieves the class group, and
<code><em>bnf</em>.clgp.no</code> the class number. If we had set <em>bnf</em> = 
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>(<em>pol</em>), both would have output an error message. All these
functions are completely recursive, thus for instance
<code><em>bnr</em>.bnf.nf.zk</code> will yield the maximal order of <em>bnr</em>, which
you could get directly with a simple <code><em>bnr</em>.zk</code>.</p>
<p>

<hr>
<div id="se:GRHbnf"></div>
<div id="Class_group__units__and_the_GRH"></div>
<h4>Class group, units, and the GRH</h4>
<p></p>
<p>
Some of the functions starting with <code>bnf</code> are implementations of the
sub-exponential algorithms for finding class and unit groups under GRH,
due to Hafner-McCurley, Buchmann and Cohen-Diaz-Olivier. The general
call to the functions concerning class groups of general number fields
(i.e.&nbsp;excluding <code><a href="Arithmetic_functions.html#se:quadclassunit"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">quadclassunit</a></code>) involves a polynomial P and a
technical vector
<em>tech</em> = [c<sub>1</sub>, c<sub>2</sub>, <em>nrpid</em> ],
where the parameters are to be understood as follows:</p>
<p>
P is the defining polynomial for the number field, which must be in
&Zopf;[X], irreducible and monic. In fact, if you supply a non-monic polynomial
at this point, <code>gp</code> issues a warning, then <em>transforms your
polynomial</em> so that it becomes monic. The <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> routine
will return a different result in this case: instead of <code>res</code>, you get a
vector <code>[res,Mod(a,Q)]</code>, where <code>Mod(a,Q) = Mod(X,P)</code> gives the change
of variables. In all other routines, the variable change is simply lost.</p>
<p>
The <em>tech</em> interface is obsolete and you should not tamper with
these parameters. Indeed, from version 2.4.0 on,</p>
<p>
<b>*</b> the results are always rigorous under GRH (before that version,
they relied on a heuristic strengthening, hence the need for overrides).</p>
<p>
<b>*</b> the influence of these parameters on execution time and stack size is
marginal. They <em>can</em> be useful to fine-tune and experiment with the
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> code, but you will be better off modifying all tuning
parameters in the C code (there are many more than just those three).
We nevertheless describe it for completeness.</p>
<p>
The numbers c<sub>1</sub> &leq; c<sub>2</sub> are non-negative real numbers. By default they are
chosen so that the result is correct under GRH. For i = 1,2, let
B<sub>i</sub> = c<sub>i</sub>(log |d<sub>K</sub>|)^2, and denote by S(B) the set of maximal ideals of
K whose norm is less than B. We want S(B<sub>1</sub>) to generate Cl(K) and hope
that S(B<sub>2</sub>) can be <em>proven</em> to generate Cl(K).</p>
<p>
More precisely, S(B<sub>1</sub>) is a factorbase used to compute a tentative
Cl(K) by generators and relations. We then check explicitly, using
essentially <code><a href="General_number_fields.html#se:bnfisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisprincipal</a></code>, that the elements of S(B<sub>2</sub>) belong to the
span of S(B<sub>1</sub>). Under the assumption that S(B<sub>2</sub>) generates Cl(K), we
are done. User-supplied c<sub>i</sub> are only used to compute initial guesses for
the bounds B<sub>i</sub>, and the algorithm increases them until one can <em>prove</em>
under GRH that S(B<sub>2</sub>) generates Cl(K). A uniform result of Bach says
that c<sub>2</sub> = 12 is always suitable, but this bound is very pessimistic and a
direct algorithm due to Belabas-Diaz-Friedman is used to check the condition,
assuming GRH. The default values are c<sub>1</sub> = c<sub>2</sub> = 0. When c<sub>1</sub> is equal to
0 the algorithm takes it equal to c<sub>2</sub>.</p>
<p>
<em>nrpid</em> is the maximal number of small norm relations attached to each
ideal in the factor base. Set it to 0 to disable the search for small norm
relations. Otherwise, reasonable values are between 4 and 20. The default is
4.</p>
<p>
<b>Warning.</b> Make sure you understand the above! By default, most of
the <code>bnf</code> routines depend on the correctness of the GRH. In particular,
any of the class number, class group structure, class group generators,
regulator and fundamental units may be wrong, independently of each other.
Any result computed from such a <code>bnf</code> may be wrong. The only guarantee is
that the units given generate a subgroup of finite index in the full unit
group. You must use <code><a href="General_number_fields.html#se:bnfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfcertify</a></code> to certify the computations
unconditionally.</p>
<p>
<b>Remarks.</b></p>
<p>
You do not need to supply the technical parameters (under the library you
still need to send at least an empty vector, coded as <code>NULL</code>). However,
should you choose to set some of them, they <em>must</em> be given in the
requested order. For example, if you want to specify a given value of
<em>nrpid</em>, you must give some values as well for c<sub>1</sub> and c<sub>2</sub>, and provide
a vector [c<sub>1</sub>,c<sub>2</sub>,<em>nrpid</em>].</p>
<p>
Note also that you can use an <em>nf</em> instead of P, which avoids
recomputing the integral basis and analogous quantities.</p>
<p>

<hr>
<div id="se:bnfcertify"></div>
<div id="bnfcertify"></div>
<h4>bnfcertify(<em>bnf</em>, {<em>flag</em> = 0})</h4>
<p>
<em>bnf</em> being as output by
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, checks whether the result is correct, i.e.&nbsp;whether it is
possible to remove the assumption of the Generalized Riemann
Hypothesis. It is correct if and only if the answer is 1. If it is
incorrect, the program may output some error message, or loop indefinitely.
You can check its progress by increasing the debug level. The <em>bnf</em>
structure must contain the fundamental units:</p>
<p>
</p><pre class="code">  ? K = bnfinit(x^3+2^2^3+1); bnfcertify(K)
    ***   at top-level: K=bnfinit(x^3+2^2^3+1);bnfcertify(K)
    ***                                        ^ &mdash;  &mdash;  &mdash;  &mdash; -
    *** bnfcertify: missing units in bnf.
  ? K = bnfinit(x^3+2^2^3+1, 1); \\ include units
  ? bnfcertify(K)
  %3 = 1
</pre><p></p>
<p></p>
<p>
If flag is present, only certify that the class group is a quotient of the
one computed in bnf (much simpler in general); likewise, the computed units
may form a subgroup of the full unit group. In this variant, the units are
no longer needed:</p>
<p>
</p><pre class="code">  ? K = bnfinit(x^3+2^2^3+1); bnfcertify(K, 1)
  %4 = 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>bnfcertify0</b>(GEN bnf, long flag)</code>.
Also available is  <code>GEN <b>bnfcertify</b>(GEN bnf)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:bnfcompress"></div>
<div id="bnfcompress"></div>
<h4>bnfcompress(<em>bnf</em>)</h4>
<p>
Computes a compressed version of <em>bnf</em> (from <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>), a
"small Buchmann's number field" (or <em>sbnf</em> for short) which contains
enough information to recover a full <em>bnf</em> vector very rapidly, but
which is much smaller and hence easy to store and print. Calling
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> on the result recovers a true <code>bnf</code>, in general different
from the original. Note that an <em>snbf</em> is useless for almost all
purposes besides storage, and must be converted back to <em>bnf</em> form
before use; for instance, no <code>nf*</code>, <code>bnf*</code> or member function
accepts them.</p>
<p>
An <em>sbnf</em> is a 12 component vector v, as follows. Let <code>bnf</code> be
the result of a full <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, complete with units. Then v[1] is
<code>bnf.pol</code>, v[2] is the number of real embeddings <code>bnf.sign[1]</code>,
v[3] is <code>bnf.disc</code>, v[4] is <code>bnf.zk</code>, v[5] is the list of roots
<code>bnf.roots</code>, v[7] is the matrix <code>W</code> = <code>bnf[1]</code>,
v[8] is the matrix <code>matalpha</code> = <code>bnf[2]</code>,
v[9] is the prime ideal factor base <code>bnf[5]</code> coded in a compact way,
and ordered according to the permutation <code>bnf[6]</code>, v[10] is the
2-component vector giving the number of roots of unity and a generator,
expressed on the integral basis, v[11] is the list of fundamental units,
expressed on the integral basis, v[12] is a vector containing the algebraic
numbers alpha corresponding to the columns of the matrix <code>matalpha</code>,
expressed on the integral basis.</p>
<p>
All the components are exact (integral or rational), except for the roots in
v[5].</p>
<p>
The library syntax is <code>GEN <b>bnfcompress</b>(GEN bnf)</code>.</p>
<p>

<hr>
<div id="se:bnfdecodemodule"></div>
<div id="bnfdecodemodule"></div>
<h4>bnfdecodemodule(<em>nf</em>, m)</h4>
<p>
If m is a module as output in the
first component of an extension given by <code><a href="General_number_fields.html#se:bnrdisclist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrdisclist</a></code>, outputs the
true module.</p>
<p>
</p><pre class="code">  ? K = bnfinit(x^2+23); L = bnrdisclist(K, 10); s = L[1][2]
  %1 = [[Mat([8, 1]), [[0, 0, 0]]], [Mat([9, 1]), [[0, 0, 0]]]]
  ? bnfdecodemodule(K, s[1][1])
  %2 =
  [2 0]
  
  [0 1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>decodemodule</b>(GEN nf, GEN m)</code>.</p>
<p>

<hr>
<div id="se:bnfinit"></div>
<div id="bnfinit"></div>
<h4>bnfinit(P, {<em>flag</em> = 0}, {<em>tech</em> = []})</h4>
<p>
Initializes a
<code>bnf</code> structure. Used in programs such as <code><a href="General_number_fields.html#se:bnfisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisprincipal</a></code>,
<code><a href="General_number_fields.html#se:bnfisunit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisunit</a></code> or <code><a href="General_number_fields.html#se:bnfnarrow"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfnarrow</a></code>. By default, the results are conditional
on the GRH, see <a href="General_number_fields.html#se:GRHbnf"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:GRHbnf</a>. The result is a
10-component vector <em>bnf</em>.</p>
<p>
This implements Buchmann's sub-exponential algorithm for computing the
class group, the regulator and a system of fundamental units of the
general algebraic number field K defined by the irreducible polynomial P
with integer coefficients.</p>
<p>
If the precision becomes insufficient, <code>gp</code> does not strive to compute
the units by default (<em>flag</em> = 0).</p>
<p>
When <em>flag</em> = 1, we insist on finding the fundamental units exactly. Be
warned that this can take a very long time when the coefficients of the
fundamental units on the integral basis are very large. If the fundamental
units are simply too large to be represented in this form, an error message
is issued. They could be obtained using the so-called compact representation
of algebraic numbers as a formal product of algebraic integers. The latter is
implemented internally but not publicly accessible yet.</p>
<p>
<em>tech</em> is a technical vector (empty by default, see <a href="General_number_fields.html#se:GRHbnf"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:GRHbnf</a>).
Careful use of this parameter may speed up your computations,
but it is mostly obsolete and you should leave it alone.</p>
<p></p>
<p></p>
<p>
The components of a <em>bnf</em> or <em>sbnf</em> are technical and never used by
the casual user. In fact: <em>never access a component directly, always use
a proper member function.</em> However, for the sake of completeness and internal
documentation, their description is as follows. We use the notations
explained in the book by H. Cohen, <em>A Course in Computational Algebraic
Number Theory</em>, Graduate Texts in Maths <b>138</b>, Springer-Verlag, 1993,
Section 6.5, and subsection 6.5.5 in particular.</p>
<p>
<em>bnf</em>[1] contains the matrix W, i.e.&nbsp;the matrix in Hermite normal
form giving relations for the class group on prime ideal generators
(&pfr;<sub>i</sub>)<sub>1 &leq; i &leq; r</sub>.</p>
<p>
<em>bnf</em>[2] contains the matrix B, i.e.&nbsp;the matrix containing the
expressions of the prime ideal factorbase in terms of the &pfr;<sub>i</sub>.
It is an r x c matrix.</p>
<p>
<em>bnf</em>[3] contains the complex logarithmic embeddings of the system of
fundamental units which has been found. It is an (r<sub>1</sub>+r<sub>2</sub>) x (r<sub>1</sub>+r<sub>2</sub>-1)
matrix.</p>
<p>
<em>bnf</em>[4] contains the matrix M"<sub>C</sub> of Archimedean components of the
relations of the matrix (W|B).</p>
<p>
<em>bnf</em>[5] contains the prime factor base, i.e.&nbsp;the list of prime
ideals used in finding the relations.</p>
<p>
<em>bnf</em>[6] used to contain a permutation of the prime factor base, but
has been obsoleted. It contains a dummy 0.</p>
<p>
<em>bnf</em>[7] or <code><em>bnf</em>.nf</code> is equal to the number field data
<em>nf</em> as would be given by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>.</p>
<p>
<em>bnf</em>[8] is a vector containing the classgroup <code><em>bnf</em>.clgp</code>
as a finite abelian group, the regulator <code><em>bnf</em>.reg</code>, a 1 (used to
contain an obsolete "check number"), the number of roots of unity and a
generator <code><em>bnf</em>.tu</code>, the fundamental units <code><em>bnf</em>.fu</code>.</p>
<p>
<em>bnf</em>[9] is a 3-element row vector used in <code><a href="General_number_fields.html#se:bnfisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisprincipal</a></code> only
and obtained as follows. Let D = U W V obtained by applying the
Smith normal form algorithm to the matrix W ( = <em>bnf</em>[1]) and
let U<sub>r</sub> be the reduction of U modulo D. The first elements of the
factorbase are given (in terms of <code>bnf.gen</code>) by the columns of U<sub>r</sub>,
with Archimedean component g<sub>a</sub>; let also GD<sub>a</sub> be the Archimedean
components of the generators of the (principal) ideals defined by the
<code>bnf.gen[i]^bnf.cyc[i]</code>. Then <em>bnf</em>[9] = [U<sub>r</sub>, g<sub>a</sub>, GD<sub>a</sub>].</p>
<p>
<em>bnf</em>[10] is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available, which
is rarely needed, hence would be too expensive to compute during the initial
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> call. For instance, the generators of the principal ideals
<code>bnf.gen[i]^bnf.cyc[i]</code> (during a call to <code><a href="General_number_fields.html#se:bnrisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrisprincipal</a></code>), or
those corresponding to the relations in W and B (when the <code>bnf</code>
internal precision needs to be increased).</p>
<p>
The library syntax is <code>GEN <b>bnfinit0</b>(GEN P, long flag, GEN tech = NULL, long prec)</code>.</p>
<p>
Also available is <code>GEN <b>Buchall</b>(GEN P, long flag, long prec)</code>,
corresponding to <code>tech = NULL</code>, where
<code>flag</code> is either 0 (default) or <code>nf_FORCE</code> (insist on finding
fundamental units). The function
<code>GEN <b>Buchall_param</b>(GEN P, double c1, double c2, long nrpid, long flag, long prec)</code> gives direct access to the technical parameters.</p>
<p>

<hr>
<div id="se:bnfisintnorm"></div>
<div id="bnfisintnorm"></div>
<h4>bnfisintnorm(<em>bnf</em>, x)</h4>
<p>
Computes a complete system of
solutions (modulo units of positive norm) of the absolute norm equation
Norm(a) = x,
where a is an integer in <em>bnf</em>. If <em>bnf</em> has not been certified,
the correctness of the result depends on the validity of GRH.</p>
<p>
See also <code><a href="General_number_fields.html#se:bnfisnorm"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisnorm</a></code>.</p>
<p>
The library syntax is <code>GEN <b>bnfisintnorm</b>(GEN bnf, GEN x)</code>.
The function <code>GEN <b>bnfisintnormabs</b>(GEN bnf, GEN a)</code>
returns a complete system of solutions modulo units of the absolute norm
equation |Norm(x) |= |a|. As fast as <code><a href="General_number_fields.html#se:bnfisintnorm"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisintnorm</a></code>, but solves
the two equations Norm(x) = &#177; a simultaneously.</p>
<p>

<hr>
<div id="se:bnfisnorm"></div>
<div id="bnfisnorm"></div>
<h4>bnfisnorm(<em>bnf</em>, x, {<em>flag</em> = 1})</h4>
<p>
Tries to tell whether the
rational number x is the norm of some element y in <em>bnf</em>. Returns a
vector [a,b] where x = Norm(a)*b. Looks for a solution which is an S-unit,
with S a certain set of prime ideals containing (among others) all primes
dividing x. If <em>bnf</em> is known to be Galois, set <em>flag</em> = 0 (in
this case, x is a norm iff b = 1). If <em>flag</em> is non zero the program adds to
S the following prime ideals, depending on the sign of <em>flag</em>. If <em>flag</em> &gt; 0,
the ideals of norm less than <em>flag</em>. And if <em>flag</em> &lt; 0 the ideals dividing <em>flag</em>.</p>
<p>
Assuming GRH, the answer is guaranteed (i.e.&nbsp;x is a norm iff b = 1),
if S contains all primes less than 12log(disc(<em>Bnf</em>))^2, where
<em>Bnf</em> is the Galois closure of <em>bnf</em>.</p>
<p>
See also <code><a href="General_number_fields.html#se:bnfisintnorm"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisintnorm</a></code>.</p>
<p>
The library syntax is <code>GEN <b>bnfisnorm</b>(GEN bnf, GEN x, long flag)</code>.</p>
<p>

<hr>
<div id="se:bnfisprincipal"></div>
<div id="bnfisprincipal"></div>
<h4>bnfisprincipal(<em>bnf</em>, x, {<em>flag</em> = 1})</h4>
<p>
<em>bnf</em> being the 
number field data output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, and x being an ideal, this
function tests whether the ideal is principal or not. The result is more
complete than a simple true/false answer and solves general discrete
logarithm problem. Assume the class group is &bigoplus;  (&Zopf;/d<sub>i</sub>&Zopf;)g<sub>i</sub>
(where the generators g<sub>i</sub> and their orders d<sub>i</sub> are respectively given by
<code>bnf.gen</code> and <code>bnf.cyc</code>). The routine returns a row vector [e,t],
where e is a vector of exponents 0 &leq; e<sub>i</sub> &lt; d<sub>i</sub>, and t is a number
field element such that
 x = (t) &prod;<sub>i</sub>  g<sub>i</sub><sup>e<sub>i</sub></sup>.
For <em>given</em> g<sub>i</sub> (i.e. for a given <code>bnf</code>), the e<sub>i</sub> are unique,
and t is unique modulo units.</p>
<p>
In particular, x is principal if and only if e is the zero vector. Note
that the empty vector, which is returned when the class number is 1, is
considered to be a zero vector (of dimension 0).</p>
<p>
</p><pre class="code">  ? K = bnfinit(y^2+23);
  ? K.cyc
  %2 = [3]
  ? K.gen
  %3 = [[2, 0; 0, 1]]          \\ a prime ideal above 2
  ? P = idealprimedec(K,3)[1]; \\ a prime ideal above 3
  ? v = bnfisprincipal(K, P)
  %5 = [[2]~, [3/4, 1/4]~]
  ? idealmul(K, v[2], idealfactorback(K, K.gen, v[1]))
  %6 =
  [3 0]
  
  [0 1]
  ? % == idealhnf(K, P)
  %7 = 1
</pre><p></p>
<p></p>
<p>
The binary digits of <em>flag</em> mean:</p>
<p>
<b>*</b> 1: If set, outputs [e,t] as explained above, otherwise returns
only e, which is much easier to compute. The following idiom only tests
whether an ideal is principal:</p>
<p>
</p><pre class="code">    is_principal(bnf, x) = !bnfisprincipal(bnf,x,0);
</pre><p></p>
<p></p>
<p>
<b>*</b> 2: It may not be possible to recover t, given the initial accuracy
to which the <code>bnf</code> structure was computed. In that case, a warning is
printed and t is set equal to the empty vector <code>[]~</code>. If this bit is
set, increase the precision and recompute needed quantities until t can be
computed. Warning: setting this may induce <em>lengthy</em> computations.</p>
<p>
The library syntax is <code>GEN <b>bnfisprincipal0</b>(GEN bnf, GEN x, long flag)</code>.
Instead of the above hardcoded numerical flags, one should
rather use an or-ed combination of the symbolic flags <code>nf_GEN</code> (include
generators, possibly a place holder if too difficult) and <code>nf_FORCE</code>
(insist on finding the generators).</p>
<p>

<hr>
<div id="se:bnfissunit"></div>
<div id="bnfissunit"></div>
<h4>bnfissunit(<em>bnf</em>, <em>sfu</em>, x)</h4>
<p>
<em>bnf</em> being output by
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, <em>sfu</em> by <code><a href="General_number_fields.html#se:bnfsunit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfsunit</a></code>, gives the column vector of
exponents of x on the fundamental S-units and the roots of unity, in the
following order: the fundamental units&nbsp;<em>bnf.fu</em>, the root of
unity&nbsp;<em>bnf.tu</em>, and the S-units&nbsp;<em>sfu[1]</em>.
If x is not an S-unit, outputs an empty vector.</p>
<p></p>
<p>
</p><pre class="code">   ? bnf = bnfinit(x^4 - x^3 + 4*x^2 + 3*x + 9, 1);
   ? bnf.sign
   %2 = [0, 2]
   ? S = idealprimedec(bnf,5); #S
   %3 = 2
   ? sfu = bnfsunit(bnf,S);
   ? sfu[1]
   %5 = [-5/6*x^3 + 4/3*x^2 - 4/3*x - 3/2, 5]
   ? u = [10,-40,24,11]~;
   ? bnfissunit(bnf,sfu,u)
   %7 = [1, Mod(2, 6), 2, 0]~
   ? bnfissunit(bnf,sfu,3)
   %8 = []~
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnfissunit</b>(GEN bnf, GEN sfu, GEN x)</code>.</p>
<p>

<hr>
<div id="se:bnfisunit"></div>
<div id="bnfisunit"></div>
<h4>bnfisunit(<em>bnf</em>, x)</h4>
<p>
<em>bnf</em> being the number field data
output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> and x being an algebraic number (type integer,
rational or polmod), this outputs the decomposition of x on the fundamental
units and the roots of unity if x is a unit, the empty vector otherwise.
More precisely, if u<sub>1</sub>,...,u<sub>r</sub> are the fundamental units, and &zeta;
is the generator of the group of roots of unity (<code>bnf.tu</code>), the output is
a vector [x<sub>1</sub>,...,x<sub>r</sub>,x<sub>r+1</sub>] such that x = u<sub>1</sub><sup>x<sub>1</sub></sup>...
u<sub>r</sub><sup>x<sub>r</sub></sup>.&zeta;<sup>x<sub>r+1</sub></sup>. The x<sub>i</sub> are integers for i &leq; r and is an
integer modulo the order of &zeta; for i = r+1.</p>
<p>
Note that <em>bnf</em> need not contain the fundamental unit explicitly:</p>
<p>
</p><pre class="code">  ? setrand(1); bnf = bnfinit(x^2-x-100000);
  ? bnf.fu
    ***   at top-level: bnf.fu
    ***                     ^--
    *** _.fu: missing units in .fu.
  ? u = [119836165644250789990462835950022871665178127611316131167, \
         379554884019013781006303254896369154068336082609238336]~;
  ? bnfisunit(bnf, u)
  %3 = [-1, Mod(0, 2)]~
</pre><p>
The given u is the inverse of the fundamental unit
implicitly stored in <em>bnf</em>. In this case, the fundamental unit was not
computed and stored in algebraic form since the default accuracy was too
low. (Re-run the command at \g1 or higher to see such diagnostics.)</p>
<p>
The library syntax is <code>GEN <b>bnfisunit</b>(GEN bnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:bnflog"></div>
<div id="bnflog"></div>
<h4>bnflog(<em>bnf</em>, l)</h4>
<p>
Let <em>bnf</em> be a <em>bnf</em> structure attached to the number field F and let l be
a prime number (hereafter denoted &ell; for typographical reasons). Return
the logarithmic &ell;-class group ~{Cl}<sub>F</sub>
of F. This is an abelian group, conjecturally finite (known to be finite
if F/&Qopf; is abelian). The function returns if and only if
the group is indeed finite (otherwise it would run into an infinite loop).
Let S = { &pfr;<sub>1</sub>,..., &pfr;<sub>k</sub>} be the set of &ell;-adic places
(maximal ideals containing &ell;).
The function returns [D, G(&ell;), G'], where</p>
<p>
<b>*</b> D is the vector of elementary divisors for ~{Cl}<sub>F</sub>.</p>
<p>
<b>*</b> G(&ell;) is the vector of elementary divisors for
the (conjecturally finite) abelian group
~{Cl}(&ell;) = 
{ &afr; = &sum;<sub>i &leq; k</sub> a<sub>i</sub> &pfr;<sub>i</sub> :&nbsp;deg<sub>F</sub> &afr; = 0},
where the &pfr;<sub>i</sub> are the &ell;-adic places of F; this is a
subgroup of ~{Cl}.</p>
<p>
<b>*</b> G' is the vector of elementary divisors for the &ell;-Sylow Cl'
of the S-class group of F; the group ~{Cl} maps to Cl'
with a simple co-kernel.</p>
<p>
The library syntax is <code>GEN <b>bnflog</b>(GEN bnf, GEN l)</code>.</p>
<p>

<hr>
<div id="se:bnflogdegree"></div>
<div id="bnflogdegree"></div>
<h4>bnflogdegree(<em>nf</em>, A, l)</h4>
<p>
Let <em>nf</em> be a <em>nf</em> structure attached to a number field F,
and let l be a prime number (hereafter
denoted &ell;). The
&ell;-adified group of id\`{e}les of F quotiented by
the group of logarithmic units is identified to the &ell;-group
of logarithmic divisors &bigoplus;  &Zopf;_&ell; [&pfr;], generated by the
maximal ideals of F.</p>
<p>
The <em>degree</em> map deg<sub>F</sub> is additive with values in &Zopf;_&ell;,
defined by deg<sub>F</sub> &pfr; = ~{f}<sub>&pfr;</sub> deg_&ell; p,
where the integer ~{f}<sub>&pfr;</sub> is as in <code><a href="General_number_fields.html#se:bnflogef"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnflogef</a></code> and deg_&ell; p
is log_&ell; p for p != &ell;, log_&ell; (1 + &ell;) for
p = &ell; != 2 and log_&ell; (1 + 2^2) for p = &ell; = 2.</p>
<p>
Let A = &prod; &pfr;<sup>n<sub>&pfr;</sub></sup> be an ideal and let ~{A} = 
&sum; n_&pfr; [&pfr;] be the attached logarithmic divisor. Return the
exponential of the &ell;-adic logarithmic degree deg<sub>F</sub> A, which is a
natural number.</p>
<p>
The library syntax is <code>GEN <b>bnflogdegree</b>(GEN nf, GEN A, GEN l)</code>.</p>
<p>

<hr>
<div id="se:bnflogef"></div>
<div id="bnflogef"></div>
<h4>bnflogef(<em>nf</em>, <em>pr</em>)</h4>
<p>
Let <em>nf</em> be a <em>nf</em> structure attached to a number field F
and let <em>pr</em> be a <em>prid</em> structure attached to a
maximal ideal &pfr; / p. Return
[~{e}(F_&pfr; / &Qopf;<sub>p</sub>), ~{f}(F_&pfr; / &Qopf;<sub>p</sub>)]
the logarithmic ramification and residue degrees. Let &Qopf;<sub>p</sub>^c/&Qopf;<sub>p</sub> be the
cyclotomic &Zopf;<sub>p</sub>-extension, then
~{e} = [F_&pfr; : F_&pfr; &cap; &Qopf;<sub>p</sub>^c] and
~{f} = [F_&pfr; &cap; &Qopf;<sub>p</sub>^c : &Qopf;<sub>p</sub>]. Note that
~{e}~{f} = e(&pfr;/p) f(&pfr;/p), where e(&pfr;/p) and f(&pfr;/p) denote the
usual ramification and residue degrees.</p>
<p>
</p><pre class="code">  ? F = nfinit(y^6 - 3*y^5 + 5*y^3 - 3*y + 1);
  ? bnflogef(F, idealprimedec(F,2)[1])
  %2 = [6, 1]
  ? bnflogef(F, idealprimedec(F,5)[1])
  %3 = [1, 2]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnflogef</b>(GEN nf, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:bnfnarrow"></div>
<div id="bnfnarrow"></div>
<h4>bnfnarrow(<em>bnf</em>)</h4>
<p>
<em>bnf</em> being as output by
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, computes the narrow class group of <em>bnf</em>. The output is
a 3-component row vector v analogous to the corresponding class group
component <code><em>bnf</em>.clgp</code>: the first component
is the narrow class number <code>v.no</code>, the second component is a vector
containing the SNF cyclic components <code>v.cyc</code> of
the narrow class group, and the third is a vector giving the generators of
the corresponding <code>v.gen</code> cyclic groups. Note that this function is a
special case of <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>; the <em>bnf</em> need not contain fundamental
units.</p>
<p>
The library syntax is <code>GEN <b>bnfnarrow</b>(GEN bnf)</code>.</p>
<p>

<hr>
<div id="se:bnfsignunit"></div>
<div id="bnfsignunit"></div>
<h4>bnfsignunit(<em>bnf</em>)</h4>
<p>
<em>bnf</em> being as output by
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, this computes an r<sub>1</sub> x (r<sub>1</sub>+r<sub>2</sub>-1) matrix having &#177;1
components, giving the signs of the real embeddings of the fundamental units.
The following functions compute generators for the totally positive units:</p>
<p></p>
<p>
</p><pre class="code">  /* exponents of totally positive units generators on bnf.tufu */
  tpuexpo(bnf)=
  { my(K, S = bnfsignunit(bnf), [m,n] = matsize(S));
    \\ m = bnf.r1, n = r1+r2-1
    S = matrix(m,n, i,j, if (S[i,j] &lt; 0, 1,0));
    S = concat(vectorv(m,i,1), S);   \\ add sign(-1)
    K = matker(S * Mod(1,2));
    if (K, mathnfmodid(lift(K), 2), 2*matid(n+1))
  }
  
  /* totally positive fundamental units */
  tpu(bnf)=
  { my(ex = tpuexpo(bnf)[,2..-1]); \\ remove ex[,1], corresponds to 1 or -1
    vector(#ex, i, nffactorback(bnf, bnf.tufu, ex[,i]));
  }
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>signunits</b>(GEN bnf)</code>.</p>
<p>

<hr>
<div id="se:bnfsunit"></div>
<div id="bnfsunit"></div>
<h4>bnfsunit(<em>bnf</em>, S)</h4>
<p>
Computes the fundamental S-units of the
number field <em>bnf</em> (output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>), where S is a list of
prime ideals (output by <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code>). The output is a vector v with
6 components.</p>
<p>
v[1] gives a minimal system of (integral) generators of the S-unit group
modulo the unit group.</p>
<p>
v[2] contains technical data needed by <code><a href="General_number_fields.html#se:bnfissunit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfissunit</a></code>.</p>
<p>
v[3] is an empty vector (used to give the logarithmic embeddings of the
generators in v[1] in version 2.0.16).</p>
<p>
v[4] is the S-regulator (this is the product of the regulator, the
determinant of v[2] and the natural logarithms of the norms of the ideals
in S).</p>
<p>
v[5] gives the S-class group structure, in the usual format
(a row vector whose three components give in order the S-class number,
the cyclic components and the generators).</p>
<p>
v[6] is a copy of S.</p>
<p>
The library syntax is <code>GEN <b>bnfsunit</b>(GEN bnf, GEN S, long prec)</code>.</p>
<p>

<hr>
<div id="se:bnrL1"></div>
<div id="bnrL1"></div>
<h4>bnrL1(<em>bnr</em>, {H}, {<em>flag</em> = 0})</h4>
<p>
Let <em>bnr</em> be the number field data output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code> and
<em>H</em> be a square matrix defining a congruence subgroup of the
ray class group corresponding to <em>bnr</em> (the trivial congruence subgroup
if omitted). This function returns, for each character &chi; of the ray
class group which is trivial on H, the value at s = 1 (or s = 0) of the
abelian L-function attached to &chi;. For the value at s = 0, the
function returns in fact for each &chi; a vector [r_&chi;, c_&chi;] where
L(s, &chi;) = c.s^r + O(s<sup>r + 1</sup>)
near 0.</p>
<p>
The argument <em>flag</em> is optional, its binary digits
mean 1: compute at s = 0 if unset or s = 1 if set, 2: compute the
primitive L-function attached to &chi; if unset or the L-function
with Euler factors at prime ideals dividing the modulus of <em>bnr</em> removed
if set (that is L<sub>S</sub>(s, &chi;), where S is the
set of infinite places of the number field together with the finite prime
ideals dividing the modulus of <em>bnr</em>), 3: return also the character if
set.</p>
<p>
</p><pre class="code">  K = bnfinit(x^2-229);
  bnr = bnrinit(K,1);
  bnrL1(bnr)
</pre><p></p>
<p>
returns the order and the first non-zero term of L(s, &chi;) at s = 0
where &chi; runs through the characters of the class group of
K = &Qopf;(sqrt{229}). Then</p>
<p>
</p><pre class="code">  bnr2 = bnrinit(K,2);
  bnrL1(bnr2,,2)
</pre><p></p>
<p>
returns the order and the first non-zero terms of L<sub>S</sub>(s, &chi;) at s = 0
where &chi; runs through the characters of the class group of K and S is
the set of infinite places of K together with the finite prime 2. Note
that the ray class group modulo 2 is in fact the class group, so
<code>bnrL1(bnr2,0)</code> returns the same answer as <code>bnrL1(bnr,0)</code>.</p>
<p>
This function will fail with the message</p>
<p>
</p><pre class="code">   *** bnrL1: overflow in zeta_get_N0 [need too many primes].
</pre><p>
if the approximate functional equation requires us to sum
too many terms (if the discriminant of K is too large).</p>
<p>
The library syntax is <code>GEN <b>bnrL1</b>(GEN bnr, GEN H = NULL, long flag, long prec)</code>.</p>
<p>

<hr>
<div id="se:bnrchar"></div>
<div id="bnrchar"></div>
<h4>bnrchar(<em>bnr</em>, g, {v})</h4>
<p>
Returns all characters &chi; on <code>bnr.clgp</code> such that
&chi;(g<sub>i</sub>) = e(v<sub>i</sub>), where e(x) = exp(2i&pi; x). If v is omitted,
returns all characters that are trivial on the g<sub>i</sub>. Else the vectors g
and v must have the same length, the g<sub>i</sub> must be ideals in any form, and
each v<sub>i</sub> is a rational number whose denominator must divide the order of
g<sub>i</sub> in the ray class group. For convenience, the vector of the g<sub>i</sub>
can be replaced by a matrix whose columns give their discrete logarithm,
as given by <code><a href="General_number_fields.html#se:bnrisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrisprincipal</a></code>; this allows to specify abstractly a
subgroup of the ray class group.</p>
<p></p>
<p>
</p><pre class="code">  ? bnr = bnrinit(bnfinit(x), [160,[1]], 1); /* (Z/160Z)<sup>*</sup> */
  ? bnr.cyc
  %2 = [8, 4, 2]
  ? g = bnr.gen;
  ? bnrchar(bnr, g, [1/2,0,0])
  %4 = [[4, 0, 0]]  \\ a unique character
  ? bnrchar(bnr, [g[1],g[3]]) \\ all characters trivial on g[1] and g[3]
  %5 = [[0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 0, 0]]
  ? bnrchar(bnr, [1,0,0;0,1,0;0,0,2])
  %6 = [[0, 0, 1], [0, 0, 0]]  \\ characters trivial on given subgroup
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnrchar</b>(GEN bnr, GEN g, GEN v = NULL)</code>.</p>
<p>

<hr>
<div id="se:bnrclassno"></div>
<div id="bnrclassno"></div>
<h4>bnrclassno(A, {B}, {C})</h4>
<p>
Let A, B, C define a class field L over a ground field K
(of type <code>[<em>bnr</em>]</code>,
<code>[<em>bnr</em>, <em>subgroup</em>]</code>,
or <code>[<em>bnf</em>, <em>modulus</em>]</code>,
or <code>[<em>bnf</em>, <em>modulus</em>,<em>subgroup</em>]</code>,
Section <a href="General_number_fields.html#se:CFT"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:CFT</a>); this function returns the relative degree [L:K].</p>
<p>
In particular if A is a <em>bnf</em> (with units), and B a modulus,
this function returns the corresponding ray class number modulo B.
One can input the attached <em>bid</em> (with generators if the subgroup
C is non trivial) for B instead of the module itself, saving some time.</p>
<p>
This function is faster than <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code> and should be used if only the
ray class number is desired. See <code><a href="General_number_fields.html#se:bnrclassnolist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrclassnolist</a></code> if you need ray class
numbers for all moduli less than some bound.</p>
<p>
The library syntax is <code>GEN <b>bnrclassno0</b>(GEN A, GEN B = NULL, GEN C = NULL)</code>.
Also available is
<code>GEN <b>bnrclassno</b>(GEN bnf,GEN f)</code> to compute the ray class number
modulo&nbsp;f.</p>
<p>

<hr>
<div id="se:bnrclassnolist"></div>
<div id="bnrclassnolist"></div>
<h4>bnrclassnolist(<em>bnf</em>, <em>list</em>)</h4>
<p>
<em>bnf</em> being as
output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, and <em>list</em> being a list of moduli (with units) as
output by <code><a href="General_number_fields.html#se:ideallist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallist</a></code> or <code><a href="General_number_fields.html#se:ideallistarch"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallistarch</a></code>, outputs the list of the
class numbers of the corresponding ray class groups. To compute a single
class number, <code><a href="General_number_fields.html#se:bnrclassno"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrclassno</a></code> is more efficient.</p>
<p></p>
<p>
</p><pre class="code">  ? bnf = bnfinit(x^2 - 2);
  ? L = ideallist(bnf, 100, 2);
  ? H = bnrclassnolist(bnf, L);
  ? H[98]
  %4 = [1, 3, 1]
  ? l = L[1][98]; ids = vector(#l, i, l[i].mod[1])
  %5 = [[98, 88; 0, 1], [14, 0; 0, 7], [98, 10; 0, 1]]
</pre><p></p>
<p>
The weird <code>l[i].mod[1]</code>, is the first component of <code>l[i].mod</code>, i.e.
the finite part of the conductor. (This is cosmetic: since by construction
the Archimedean part is trivial, I do not want to see it). This tells us that
the ray class groups modulo the ideals of norm 98 (printed as <code>%5</code>) have
respectively order 1, 3 and 1. Indeed, we may check directly:</p>
<p>
</p><pre class="code">  ? bnrclassno(bnf, ids[2])
  %6 = 3
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnrclassnolist</b>(GEN bnf, GEN list)</code>.</p>
<p>

<hr>
<div id="se:bnrconductor"></div>
<div id="bnrconductor"></div>
<h4>bnrconductor(A, {B}, {C}, {<em>flag</em> = 0})</h4>
<p>
Conductor f of the subfield of a ray class field as defined by [A,B,C]
(of type <code>[<em>bnr</em>]</code>,
<code>[<em>bnr</em>, <em>subgroup</em>]</code>,
<code>[<em>bnf</em>, <em>modulus</em>]</code> or
<code>[<em>bnf</em>, <em>modulus</em>, <em>subgroup</em>]</code>,
Section <a href="General_number_fields.html#se:CFT"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:CFT</a>)</p>
<p>
If <em>flag</em> = 0, returns f.</p>
<p>
If <em>flag</em> = 1, returns [f, Cl<sub>f</sub>, H], where Cl<sub>f</sub> is the ray class group
modulo f, as a finite abelian group; finally H is the subgroup of Cl<sub>f</sub>
defining the extension.</p>
<p>
If <em>flag</em> = 2, returns [f, <em>bnr</em>(f), H], as above except Cl<sub>f</sub> is
replaced by a <code>bnr</code> structure, as output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>(,f), without
generators unless the input contained a <em>bnr</em> with generators.</p>
<p>
In place of a subgroup H, this function also accepts a character
<code>chi</code>   = (a<sub>j</sub>), expressed as usual in terms of the generators
<code>bnr.gen</code>: &chi;(g<sub>j</sub>) = exp(2i&pi; a<sub>j</sub> / d<sub>j</sub>), where g<sub>j</sub> has
order d<sub>j</sub> = <code>bnr.cyc[j]</code>. In which case, the function returns
respectively</p>
<p>
If <em>flag</em> = 0, the conductor f of Ker &chi;.</p>
<p>
If <em>flag</em> = 1, [f, Cl<sub>f</sub>, &chi;<sub>f</sub>], where &chi;<sub>f</sub> is &chi; expressed
on the minimal ray class group, whose modulus is the conductor.</p>
<p>
If <em>flag</em> = 2, [f, <em>bnr</em>(f), &chi;<sub>f</sub>].</p>
<p>
The library syntax is <code>GEN <b>bnrconductor0</b>(GEN A, GEN B = NULL, GEN C = NULL, long flag)</code>.</p>
<p>
Also available is <code>GEN <b>bnrconductor</b>(GEN bnr, GEN H, long flag)</code></p>
<p>

<hr>
<div id="se:bnrconductorofchar"></div>
<div id="bnrconductorofchar"></div>
<h4>bnrconductorofchar(<em>bnr</em>, <em>chi</em>)</h4>
<p>
This function is obsolete, use <em>bnrconductor</em>.</p>
<p>
The library syntax is <code>GEN <b>bnrconductorofchar</b>(GEN bnr, GEN chi)</code>.</p>
<p>

<hr>
<div id="se:bnrdisc"></div>
<div id="bnrdisc"></div>
<h4>bnrdisc(A, {B}, {C}, {<em>flag</em> = 0})</h4>
<p>
A, B, C defining a class field L over a ground field K
(of type <code>[<em>bnr</em>]</code>,
<code>[<em>bnr</em>, <em>subgroup</em>]</code>,
<code>[<em>bnr</em>, <em>character</em>]</code>,
<code>[<em>bnf</em>, <em>modulus</em>]</code> or
<code>[<em>bnf</em>, <em>modulus</em>, <em>subgroup</em>]</code>,
Section <a href="General_number_fields.html#se:CFT"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:CFT</a>), outputs data [N,r<sub>1</sub>,D] giving the discriminant and
signature of L, depending on the binary digits of <em>flag</em>:</p>
<p>
<b>*</b> 1: if this bit is unset, output absolute data related to L/&Qopf;:
N is the absolute degree [L:&Qopf;], r<sub>1</sub> the number of real places of L,
and D the discriminant of L/&Qopf;. Otherwise, output relative data for L/K:
N is the relative degree [L:K], r<sub>1</sub> is the number of real places of K
unramified in L (so that the number of real places of L is equal to r<sub>1</sub>
times N), and D is the relative discriminant ideal of L/K.</p>
<p>
<b>*</b> 2: if this bit is set and if the modulus is not the conductor of L,
only return 0.</p>
<p>
The library syntax is <code>GEN <b>bnrdisc0</b>(GEN A, GEN B = NULL, GEN C = NULL, long flag)</code>.</p>
<p>

<hr>
<div id="se:bnrdisclist"></div>
<div id="bnrdisclist"></div>
<h4>bnrdisclist(<em>bnf</em>, <em>bound</em>, {<em>arch</em>})</h4>
<p>
<em>bnf</em> being as output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> (with units), computes a
list of discriminants of Abelian extensions of the number field by increasing
modulus norm up to bound <em>bound</em>. The ramified Archimedean places are
given by <em>arch</em>; all possible values are taken if <em>arch</em> is omitted.</p>
<p>
The alternative syntax <code><a href="General_number_fields.html#se:bnrdisclist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrdisclist</a></code>(<em>bnf</em>,<em>list</em>) is
supported, where <em>list</em> is as output by <code><a href="General_number_fields.html#se:ideallist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallist</a></code> or
<code><a href="General_number_fields.html#se:ideallistarch"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallistarch</a></code> (with units), in which case <em>arch</em> is disregarded.</p>
<p>
The output v is a vector, where v[k] is itself a vector w, whose length
is the number of ideals of norm k.</p>
<p>
<b>*</b> We consider first the case where <em>arch</em> was specified. Each
component of w corresponds to an ideal m of norm k, and
gives invariants attached to the ray class field L of <em>bnf</em> of
conductor [m, <em>arch</em>]. Namely, each contains a vector [m,d,r,D] with
the following meaning: m is the prime ideal factorization of the modulus,
d = [L:&Qopf;] is the absolute degree of L, r is the number of real places
of L, and D is the factorization of its absolute discriminant. We set d
 = r = D = 0 if m is not the finite part of a conductor.</p>
<p>
<b>*</b> If <em>arch</em> was omitted, all t = 2<sup>r<sub>1</sub></sup> possible values are taken
and a component of w has the form
[m, [[d<sub>1</sub>,r<sub>1</sub>,D<sub>1</sub>],..., [d<sub>t</sub>,r<sub>t</sub>,D<sub>t</sub>]]],
where m is the finite part of the conductor as above, and
[d<sub>i</sub>,r<sub>i</sub>,D<sub>i</sub>] are the invariants of the ray class field of conductor
[m,v<sub>i</sub>], where v<sub>i</sub> is the i-th Archimedean component, ordered by
inverse lexicographic order; so v<sub>1</sub> = [0,...,0], v<sub>2</sub> = [1,0...,0],
etc. Again, we set d<sub>i</sub> = r<sub>i</sub> = D<sub>i</sub> = 0 if [m,v<sub>i</sub>] is not a conductor.</p>
<p>
Finally, each prime ideal pr = [p,&alpha;,e,f,&beta;] in the prime
factorization m is coded as the integer p.n^2+(f-1).n+(j-1),
where n is the degree of the base field and j is such that</p>
<p>
<code>pr = idealprimedec(<em>nf</em>,p)[j]</code>.</p>
<p>
m can be decoded using <code><a href="General_number_fields.html#se:bnfdecodemodule"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfdecodemodule</a></code>.</p>
<p>
Note that to compute such data for a single field, either <code><a href="General_number_fields.html#se:bnrclassno"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrclassno</a></code>
or <code><a href="General_number_fields.html#se:bnrdisc"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrdisc</a></code> are (much) more efficient.</p>
<p>
The library syntax is <code>GEN <b>bnrdisclist0</b>(GEN bnf, GEN bound, GEN arch = NULL)</code>.</p>
<p>

<hr>
<div id="se:bnrgaloisapply"></div>
<div id="bnrgaloisapply"></div>
<h4>bnrgaloisapply(<em>bnr</em>, <em>mat</em>, H)</h4>
<p>
Apply the automorphism given by its matrix <em>mat</em> to the congruence
subgroup H given as a HNF matrix.
The matrix <em>mat</em> can be computed with <code><a href="General_number_fields.html#se:bnrgaloismatrix"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrgaloismatrix</a></code>.</p>
<p>
The library syntax is <code>GEN <b>bnrgaloisapply</b>(GEN bnr, GEN mat, GEN H)</code>.</p>
<p>

<hr>
<div id="se:bnrgaloismatrix"></div>
<div id="bnrgaloismatrix"></div>
<h4>bnrgaloismatrix(<em>bnr</em>, <em>aut</em>)</h4>
<p>
Return the matrix of the action of the automorphism <em>aut</em> of the base
field <code>bnf.nf</code> on the generators of the ray class field <code>bnr.gen</code>.
<em>aut</em> can be given as a polynomial, an algebraic number, or a vector of
automorphisms or a Galois group as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>, in which case a
vector of matrices is returned (in the later case, only for the generators
<code>aut.gen</code>).</p>
<p>
See <code><a href="General_number_fields.html#se:bnrisgalois"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrisgalois</a></code> for an example.</p>
<p>
The library syntax is <code>GEN <b>bnrgaloismatrix</b>(GEN bnr, GEN aut)</code>.
When aut is a polynomial or an algebraic number,
<code>GEN <b>bnrautmatrix</b>(GEN bnr, GEN aut)</code> is available.</p>
<p>

<hr>
<div id="se:bnrinit"></div>
<div id="bnrinit"></div>
<h4>bnrinit(<em>bnf</em>, f, {<em>flag</em> = 0})</h4>
<p>
<em>bnf</em> is as
output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> (including fundamental units), f is a modulus,
initializes data linked to the ray class group structure corresponding to
this module, a so-called <code>bnr</code> structure. One can input the attached
<em>bid</em> with generators for f instead of the module itself, saving some
time. (As in <code><a href="General_number_fields.html#se:idealstar"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealstar</a></code>, the finite part of the conductor may be given
by a factorization into prime ideals, as produced by <code><a href="General_number_fields.html#se:idealfactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealfactor</a></code>.)</p>
<p>
The following member functions are available
on the result: <code>.bnf</code> is the underlying <em>bnf</em>,
<code>.mod</code> the modulus, <code>.bid</code> the <code>bid</code> structure attached to the
modulus; finally, <code>.clgp</code>, <code>.no</code>, <code>.cyc</code>, <code>.gen</code> refer to the
ray class group (as a finite abelian group), its cardinality, its elementary
divisors, its generators (only computed if <em>flag</em> = 1).</p>
<p>
The last group of functions are different from the members of the underlying
<em>bnf</em>, which refer to the class group; use <code><em>bnr</em>.bnf.<em>xxx</em></code>
to access these, e.g.&nbsp;<code><em>bnr</em>.bnf.cyc</code> to get the cyclic decomposition
of the class group.</p>
<p>
They are also different from the members of the underlying <em>bid</em>, which
refer to (&Zopf;<sub>K</sub>/f)<sup>*</sup>; use <code><em>bnr</em>.bid.<em>xxx</em></code> to access these,
e.g.&nbsp;<code><em>bnr</em>.bid.no</code> to get &phi;(f).</p>
<p>
If <em>flag</em> = 0 (default), the generators of the ray class group are not computed,
which saves time. Hence <code><em>bnr</em>.gen</code> would produce an error.</p>
<p>
If <em>flag</em> = 1, as the default, except that generators are computed.</p>
<p>
The library syntax is <code>GEN <b>bnrinit0</b>(GEN bnf, GEN f, long flag)</code>.
Instead the above  hardcoded  numerical flags,  one should rather use
<code>GEN <b>Buchray</b>(GEN bnf, GEN module, long flag)</code>
where flag is an or-ed combination of <code>nf_GEN</code> (include generators)
and <code>nf_INIT</code> (if omitted, return just the cardinality of the ray class
group and its structure), possibly 0.</p>
<p>

<hr>
<div id="se:bnrisconductor"></div>
<div id="bnrisconductor"></div>
<h4>bnrisconductor(A, {B}, {C})</h4>
<p>
Fast variant of <code><a href="General_number_fields.html#se:bnrconductor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrconductor</a></code>(A,B,C); A, B, C represent
an extension of the base field, given by class field theory
(see&nbsp;Section <a href="General_number_fields.html#se:CFT"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:CFT</a>). Outputs 1 if this modulus is the conductor, and 0
otherwise. This is slightly faster than <code><a href="General_number_fields.html#se:bnrconductor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrconductor</a></code> when the
character or subgroup is not primitive.</p>
<p>
The library syntax is <code>long <b>bnrisconductor0</b>(GEN A, GEN B = NULL, GEN C = NULL)</code>.</p>
<p>

<hr>
<div id="se:bnrisgalois"></div>
<div id="bnrisgalois"></div>
<h4>bnrisgalois(<em>bnr</em>, <em>gal</em>, H)</h4>
<p>
Check whether the class field attached to the subgroup H is Galois
over the subfield of <code>bnr.nf</code> fixed by the group <em>gal</em>, which can be
given as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>, or as a matrix or a vector of matrices as
output by <code><a href="General_number_fields.html#se:bnrgaloismatrix"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrgaloismatrix</a></code>, the second option being preferable, since it
saves the recomputation of the matrices.  Note: The function assumes that the
ray class field attached to bnr is Galois, which is not checked.</p>
<p>
In the following example, we lists the congruence subgroups of subextension of
degree at most 3 of the ray class field of conductor 9 which are Galois
over the rationals.</p>
<p></p>
<p>
</p><pre class="code">  K=bnfinit(a^4-3*a^2+253009);
  G=galoisinit(K);
  B=bnrinit(K,9,1);
  L1=[H|H&lt;-subgrouplist(B,3), bnrisgalois(B,G,H)]
  ##
  M=bnrgaloismatrix(B,G)
  L2=[H|H&lt;-subgrouplist(B,3), bnrisgalois(B,M,H)]
  ##
</pre><p></p>
<p>
The second computation is much faster since <code>bnrgaloismatrix(B,G)</code> is
computed only once.</p>
<p>
The library syntax is <code>long <b>bnrisgalois</b>(GEN bnr, GEN gal, GEN H)</code>.</p>
<p>

<hr>
<div id="se:bnrisprincipal"></div>
<div id="bnrisprincipal"></div>
<h4>bnrisprincipal(<em>bnr</em>, x, {<em>flag</em> = 1})</h4>
<p>
Let <em>bnr</em> be the ray class group data output by
<code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>(,,1) and let x be an ideal in any form, coprime
to the modulus f = <code>bnr.mod</code>. Solves the discrete logarithm problem
in the ray class group, with respect to the generators <code>bnr.gen</code>,
in a way similar to <code><a href="General_number_fields.html#se:bnfisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisprincipal</a></code>. If x is not coprime to the
modulus of <em>bnr</em> the result is undefined.</p>
<p>
If <em>flag</em> = 1, returns a 2-component vector v where v[1] is the
vector of components of x on the ray class group generators, v[2] is
an element &alpha; congruent to 1&nbsp;mod<sup>*</sup> f such that
x = &alpha; &prod;<sub>i</sub> g<sub>i</sub><sup>x<sub>i</sub></sup>.</p>
<p>
If <em>flag</em> = 0, outputs only v<sub>1</sub>. In that case, <em>bnr</em> need not contain the
ray class group generators, i.e.&nbsp;it may be created with
<code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>(,,0); in that case, although <code>bnr.gen</code> is undefined, we
can still define canonical generators attached to the <code>bnr</code> and compute
with respect to them.</p>
<p>
</p><pre class="code">  ? K = bnfinit(x^2 - 30); bnr = bnrinit(K, [4, [1,1]]);
  ? bnr.clgp \\ ray class group is isomorphic to Z/4 x Z/2 x Z/2
  %2 = [16, [4, 2, 2]]
  ? P = idealprimedec(K, 3)[1]; \\ a prime ideal above 3
  ? bnrisprincipal(bnr,P)
  %4 = [[1, 0, 0]~, 1]
  ? bnrisprincipal(bnr,P, 0) \\ omit the principal part
  %4 = [1, 0, 0]~
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnrisprincipal</b>(GEN bnr, GEN x, long flag)</code>.
Instead of hardcoded  numerical flags,  one should rather use
<code>GEN <b>isprincipalray</b>(GEN bnr, GEN x)</code> for <code>flag</code> = 0, and if you
want generators:</p>
<p>
</p><pre class="code">    bnrisprincipal(bnr, x, nf_GEN)
</pre><p></p>
<p></p>
<p>

<hr>
<div id="se:bnrrootnumber"></div>
<div id="bnrrootnumber"></div>
<h4>bnrrootnumber(<em>bnr</em>, <em>chi</em>, {<em>flag</em> = 0})</h4>
<p>
If &chi; = <em>chi</em> is a
character over <em>bnr</em>, not necessarily primitive, let
L(s,&chi;) = &sum;<sub>id</sub> &chi;(id) N(id)<sup>-s</sup> be the attached
Artin L-function. Returns the so-called Artin root number, i.e.&nbsp;the
complex number W(&chi;) of modulus 1 such that</p>
<p>
&Lambda;(1-s,&chi;) = W(&chi;) &Lambda;(s,<span style="text-decoration:overline">&chi;</span>)</p>
<p>
where &Lambda;(s,&chi;) = A(&chi;)<sup>s/2</sup>&gamma;_&chi;(s) L(s,&chi;) is
the enlarged L-function attached to L.</p>
<p>
You can set <em>flag</em> = 1 if the character is known to be primitive. Example:</p>
<p>
</p><pre class="code">  bnf = bnfinit(x^2 - x - 57);
  bnr = bnrinit(bnf, [7,[1,1]]);
  bnrrootnumber(bnr, [2,1])
</pre><p></p>
<p>
returns the root number of the character &chi; of
Cl<sub>7 oo <sub>1</sub> oo <sub>2</sub></sub>(&Qopf;(sqrt{229})) defined by &chi;(g<sub>1</sub>^ag<sub>2</sub>^b)
 = &zeta;<sub>1</sub><sup>2a</sup>&zeta;<sub>2</sub>^b. Here g<sub>1</sub>, g<sub>2</sub> are the generators of the
ray-class group given by <code>bnr.gen</code> and &zeta;<sub>1</sub> = e<sup>2i&pi;/N<sub>1</sub></sup>,
&zeta;<sub>2</sub> = e<sup>2i&pi;/N<sub>2</sub></sup> where N<sub>1</sub>, N<sub>2</sub> are the orders of g<sub>1</sub> and
g<sub>2</sub> respectively (N<sub>1</sub> = 6 and N<sub>2</sub> = 3 as <code>bnr.cyc</code> readily tells us).</p>
<p>
The library syntax is <code>GEN <b>bnrrootnumber</b>(GEN bnr, GEN chi, long flag, long prec)</code>.</p>
<p>

<hr>
<div id="se:bnrstark"></div>
<div id="bnrstark"></div>
<h4>bnrstark(<em>bnr</em>, {<em>subgroup</em>})</h4>
<p>
<em>bnr</em> being as output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>, finds a relative equation
for the class field corresponding to the modulus in <em>bnr</em> and the given
congruence subgroup (as usual, omit <em>subgroup</em> if you want the whole ray
class group).</p>
<p>
The main variable of <em>bnr</em> must not be x, and the ground field and the
class field must be totally real. When the base field is &Qopf;, the vastly
simpler <code><a href="General_number_fields.html#se:galoissubcyclo"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubcyclo</a></code> is used instead. Here is an example:</p>
<p>
</p><pre class="code">  bnf = bnfinit(y^2 - 3);
  bnr = bnrinit(bnf, 5);
  bnrstark(bnr)
</pre><p></p>
<p>
returns the ray class field of &Qopf;(sqrt{3}) modulo 5. Usually, one wants
to apply to the result one of</p>
<p>
</p><pre class="code">  rnfpolredabs(bnf, pol, 16)     \\  compute a reduced relative polynomial
  rnfpolredabs(bnf, pol, 16 + 2) \\  compute a reduced absolute polynomial
</pre><p></p>
<p></p>
<p>
The routine uses Stark units and needs to find a suitable auxiliary
conductor, which may not exist when the class field is not cyclic over the
base. In this case <code><a href="General_number_fields.html#se:bnrstark"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrstark</a></code> is allowed to return a vector of
polynomials defining <em>independent</em> relative extensions, whose compositum
is the requested class field. It was decided that it was more useful
to keep the extra information thus made available, hence the user has to take
the compositum herself.</p>
<p>
Even if it exists, the auxiliary conductor may be so large that later
computations become unfeasible. (And of course, Stark's conjecture may simply
be wrong.) In case of difficulties, try <code><a href="General_number_fields.html#se:rnfkummer"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfkummer</a></code>:</p>
<p>
</p><pre class="code">  ? bnr = bnrinit(bnfinit(y^8-12*y^6+36*y^4-36*y^2+9,1), 2);
  ? bnrstark(bnr)
    ***   at top-level: bnrstark(bnr)
    ***                 ^ &mdash;  &mdash;  &mdash;  &mdash; -
    *** bnrstark: need 3919350809720744 coefficients in initzeta.
    *** Computation impossible.
  ? lift( rnfkummer(bnr) )
  time = 24 ms.
  %2 = x^2 + (1/3*y^6 - 11/3*y^4 + 8*y^2 - 5)
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnrstark</b>(GEN bnr, GEN subgroup = NULL, long prec)</code>.</p>
<p>

<hr>
<div id="se:dirzetak"></div>
<div id="dirzetak"></div>
<h4>dirzetak(<em>nf</em>, b)</h4>
<p>
Gives as a vector the first b
coefficients of the Dedekind zeta function of the number field <em>nf</em>
considered as a Dirichlet series.</p>
<p>
The library syntax is <code>GEN <b>dirzetak</b>(GEN nf, GEN b)</code>.</p>
<p>

<hr>
<div id="se:factornf"></div>
<div id="factornf"></div>
<h4>factornf(x, t)</h4>
<p>
This function is obsolete, use <code><a href="General_number_fields.html#se:nffactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nffactor</a></code>.</p>
<p>
factorization of the univariate polynomial x
over the number field defined by the (univariate) polynomial t. x may
have coefficients in &Qopf; or in the number field. The algorithm reduces to
factorization over &Qopf; (Trager's trick). The direct approach of
<code><a href="General_number_fields.html#se:nffactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nffactor</a></code>, which uses van Hoeij's method in a relative setting, is
in general faster.</p>
<p>
The main variable of t must be of <em>lower</em> priority than that of x
(see Section se:priority). However if non-rational number field elements
occur (as polmods or polynomials) as coefficients of x, the variable of
these polmods <em>must</em> be the same as the main variable of t. For
example</p>
<p></p>
<p>
</p><pre class="code">  ? factornf(x^2 + Mod(y, y^2+1), y^2+1);
  ? factornf(x^2 + y, y^2+1); \\  these two are OK
  ? factornf(x^2 + Mod(z,z^2+1), y^2+1)
    ***   at top-level: factornf(x^2+Mod(z,z
    ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
    *** factornf: inconsistent data in rnf function.
  ? factornf(x^2 + z, y^2+1)
    ***   at top-level: factornf(x^2+z,y^2+1
    ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
    *** factornf: incorrect variable in rnf function.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>polfnf</b>(GEN x, GEN t)</code>.</p>
<p>

<hr>
<div id="se:galoischardet"></div>
<div id="galoischardet"></div>
<h4>galoischardet(<em>gal</em>, <em>chi</em>, {o = 1})</h4>
<p>
Let G be the group attached to the <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>
structure&nbsp;<em>gal</em>, and
let &chi; be the character of some representation &rho; of the group G,
where a polynomial variable is to be interpreted as an o-th root of 1.
For instance, if <code>[T,o] = galoischartable(gal)</code> the characters
&chi; are input as the columns of <code>T</code>.</p>
<p>
Return the degree-1 character det&rho; as the list of det &rho;(g),
where g runs through representatives of the conjugacy classes
in <code>galoisconjclasses(gal)</code>, with the same ordering.</p>
<p>
</p><pre class="code">  ? P = x^5 - x^4 - 5*x^3 + 4*x^2 + 3*x - 1;
  ? polgalois(P)
  %2 = [10, 1, 1, "D(5) = 5:2"]
  ? K = nfsplitting(P);
  ? gal = galoisinit(K);  \\ dihedral of order 10
  ? [T,o] = galoischartable(gal);
  ? chi = T[,1]; \\ trivial character
  ? galoischardet(gal, chi, o)
  %7 = [1, 1, 1, 1]~
  ? [galoischardet(gal, T[,i], o) | i &lt;- [1..#T]] \\ all characters
  %8 = [[1, 1, 1, 1]~, [1, 1, -1, 1]~, [1, 1, -1, 1]~, [1, 1, -1, 1]~]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoischardet</b>(GEN gal, GEN chi, long o)</code>.</p>
<p>

<hr>
<div id="se:galoischarpoly"></div>
<div id="galoischarpoly"></div>
<h4>galoischarpoly(<em>gal</em>, <em>chi</em>, {o = 1})</h4>
<p>
Let G be the group attached to the <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>
structure&nbsp;<em>gal</em>, and
let &chi; be the character of some representation &rho; of the group
G, where a polynomial variable is to be interpreted as an o-th root of
1, e.g., if <code>[T,o] = galoischartable(gal)</code> and &chi; is a column of
<code>T</code>.
Return the list of characteristic polynomials det(1 - &rho;(g)T),
where g runs through representatives of the conjugacy classes
in <code>galoisconjclasses(gal)</code>, with the same ordering.</p>
<p>
</p><pre class="code">  ? T = x^5 - x^4 - 5*x^3 + 4*x^2 + 3*x - 1;
  ? polgalois(T)
  %2 = [10, 1, 1, "D(5) = 5:2"]
  ? K = nfsplitting(T);
  ? gal = galoisinit(K);  \\ dihedral of order 10
  ? [T,o] = galoischartable(gal);
  ? o
  %5 = 5
  ? galoischarpoly(gal, T[,1], o)  \\ T[,1] is the trivial character
  %6 = [-x + 1, -x + 1, -x + 1, -x + 1]~
  ? galoischarpoly(gal, T[,3], o)
  %7 = [x^2 - 2*x + 1,
        x^2 + (y^3 + y^2 + 1)*x + 1,
        -x^2 + 1,
        x^2 + (-y^3 - y^2)*x + 1]~
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoischarpoly</b>(GEN gal, GEN chi, long o)</code>.</p>
<p>

<hr>
<div id="se:galoischartable"></div>
<div id="galoischartable"></div>
<h4>galoischartable(<em>gal</em>)</h4>
<p>
Compute the character table of&nbsp;G, where&nbsp;G is the underlying group of
the <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code> structure&nbsp;<em>gal</em>. The input&nbsp;<em>gal</em> is also allowed
to be a <code>t_VEC</code> of permutations that is closed under products.
Let&nbsp;N be the number of conjugacy classes of&nbsp;G.
Return a <code>t_VEC</code>&nbsp;[M,<em>e</em>] where e &geq; 1 is an integer
and M is a square <code>t_MAT</code> of size&nbsp;N giving the character table
of&nbsp;G.</p>
<p>
<b>*</b> Each column corresponds to an irreducible character; the characters
are ordered by increasing dimension and the first column is the trivial
character (hence contains only 1's).</p>
<p>
<b>*</b> Each row corresponds to a conjugacy class; the conjugacy classes are
ordered as specified by <code>galoisconjclasses(gal)</code>, in particular the
first row corresponds to the identity and gives the dimension &chi;(1)
of the irreducible representation attached to the successive characters
&chi;.</p>
<p>
The value M[i,j] of the character j at the conjugacy class i
is represented by a polynomial in <code>y</code> whose variable should be
interpreted as an e-th root of unity, i.e. as the lift of</p>
<p>
</p><pre class="code">    Mod(y, polcyclo(e,'y))
</pre><p>
(Note that M is the transpose of the usual orientation for
character tables.)</p>
<p>
The integer e divides the exponent of the group G and is chosen as small
as posible; for instance e = 1 when the characters are all defined over
&Qopf;, as is the case for S<sub>n</sub>. Examples:</p>
<p>
</p><pre class="code">  ? K = nfsplitting(x^4+x+1);
  ? gal = galoisinit(K);
  ? [M,e] = galoischartable(gal);
  ? M~  \\ take the transpose to get the usual orientation
  %4 =
  [1  1  1  1  1]
  
  [1 -1 -1  1  1]
  
  [2  0  0 -1  2]
  
  [3 -1  1  0 -1]
  
  [3  1 -1  0 -1]
  ? e
  %5 = 1
  ? {G = [Vecsmall([1, 2, 3, 4, 5]), Vecsmall([1, 5, 4, 3, 2]),
          Vecsmall([2, 1, 5, 4, 3]), Vecsmall([2, 3, 4, 5, 1]),
          Vecsmall([3, 2, 1, 5, 4]), Vecsmall([3, 4, 5, 1, 2]),
          Vecsmall([4, 3, 2, 1, 5]), Vecsmall([4, 5, 1, 2, 3]),
          Vecsmall([5, 1, 2, 3, 4]), Vecsmall([5, 4, 3, 2, 1])];}
    \\G = D10
  ? [M,e] = galoischartable(G);
  ? M~
  %8 =
  [1  1              1              1]
  
  [1 -1              1              1]
  
  [2  0 -y^3 - y^2 - 1      y^3 + y^2]
  
  [2  0      y^3 + y^2 -y^3 - y^2 - 1]
  ? e
  %9 = 5
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoischartable</b>(GEN gal)</code>.</p>
<p>

<hr>
<div id="se:galoisconjclasses"></div>
<div id="galoisconjclasses"></div>
<h4>galoisconjclasses(<em>gal</em>)</h4>
<p>
<em>gal</em> being output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>,
return the list of conjugacy classes of the underlying group.
The ordering of the classes is consistent with <code><a href="General_number_fields.html#se:galoischartable"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoischartable</a></code>
and the trivial class comes first.</p>
<p></p>
<p>
</p><pre class="code">  ? G = galoisinit(x^6+108);
  ? galoisidentify(G)
  %2 = [6, 1]  \\ S<sub>3</sub>
  ? S = galoisconjclasses(G)
  %3 = [[Vecsmall([1,2,3,4,5,6])],
        [Vecsmall([3,1,2,6,4,5]),Vecsmall([2,3,1,5,6,4])],
        [Vecsmall([6,5,4,3,2,1]),Vecsmall([5,4,6,2,1,3]),
                                 Vecsmall([4,6,5,1,3,2])]]
  ? [[permorder(c[1]),#c] | c &lt;- S ]
  %4 = [[1,1], [3,2], [2,3]]
</pre><p></p>
<p>
This command also accepts subgroups returned by <code><a href="General_number_fields.html#se:galoissubgroups"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubgroups</a></code>:</p>
<p>
</p><pre class="code">  ? subs = galoissubgroups(G); H = subs[5];
  ? galoisidentify(H)
  %2 = [2, 1]  \\ Z/2
  ? S = galoisconjclasses(subgroups_of<sub>G</sub>[5]);
  ? [[permorder(c[1]),#c] | c &lt;- S ]
  %4 = [[1,1], [2,1]]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisconjclasses</b>(GEN gal)</code>.</p>
<p>

<hr>
<div id="se:galoisexport"></div>
<div id="galoisexport"></div>
<h4>galoisexport(<em>gal</em>, {<em>flag</em>})</h4>
<p>
<em>gal</em> being be a Galois group as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>,
export the underlying permutation group as a string suitable
for (no flags or <em>flag</em> = 0) GAP or (<em>flag</em> = 1) Magma. The following example
compute the index of the underlying abstract group in the GAP library:</p>
<p>
</p><pre class="code">  ? G = galoisinit(x^6+108);
  ? s = galoisexport(G)
  %2 = "Group((1, 2, 3)(4, 5, 6), (1, 4)(2, 6)(3, 5))"
  ? extern("echo \"IdGroup("s");\" | gap -q")
  %3 = [6, 1]
  ? galoisidentify(G)
  %4 = [6, 1]
</pre><p></p>
<p>
This command also accepts subgroups returned by <code><a href="General_number_fields.html#se:galoissubgroups"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubgroups</a></code>.</p>
<p>
To <em>import</em> a GAP permutation into gp (for <code><a href="General_number_fields.html#se:galoissubfields"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubfields</a></code> for
instance), the following GAP function may be useful:</p>
<p>
</p><pre class="code">  PermToGP := function(p, n)
    return Permuted([1..n],p);
  end;
  
  gap&gt; p:= (1,26)(2,5)(3,17)(4,32)(6,9)(7,11)(8,24)(10,13)(12,15)(14,27)
    (16,22)(18,28)(19,20)(21,29)(23,31)(25,30)
  gap&gt; PermToGP(p,32);
  [ 26, 5, 17, 32, 2, 9, 11, 24, 6, 13, 7, 15, 10, 27, 12, 22, 3, 28, 20, 19,
    29, 16, 31, 8, 30, 1, 14, 18, 21, 25, 23, 4 ]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisexport</b>(GEN gal, long flag)</code>.</p>
<p>

<hr>
<div id="se:galoisfixedfield"></div>
<div id="galoisfixedfield"></div>
<h4>galoisfixedfield(<em>gal</em>, <em>perm</em>, {<em>flag</em>}, {v = y})</h4>
<p>
<em>gal</em> being be a Galois group as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code> and
<em>perm</em> an element of <em>gal</em>.group, a vector of such elements
or a subgroup of <em>gal</em> as returned by galoissubgroups,
computes the fixed field of <em>gal</em> by the automorphism defined by the
permutations <em>perm</em> of the roots <em>gal</em>.roots. P is guaranteed to
be squarefree modulo <em>gal</em>.p.</p>
<p>
If no flags or <em>flag</em> = 0, output format is the same as for <code>nfsubfield</code>,
returning [P,x] such that P is a polynomial defining the fixed field, and
x is a root of P expressed as a polmod in <em>gal</em>.pol.</p>
<p>
If <em>flag</em> = 1 return only the polynomial P.</p>
<p>
If <em>flag</em> = 2 return [P,x,F] where P and x are as above and F is the
factorization of <em>gal</em>.pol over the field defined by P, where
variable v (y by default) stands for a root of P. The priority of v
must be less than the priority of the variable of <em>gal</em>.pol (see
Section se:priority).
In this case, P is also expressed in the variable v for compatibility
with F. Example:</p>
<p></p>
<p>
</p><pre class="code">  ? G = galoisinit(x^4+1);
  ? galoisfixedfield(G,G.group[2],2)
  %2 = [y^2 - 2, Mod(- x^3 + x, x^4 + 1), [x^2 - y*x + 1, x^2 + y*x + 1]]
</pre><p></p>
<p>
computes the factorization  x^4+1 = (x^2-sqrt{2}x+1)(x^2+sqrt{2}x+1)</p>
<p>
The library syntax is <code>GEN <b>galoisfixedfield</b>(GEN gal, GEN perm, long flag, long v = -1)</code> where <code>v</code> is a variable number.</p>
<p>

<hr>
<div id="se:galoisgetgroup"></div>
<div id="galoisgetgroup"></div>
<h4>galoisgetgroup(a, {b})</h4>
<p>
Query the galpol package for a group of order a with index b in the
GAP4 Small Group library, by Hans Ulrich Besche, Bettina Eick and Eamonn
O'Brien.</p>
<p>
If b is omitted, return the number of isomorphism classes of
groups of order a.</p>
<p>
The library syntax is <code>GEN <b>galoisgetgroup</b>(long a, long b)</code>.
Also available is <code>GEN <b>galoisnbpol</b>(long a)</code> when b
is omitted.</p>
<p>

<hr>
<div id="se:galoisgetname"></div>
<div id="galoisgetname"></div>
<h4>galoisgetname(a, b)</h4>
<p>
Query the galpol package for a string describing the group of order a
with index b in the GAP4 Small Group library, by Hans Ulrich Besche,
Bettina Eick and Eamonn O'Brien.
The strings were generated using the GAP4 function StructureDescription.
It is possible for different groups to have the same name.
The command below outputs the names of all abstract groups of order 12:</p>
<p>
</p><pre class="code">  ? N = galoisgetgroup(12); \\ # of abstract groups of order 12
  ? for(i=1, N, print(i,":",galoisgetname(12,i)))
  1:C3 : C4
  2:C12
  3:A4
  4:D12
  5:C6 x C2
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisgetname</b>(long a, long b)</code>.</p>
<p>

<hr>
<div id="se:galoisgetpol"></div>
<div id="galoisgetpol"></div>
<h4>galoisgetpol(a, {b}, {s})</h4>
<p>
Query the galpol package for a polynomial with Galois group isomorphic to
GAP4(a,b), totally real if s = 1 (default) and totally complex if s = 2. The
output is a vector [<code>pol</code>, <code>den</code>] where</p>
<p>
<b>*</b>  <code>pol</code> is the polynomial of degree a</p>
<p>
<b>*</b> <code>den</code> is the denominator of <code>nfgaloisconj(pol)</code>.
Pass it as an optional argument to <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code> or <code><a href="General_number_fields.html#se:nfgaloisconj"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfgaloisconj</a></code> to
speed them up:</p>
<p>
</p><pre class="code">  ? [pol,den] = galoisgetpol(64,4,1);
  ? G = galoisinit(pol);
  time = 352ms
  ? galoisinit(pol, den);  \\ passing 'den' speeds up the computation
  time = 264ms
  ? % == %`
  %4 = 1  \\ same answer
</pre><p></p>
<p>
If b and s are omitted, return the number of isomorphism classes of
groups of order a.</p>
<p>
The library syntax is <code>GEN <b>galoisgetpol</b>(long a, long b, long s)</code>.
Also available is <code>GEN <b>galoisnbpol</b>(long a)</code> when b and s
are omitted.</p>
<p>

<hr>
<div id="se:galoisidentify"></div>
<div id="galoisidentify"></div>
<h4>galoisidentify(<em>gal</em>)</h4>
<p>
<em>gal</em> being be a Galois group as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>,
output the isomorphism class of the underlying abstract group as a
two-components vector [o,i], where o is the group order, and i is the
group index in the GAP4 Small Group library, by Hans Ulrich Besche, Bettina
Eick and Eamonn O'Brien.</p>
<p>
This command also accepts subgroups returned by <code><a href="General_number_fields.html#se:galoissubgroups"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubgroups</a></code>.</p>
<p>
The current implementation is limited to degree less or equal to 127.
Some larger "easy" orders are also supported.</p>
<p>
The output is similar to the output of the function <code>IdGroup</code> in GAP4.
Note that GAP4 <code>IdGroup</code> handles all groups of order less than 2000
except 1024, so you can use <code><a href="General_number_fields.html#se:galoisexport"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisexport</a></code> and GAP4 to identify large
Galois groups.</p>
<p>
The library syntax is <code>GEN <b>galoisidentify</b>(GEN gal)</code>.</p>
<p>

<hr>
<div id="se:galoisinit"></div>
<div id="galoisinit"></div>
<h4>galoisinit(<em>pol</em>, {<em>den</em>})</h4>
<p>
Computes the Galois group
and all necessary information for computing the fixed fields of the
Galois extension K/&Qopf; where K is the number field defined by
<em>pol</em> (monic irreducible polynomial in &Zopf;[X] or
a number field as output by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>). The extension K/&Qopf; must be
Galois with Galois group "weakly" super-solvable, see below;
returns 0 otherwise. Hence this permits to quickly check whether a polynomial
of order strictly less than 36 is Galois or not.</p>
<p>
The algorithm used is an improved version of the paper
"An efficient algorithm for the computation of Galois automorphisms",
Bill Allombert, Math.&nbsp;Comp, vol.&nbsp;73, 245, 2001, pp.&nbsp;359--375.</p>
<p>
A group G is said to be "weakly" super-solvable if there exists a
normal series</p>
<p>
{1} = H<sub>0</sub>  &triangleleft;  H<sub>1</sub>  &triangleleft; ... &triangleleft;  H<sub>n-1</sub>
 &triangleleft;  H<sub>n</sub></p>
<p>
such that each H<sub>i</sub> is normal in G and for i &lt; n, each quotient group
H<sub>i+1</sub>/H<sub>i</sub> is cyclic, and either H<sub>n</sub> = G (then G is super-solvable) or
G/H<sub>n</sub> is isomorphic to either A<sub>4</sub> or S<sub>4</sub>.</p>
<p>
In practice, almost all small groups are WKSS, the exceptions having order
36(1 exception), 48(2), 56(1), 60(1), 72(5), 75(1), 80(1), 96(10) and  &geq; 
108.</p>
<p>
This function is a prerequisite for most of the <code>galois</code>xxx routines.
For instance:</p>
<p></p>
<p>
</p><pre class="code">  P = x^6 + 108;
  G = galoisinit(P);
  L = galoissubgroups(G);
  vector(#L, i, galoisisabelian(L[i],1))
  vector(#L, i, galoisidentify(L[i]))
</pre><p></p>
<p></p>
<p>
The output is an 8-component vector <em>gal</em>.</p>
<p>
<em>gal</em>[1] contains the polynomial <em>pol</em>
(<code><em>gal</em>.pol</code>).</p>
<p>
<em>gal</em>[2] is a three-components vector [p,e,q] where p is a
prime number (<code><em>gal</em>.p</code>) such that <em>pol</em> totally split
modulo p , e is an integer and q = p^e (<code><em>gal</em>.mod</code>) is the
modulus of the roots in <code><em>gal</em>.roots</code>.</p>
<p>
<em>gal</em>[3] is a vector L containing the p-adic roots of
<em>pol</em> as integers implicitly modulo <code><em>gal</em>.mod</code>.
(<code><em>gal</em>.roots</code>).</p>
<p>
<em>gal</em>[4] is the inverse of the Vandermonde matrix of the
p-adic roots of <em>pol</em>, multiplied by <em>gal</em>[5].</p>
<p>
<em>gal</em>[5] is a multiple of the least common denominator of the
automorphisms expressed as polynomial in a root of <em>pol</em>.</p>
<p>
<em>gal</em>[6] is the Galois group G expressed as a vector of
permutations of L (<code><em>gal</em>.group</code>).</p>
<p>
<em>gal</em>[7] is a generating subset S = [s<sub>1</sub>,...,s<sub>g</sub>] of G
expressed as a vector of permutations of L (<code><em>gal</em>.gen</code>).</p>
<p>
<em>gal</em>[8] contains the relative orders [o<sub>1</sub>,...,o<sub>g</sub>] of
the generators of S (<code><em>gal</em>.orders</code>).</p>
<p>
Let H<sub>n</sub> be as above, we have the following properties:</p>
<p>
&nbsp;&nbsp;<b>*</b> if G/H<sub>n</sub> ~  A<sub>4</sub> then [o<sub>1</sub>,...,o<sub>g</sub>] ends by
[2,2,3].</p>
<p>
&nbsp;&nbsp;<b>*</b> if G/H<sub>n</sub> ~  S<sub>4</sub> then [o<sub>1</sub>,...,o<sub>g</sub>] ends by
[2,2,3,2].</p>
<p>
&nbsp;&nbsp;<b>*</b> for 1 &leq; i &leq; g the subgroup of G generated by
[s<sub>1</sub>,...,s<sub>g</sub>] is normal, with the exception of i = g-2 in the
A<sub>4</sub> case and of i = g-3 in the S<sub>A</sub> case.</p>
<p>
&nbsp;&nbsp;<b>*</b> the relative order o<sub>i</sub> of s<sub>i</sub> is its order in the
quotient group G/<code>&lt;</code>s<sub>1</sub>,...,s<sub>i-1</sub><code>&gt;</code>, with the same
exceptions.</p>
<p>
&nbsp;&nbsp;<b>*</b> for any x &in;  G there exists a unique family
[e<sub>1</sub>,...,e<sub>g</sub>] such that (no exceptions):</p>
<p>
-- for 1 &leq; i &leq; g we have 0 &leq; e<sub>i</sub> &lt; o<sub>i</sub></p>
<p>
-- x = g<sub>1</sub><sup>e<sub>1</sub></sup>g<sub>2</sub><sup>e<sub>2</sub></sup>...g<sub>n</sub><sup>e<sub>n</sub></sup></p>
<p>
If present den must be a suitable value for <em>gal</em>[5].</p>
<p>
The library syntax is <code>GEN <b>galoisinit</b>(GEN pol, GEN den = NULL)</code>.</p>
<p>

<hr>
<div id="se:galoisisabelian"></div>
<div id="galoisisabelian"></div>
<h4>galoisisabelian(<em>gal</em>, {<em>flag</em> = 0})</h4>
<p>
<em>gal</em> being as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>, return 0 if
<em>gal</em> is not an abelian group, and the HNF matrix of <em>gal</em> over
<code>gal.gen</code> if fl = 0, 1 if fl = 1.</p>
<p>
This command also accepts subgroups returned by <code><a href="General_number_fields.html#se:galoissubgroups"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubgroups</a></code>.</p>
<p>
The library syntax is <code>GEN <b>galoisisabelian</b>(GEN gal, long flag)</code>.</p>
<p>

<hr>
<div id="se:galoisisnormal"></div>
<div id="galoisisnormal"></div>
<h4>galoisisnormal(<em>gal</em>, <em>subgrp</em>)</h4>
<p>
<em>gal</em> being as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>, and <em>subgrp</em> a subgroup
of <em>gal</em> as output by <code><a href="General_number_fields.html#se:galoissubgroups"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubgroups</a></code>,return 1 if <em>subgrp</em> is a
normal subgroup of <em>gal</em>, else return 0.</p>
<p>
This command also accepts subgroups returned by <code><a href="General_number_fields.html#se:galoissubgroups"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubgroups</a></code>.</p>
<p>
The library syntax is <code>long <b>galoisisnormal</b>(GEN gal, GEN subgrp)</code>.</p>
<p>

<hr>
<div id="se:galoispermtopol"></div>
<div id="galoispermtopol"></div>
<h4>galoispermtopol(<em>gal</em>, <em>perm</em>)</h4>
<p>
<em>gal</em> being a
Galois group as output by <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code> and <em>perm</em> a element of
<em>gal</em>.group, return the polynomial defining the Galois
automorphism, as output by <code><a href="General_number_fields.html#se:nfgaloisconj"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfgaloisconj</a></code>, attached to the
permutation <em>perm</em> of the roots <em>gal</em>.roots. <em>perm</em> can
also be a vector or matrix, in this case, <code><a href="General_number_fields.html#se:galoispermtopol"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoispermtopol</a></code> is
applied to all components recursively.</p>
<p>
Note that</p>
<p>
</p><pre class="code">  G = galoisinit(pol);
  galoispermtopol(G, G[6])~
</pre><p></p>
<p>
is equivalent to <code>nfgaloisconj(pol)</code>, if degree of <em>pol</em> is greater
or equal to 2.</p>
<p>
The library syntax is <code>GEN <b>galoispermtopol</b>(GEN gal, GEN perm)</code>.</p>
<p>

<hr>
<div id="se:galoissubcyclo"></div>
<div id="galoissubcyclo"></div>
<h4>galoissubcyclo(N, H, {<em>fl</em> = 0}, {v})</h4>
<p>
Computes the subextension of &Qopf;(&zeta;<sub>n</sub>) fixed by the subgroup
H  &subset;  (&Zopf;/n&Zopf;)<sup>*</sup>. By the Kronecker-Weber theorem, all abelian number
fields can be generated in this way (uniquely if n is taken to be minimal).</p>
<p>
The pair (n, H) is deduced from the parameters (N, H) as follows</p>
<p>
<b>*</b> N an integer: then n = N; H is a generator, i.e. an
integer or an integer modulo n; or a vector of generators.</p>
<p>
<b>*</b> N the output of <code><a href="Arithmetic_functions.html#se:znstar"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">znstar</a></code>(n) or <code><a href="Arithmetic_functions.html#se:znstar"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">znstar</a></code>(n,1).
H as in the first case above, or a matrix, taken to be a HNF left divisor
of the SNF for (&Zopf;/n&Zopf;)<sup>*</sup>
(<code>N.cyc</code>), giving the generators of H in terms of <code>N.gen</code>.</p>
<p>
<b>*</b> N the output of <code>bnrinit(bnfinit(y), m)</code> where m is a
module. H as in the first case, or a matrix taken to be a HNF left
divisor of the SNF for the ray class group modulo m
(of type <code>N.cyc</code>), giving the generators of H in terms of
<code>N.bid.gen</code> ( = <code>N</code>.gen if N includes generators).</p>
<p>
In this last case, beware that H is understood relatively to N; in
particular, if the infinite place does not divide the module, e.g if m is
an integer, then it is not a subgroup of (&Zopf;/n&Zopf;)<sup>*</sup>, but of its quotient by
{&#177; 1}.</p>
<p>
If fl = 0, compute a polynomial (in the variable <em>v</em>) defining
the subfield of &Qopf;(&zeta;<sub>n</sub>) fixed by the subgroup <em>H</em> of (&Zopf;/n&Zopf;)<sup>*</sup>.</p>
<p>
If fl = 1, compute only the conductor of the abelian extension, as a module.</p>
<p>
If fl = 2, output [pol, N], where pol is the polynomial as output when
fl = 0 and N the conductor as output when fl = 1.</p>
<p>
The following function can be used to compute all subfields of
&Qopf;(&zeta;<sub>n</sub>) (of exact degree <code>d</code>, if <code>d</code> is set):</p>
<p>
</p><pre class="code">  subcyclo(n, d = -1)=
  { my(bnr,L,IndexBound);
    IndexBound = if (d &lt; 0, n, [d]);
    bnr = bnrinit(bnfinit(y), [n,[1]]);
    L = subgrouplist(bnr, IndexBound, 1);
    vector(#L,i, galoissubcyclo(bnr,L[i]));
  }
</pre><p></p>
<p>
Setting <code>L = subgrouplist(bnr, IndexBound)</code> would produce subfields of
exact conductor n oo .</p>
<p>
The library syntax is <code>GEN <b>galoissubcyclo</b>(GEN N, GEN H = NULL, long fl, long v = -1)</code> where <code>v</code> is a variable number.</p>
<p>

<hr>
<div id="se:galoissubfields"></div>
<div id="galoissubfields"></div>
<h4>galoissubfields(G, {<em>flag</em> = 0}, {v})</h4>
<p>
Outputs all the subfields of the Galois group <em>G</em>, as a vector.
This works by applying <code><a href="General_number_fields.html#se:galoisfixedfield"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisfixedfield</a></code> to all subgroups. The meaning of
<em>flag</em> is the same as for <code><a href="General_number_fields.html#se:galoisfixedfield"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisfixedfield</a></code>.</p>
<p>
The library syntax is <code>GEN <b>galoissubfields</b>(GEN G, long flag, long v = -1)</code> where <code>v</code> is a variable number.</p>
<p>

<hr>
<div id="se:galoissubgroups"></div>
<div id="galoissubgroups"></div>
<h4>galoissubgroups(G)</h4>
<p>
Outputs all the subgroups of the Galois group <code>gal</code>. A subgroup is a
vector [<em>gen</em>, <em>orders</em>], with the same meaning
as for <em>gal</em>.gen and <em>gal</em>.orders. Hence <em>gen</em> is a vector of
permutations generating the subgroup, and <em>orders</em> is the relatives
orders of the generators. The cardinality of a subgroup is the product of the
relative orders. Such subgroup can be used instead of a Galois group in the
following command: <code><a href="General_number_fields.html#se:galoisisabelian"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisisabelian</a></code>, <code><a href="General_number_fields.html#se:galoissubgroups"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubgroups</a></code>,
<code><a href="General_number_fields.html#se:galoisexport"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisexport</a></code> and <code><a href="General_number_fields.html#se:galoisidentify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisidentify</a></code>.</p>
<p>
To get the subfield fixed by a subgroup <em>sub</em> of <em>gal</em>, use</p>
<p>
</p><pre class="code">  galoisfixedfield(gal,sub[1])
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoissubgroups</b>(GEN G)</code>.</p>
<p>

<hr>
<div id="se:idealadd"></div>
<div id="idealadd"></div>
<h4>idealadd(<em>nf</em>, x, y)</h4>
<p>
Sum of the two ideals x and y in the number field <em>nf</em>. The
result is given in HNF.</p>
<p>
</p><pre class="code">   ? K = nfinit(x^2 + 1);
   ? a = idealadd(K, 2, x + 1)  \\ ideal generated by 2 and 1+I
   %2 =
   [2 1]
  
   [0 1]
   ? pr = idealprimedec(K, 5)[1];  \\ a prime ideal above 5
   ? idealadd(K, a, pr)     \\ coprime, as expected
   %4 =
   [1 0]
  
   [0 1]
</pre><p></p>
<p>
This function cannot be used to add arbitrary &Zopf;-modules, since it assumes
that its arguments are ideals:</p>
<p>
</p><pre class="code">    ? b = Mat([1,0]~);
    ? idealadd(K, b, b)     \\ only square t_MATs represent ideals
    *** idealadd: non-square t_MAT in idealtyp.
    ? c = [2, 0; 2, 0]; idealadd(K, c, c)   \\ non-sense
    %6 =
    [2 0]
  
    [0 2]
    ? d = [1, 0; 0, 2]; idealadd(K, d, d)   \\ non-sense
    %7 =
    [1 0]
  
    [0 1]
  
</pre><p>
In the last two examples, we get wrong results since the
matrices c and d do not correspond to an ideal: the &Zopf;-span of their
columns (as usual interpreted as coordinates with respect to the integer basis
<code>K.zk</code>) is not an O<sub>K</sub>-module. To add arbitrary &Zopf;-modules generated
by the columns of matrices A and B, use <code>mathnf(concat(A,B))</code>.</p>
<p>
The library syntax is <code>GEN <b>idealadd</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:idealaddtoone"></div>
<div id="idealaddtoone"></div>
<h4>idealaddtoone(<em>nf</em>, x, {y})</h4>
<p>
x and y being two co-prime
integral ideals (given in any form), this gives a two-component row vector
[a,b] such that a &in;  x, b &in;  y and a+b = 1.</p>
<p>
The alternative syntax <code><a href="General_number_fields.html#se:idealaddtoone"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealaddtoone</a></code>(<em>nf</em>,v), is supported, where
v is a k-component vector of ideals (given in any form) which sum to
&Zopf;<sub>K</sub>. This outputs a k-component vector e such that e[i] &in;  x[i] for
1 &leq; i &leq; k and &sum;<sub>1 &leq; i &leq; k</sub>e[i] = 1.</p>
<p>
The library syntax is <code>GEN <b>idealaddtoone0</b>(GEN nf, GEN x, GEN y = NULL)</code>.</p>
<p>

<hr>
<div id="se:idealappr"></div>
<div id="idealappr"></div>
<h4>idealappr(<em>nf</em>, x, {<em>flag</em>})</h4>
<p>
If x is a fractional ideal
(given in any form), gives an element &alpha; in <em>nf</em> such that for
all prime ideals &pfr; such that the valuation of x at &pfr; is
non-zero, we have v<sub>&pfr;</sub>(&alpha;) = v<sub>&pfr;</sub>(x), and
v<sub>&pfr;</sub>(&alpha;) &geq; 0 for all other &pfr;.</p>
<p>
The argument x may also be given as a prime ideal factorization, as
output by <code><a href="General_number_fields.html#se:idealfactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealfactor</a></code>, but allowing zero exponents.
This yields an element &alpha; such that for all prime ideals &pfr;
occurring in x, v<sub>&pfr;</sub>(&alpha;) = v<sub>&pfr;</sub>(x);
for all other prime ideals, v<sub>&pfr;</sub>(&alpha;) &geq; 0.</p>
<p>
flag is deprecated (ignored), kept for backward compatibility.</p>
<p>
The library syntax is <code>GEN <b>idealappr0</b>(GEN nf, GEN x, long flag)</code>.
Use directly <code>GEN <b>idealappr</b>(GEN nf, GEN x)</code> since <em>flag</em> is ignored.</p>
<p>

<hr>
<div id="se:idealchinese"></div>
<div id="idealchinese"></div>
<h4>idealchinese(<em>nf</em>, x, {y})</h4>
<p>
x being a prime ideal factorization (i.e.&nbsp;a 2-columns matrix whose first
column contains prime ideals and the second column contains integral
exponents), y a vector of elements in <em>nf</em> indexed by the ideals in
x, computes an element b such that</p>
<p>
v<sub>&pfr;</sub>(b - y<sub>&pfr;</sub>) &geq; v<sub>&pfr;</sub>(x) for all prime ideals
in x and v<sub>&pfr;</sub>(b) &geq; 0 for all other &pfr;.</p>
<p></p>
<p>
</p><pre class="code">  ? K = nfinit(t^2-2);
  ? x = idealfactor(K, 2^2*3)
  %2 =
  [[2, [0, 1]~, 2, 1, [0, 2; 1, 0]] 4]
  
  [           [3, [3, 0]~, 1, 2, 1] 1]
  ? y = [t,1];
  ? idealchinese(K, x, y)
  %4 = [4, -3]~
</pre><p></p>
<p></p>
<p>
The argument x may also be of the form [x, s] where the first component
is as above and s is a vector of signs, with r<sub>1</sub> components
s<sub>i</sub> in {-1,0,1}:
if &sigma;<sub>i</sub> denotes the i-th real embedding of the number field,
the element b returned satisfies further
<code><a href="Standard_monadic_or_dyadic_operators.html#se:sign"
    onClick="parent.itemFrame.location='cont_Standard_monadic_or_dyadic_operators.html'">sign</a></code>(&sigma;<sub>i</sub>(b)) = s<sub>i</sub> for all i such that s<sub>i</sub> = &#177;1.
In other words, the sign is fixed to s<sub>i</sub> at the i-th embedding whenever
s<sub>i</sub> is non-zero.</p>
<p>
</p><pre class="code">  ? idealchinese(K, [x, [1,1]], y)
  %5 = [16, -3]~
  ? idealchinese(K, [x, [-1,-1]], y)
  %6 = [-20, -3]~
  ? idealchinese(K, [x, [1,-1]], y)
  %7 = [4, -3]~
</pre><p></p>
<p></p>
<p>
If y is omitted, return a data structure which can be used in
place of x in later calls and allows to solve many chinese remainder
problems for a given x more efficiently.</p>
<p>
</p><pre class="code">  ? C = idealchinese(K, [x, [1,1]]);
  ? idealchinese(K, C, y) \\ as above
  %9 = [16, -3]~
  ? for(i=1,10^4, idealchinese(K,C,y))  \\ ... but faster !
  time = 80 ms.
  ? for(i=1,10^4, idealchinese(K,[x,[1,1]],y))
  time = 224 ms.
</pre><p></p>
<p>
Finally, this structure is itself allowed in place of x, the
new s overriding the one already present in the structure. This allows to
initialize for different sign conditions more efficiently when the underlying
ideal factorization remains the same.</p>
<p>
</p><pre class="code">  ? D = idealchinese(K, [C, [1,-1]]);   \\ replaces [1,1]
  ? idealchinese(K, D, y)
  %13 = [4, -3]~
  ? for(i=1,10^4,idealchinese(K,[C,[1,-1]]))
  time = 40 ms.   \\ faster than starting from scratch
  ? for(i=1,10^4,idealchinese(K,[x,[1,-1]]))
  time = 128 ms.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealchinese</b>(GEN nf, GEN x, GEN y = NULL)</code>.
Also available is
<code>GEN <b>idealchineseinit</b>(GEN nf, GEN x)</code> when y = <code>NULL</code>.</p>
<p>

<hr>
<div id="se:idealcoprime"></div>
<div id="idealcoprime"></div>
<h4>idealcoprime(<em>nf</em>, x, y)</h4>
<p>
Given two integral ideals x and y
in the number field <em>nf</em>, returns a &beta; in the field,
such that &beta;.x is an integral ideal coprime to y.</p>
<p>
The library syntax is <code>GEN <b>idealcoprime</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:idealdiv"></div>
<div id="idealdiv"></div>
<h4>idealdiv(<em>nf</em>, x, y, {<em>flag</em> = 0})</h4>
<p>
Quotient x.y<sup>-1</sup> of the two ideals x and y in the number
field <em>nf</em>. The result is given in HNF.</p>
<p>
If <em>flag</em> is non-zero, the quotient x.y<sup>-1</sup> is assumed to be an
integral ideal. This can be much faster when the norm of the quotient is
small even though the norms of x and y are large. More precisely,
the algorithm cheaply removes all maximal ideals above rational
primes such that v<sub>p</sub>(Nx) = v<sub>p</sub>(Ny).</p>
<p>
The library syntax is <code>GEN <b>idealdiv0</b>(GEN nf, GEN x, GEN y, long flag)</code>.
Also available are <code>GEN <b>idealdiv</b>(GEN nf, GEN x, GEN y)</code>
(<em>flag</em> = 0) and <code>GEN <b>idealdivexact</b>(GEN nf, GEN x, GEN y)</code> (<em>flag</em> = 1).</p>
<p>

<hr>
<div id="se:idealfactor"></div>
<div id="idealfactor"></div>
<h4>idealfactor(<em>nf</em>, x, {<em>lim</em>})</h4>
<p>
Factors into prime ideal powers the ideal x in the number field
<em>nf</em>. The output format is similar to the <code><a href="Arithmetic_functions.html#se:factor"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">factor</a></code> function, and
the prime ideals are represented in the form output by the
<code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> function. If <em>lim</em> is set, return partial
factorization, including only prime ideals above rational primes
 &lt; <em>lim</em>.</p>
<p>
</p><pre class="code">  ? nf = nfinit(x^3-2);
  ? idealfactor(nf, x) \\ a prime ideal above 2
  %2 =
  [[2, [0, 1, 0]~, 3, 1, ...] 1]
  
  ? A = idealhnf(nf, 6*x, 4+2*x+x^2)
  %3 =
  [6 0 4]
  
  [0 6 2]
  
  [0 0 1]
  
  ? idealfactor(nf, A)
  %4 =
   [[2, [0, 1, 0]~, 3, 1, ...] 2]
  
   [[3, [1, 1, 0]~, 3, 1, ...] 2]
  
  ? idealfactor(nf, A, 3) \\ restrict to primes above p &lt; 3
  %5 =
  [[2, [0, 1, 0]~, 3, 1, ...] 2]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>gpidealfactor</b>(GEN nf, GEN x, GEN lim = NULL)</code>.
This function should only be used by the <code>gp</code> interface. Use
directly <code>GEN <b>idealfactor</b>(GEN x)</code> or
<code>GEN <b>idealfactor_limit</b>(GEN x, ulong lim)</code>.</p>
<p>

<hr>
<div id="se:idealfactorback"></div>
<div id="idealfactorback"></div>
<h4>idealfactorback(<em>nf</em>, f, {e}, {<em>flag</em> = 0})</h4>
<p>
Gives back the ideal corresponding to a factorization. The integer 1
corresponds to the empty factorization.
If e is present, e and f must be vectors of the same length (e being
integral), and the corresponding factorization is the product of the
f[i]<sup>e[i]</sup>.</p>
<p>
If not, and f is vector, it is understood as in the preceding case with e
a vector of 1s: we return the product of the f[i]. Finally, f can be a
regular factorization, as produced by <code><a href="General_number_fields.html#se:idealfactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealfactor</a></code>.</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2+1); idealfactor(nf, 4 + 2*y)
  %1 =
  [[2, [1, 1]~, 2, 1, [1, 1]~] 2]
  
  [[5, [2, 1]~, 1, 1, [-2, 1]~] 1]
  
  ? idealfactorback(nf, %)
  %2 =
  [10 4]
  
  [0  2]
  
  ? f = %1[,1]; e = %1[,2]; idealfactorback(nf, f, e)
  %3 =
  [10 4]
  
  [0  2]
  
  ? % == idealhnf(nf, 4 + 2*y)
  %4 = 1
</pre><p></p>
<p>
If <code>flag</code> is non-zero, perform ideal reductions (<code><a href="General_number_fields.html#se:idealred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealred</a></code>) along the
way. This is most useful if the ideals involved are all <em>extended</em>
ideals (for instance with trivial principal part), so that the principal parts
extracted by <code><a href="General_number_fields.html#se:idealred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealred</a></code> are not lost. Here is an example:</p>
<p>
</p><pre class="code">  ? f = vector(#f, i, [f[i], [;]]);  \\ transform to extended ideals
  ? idealfactorback(nf, f, e, 1)
  %6 = [[1, 0; 0, 1], [2, 1; [2, 1]~, 1]]
  ? nffactorback(nf, %[2])
  %7 = [4, 2]~
</pre><p></p>
<p>
The extended ideal returned in <code>%6</code> is the trivial ideal 1, extended
with a principal generator given in factored form. We use <code><a href="General_number_fields.html#se:nffactorback"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nffactorback</a></code>
to recover it in standard form.</p>
<p>
The library syntax is <code>GEN <b>idealfactorback</b>(GEN nf, GEN f, GEN e = NULL, long flag)</code>.</p>
<p>

<hr>
<div id="se:idealfrobenius"></div>
<div id="idealfrobenius"></div>
<h4>idealfrobenius(<em>nf</em>, <em>gal</em>, <em>pr</em>)</h4>
<p>
Let K be the number field defined by nf and assume K/&Qopf; be a
Galois extension with Galois group given <code>gal = galoisinit(nf)</code>,
and that <em>pr</em> is an unramified prime ideal &pfr; in <code>prid</code>
format.
This function returns a permutation of <code>gal.group</code> which defines
the Frobenius element Frob<sub>&pfr;</sub> attached to &pfr;.
If p is the unique prime number in &pfr;, then
Frob(x) = x^p mod &pfr; for all x &in; &Zopf;<sub>K</sub>.</p>
<p>
</p><pre class="code">  ? nf = nfinit(polcyclo(31));
  ? gal = galoisinit(nf);
  ? pr = idealprimedec(nf,101)[1];
  ? g = idealfrobenius(nf,gal,pr);
  ? galoispermtopol(gal,g)
  %5 = x^8
</pre><p>
This is correct since 101 = 8 mod 31.</p>
<p>
The library syntax is <code>GEN <b>idealfrobenius</b>(GEN nf, GEN gal, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:idealhnf"></div>
<div id="idealhnf"></div>
<h4>idealhnf(<em>nf</em>, u, {v})</h4>
<p>
Gives the Hermite normal form of the ideal u&Zopf;<sub>K</sub>+v&Zopf;<sub>K</sub>, where u
and v are elements of the number field K defined by <em>nf</em>.</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^3 - 2);
  ? idealhnf(nf, 2, y+1)
  %2 =
  [1 0 0]
  
  [0 1 0]
  
  [0 0 1]
  ? idealhnf(nf, y/2, [0,0,1/3]~)
  %3 =
  [1/3 0 0]
  
  [0 1/6 0]
  
  [0 0 1/6]
</pre><p></p>
<p></p>
<p>
If b is omitted, returns the HNF of the ideal defined by u: u may be an
algebraic number (defining a principal ideal), a maximal ideal (as given by
<code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> or <code><a href="General_number_fields.html#se:idealfactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealfactor</a></code>), or a matrix whose columns give
generators for the ideal. This last format is a little complicated, but
useful to reduce general modules to the canonical form once in a while:</p>
<p>
<b>*</b> if strictly less than N = [K:&Qopf;] generators are given, u
is the &Zopf;<sub>K</sub>-module they generate,</p>
<p>
<b>*</b> if N or more are given, it is <em>assumed</em> that they form a
&Zopf;-basis of the ideal, in particular that the matrix has maximal rank N.
This acts as <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:mathnf"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">mathnf</a></code> since the &Zopf;<sub>K</sub>-module structure is (taken for
granted hence) not taken into account in this case.</p>
<p>
</p><pre class="code">  ? idealhnf(nf, idealprimedec(nf,2)[1])
  %4 =
  [2 0 0]
  
  [0 1 0]
  
  [0 0 1]
  ? idealhnf(nf, [1,2;2,3;3,4])
  %5 =
  [1 0 0]
  
  [0 1 0]
  
  [0 0 1]
</pre><p>
Finally, when K is quadratic with discriminant D<sub>K</sub>, we
allow u =  <code>Qfb(a,b,c)</code>, provided b^2 - 4ac = D<sub>K</sub>. As usual,
this represents the ideal a &Zopf; + (1/2)(-b + sqrt{D<sub>K</sub>}) &Zopf;.</p>
<p>
</p><pre class="code">  ? K = nfinit(x^2 - 60); K.disc
  %1 = 60
  ? idealhnf(K, qfbprimeform(60,2))
  %2 =
  [2 1]
  
  [0 1]
  ? idealhnf(K, Qfb(1,2,3))
    ***   at top-level: idealhnf(K,Qfb(1,2,3
    ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
    *** idealhnf: Qfb(1, 2, 3) has discriminant != 60 in idealhnf.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealhnf0</b>(GEN nf, GEN u, GEN v = NULL)</code>.
Also available is <code>GEN <b>idealhnf</b>(GEN nf, GEN a)</code>.</p>
<p>

<hr>
<div id="se:idealintersect"></div>
<div id="idealintersect"></div>
<h4>idealintersect(<em>nf</em>, A, B)</h4>
<p>
Intersection of the two ideals
A and B in the number field <em>nf</em>. The result is given in HNF.</p>
<p>
</p><pre class="code">  ? nf = nfinit(x^2+1);
  ? idealintersect(nf, 2, x+1)
  %2 =
  [2 0]
  
  [0 2]
</pre><p></p>
<p></p>
<p>
This function does not apply to general &Zopf;-modules, e.g.&nbsp;orders, since its
arguments are replaced by the ideals they generate. The following script
intersects &Zopf;-modules A and B given by matrices of compatible
dimensions with integer coefficients:</p>
<p>
</p><pre class="code">  ZM_intersect(A,B) =
  { my(Ker = matkerint(concat(A,B)));
    mathnf( A * Ker[1..#A,] )
  }
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealintersect</b>(GEN nf, GEN A, GEN B)</code>.</p>
<p>

<hr>
<div id="se:idealinv"></div>
<div id="idealinv"></div>
<h4>idealinv(<em>nf</em>, x)</h4>
<p>
Inverse of the ideal x in the
number field <em>nf</em>, given in HNF. If x is an extended
ideal, its principal part is suitably
updated: i.e. inverting [I,t], yields [I<sup>-1</sup>, 1/t].</p>
<p>
The library syntax is <code>GEN <b>idealinv</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:idealispower"></div>
<div id="idealispower"></div>
<h4>idealispower(<em>nf</em>, A, n, {&B})</h4>
<p>
Let <em>nf</em> be a number field and n &gt; 0 be a positive integer.
Return 1 if the fractional ideal A = B^n is an n-th power and 0
otherwise. If the argument B is present, set it to the n-th root of A,
in HNF.</p>
<p>
</p><pre class="code">  ? K = nfinit(x^3 - 2);
  ? A = [46875, 30966, 9573; 0, 3, 0; 0, 0, 3];
  ? idealispower(K, A, 3, &B)
  %3 = 1
  ? B
  %4 =
  [75 22 41]
  
  [ 0  1  0]
  
  [ 0  0  1]
  
  ? A = [9375, 2841, 198; 0, 3, 0; 0, 0, 3];
  ? idealispower(K, A, 3)
  %5 = 0
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>idealispower</b>(GEN nf, GEN A, long n, GEN *B = NULL)</code>.</p>
<p>

<hr>
<div id="se:ideallist"></div>
<div id="ideallist"></div>
<h4>ideallist(<em>nf</em>, <em>bound</em>, {<em>flag</em> = 4})</h4>
<p>
Computes the list
of all ideals of norm less or equal to <em>bound</em> in the number field
<em>nf</em>. The result is a row vector with exactly <em>bound</em> components.
Each component is itself a row vector containing the information about
ideals of a given norm, in no specific order, depending on the value of
<em>flag</em>:</p>
<p>
The possible values of <em>flag</em> are:</p>
<p>
&nbsp;&nbsp;0: give the <em>bid</em> attached to the ideals, without generators.</p>
<p>
&nbsp;&nbsp;1: as 0, but include the generators in the <em>bid</em>.</p>
<p>
&nbsp;&nbsp;2: in this case, <em>nf</em> must be a <em>bnf</em> with units. Each
component is of the form [<em>bid</em>,U], where <em>bid</em> is as case 0
and U is a vector of discrete logarithms of the units. More precisely, it
gives the <code><a href="General_number_fields.html#se:ideallog"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallog</a></code>s with respect to <em>bid</em> of <code>bnf.tufu</code>.
This structure is technical, and only meant to be used in conjunction with
<code><a href="General_number_fields.html#se:bnrclassnolist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrclassnolist</a></code> or <code><a href="General_number_fields.html#se:bnrdisclist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrdisclist</a></code>.</p>
<p>
&nbsp;&nbsp;3: as 2, but include the generators in the <em>bid</em>.</p>
<p>
&nbsp;&nbsp;4: give only the HNF of the ideal.</p>
<p></p>
<p>
</p><pre class="code">  ? nf = nfinit(x^2+1);
  ? L = ideallist(nf, 100);
  ? L[1]
  %3 = [[1, 0; 0, 1]]  \\  A single ideal of norm 1
  ? #L[65]
  %4 = 4               \\  There are 4 ideals of norm 4 in &Zopf;[i]
</pre><p></p>
<p>
If one wants more information, one could do instead:</p>
<p>
</p><pre class="code">  ? nf = nfinit(x^2+1);
  ? L = ideallist(nf, 100, 0);
  ? l = L[25]; vector(#l, i, l[i].clgp)
  %3 = [[20, [20]], [16, [4, 4]], [20, [20]]]
  ? l[1].mod
  %4 = [[25, 18; 0, 1], []]
  ? l[2].mod
  %5 = [[5, 0; 0, 5], []]
  ? l[3].mod
  %6 = [[25, 7; 0, 1], []]
</pre><p>
where we ask for the structures of the (&Zopf;[i]/I)<sup>*</sup> for all
three ideals of norm 25. In fact, for all moduli with finite part of norm
25 and trivial Archimedean part, as the last 3 commands show. See
<code><a href="General_number_fields.html#se:ideallistarch"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallistarch</a></code> to treat general moduli.</p>
<p>
The library syntax is <code>GEN <b>ideallist0</b>(GEN nf, long bound, long flag)</code>.</p>
<p>

<hr>
<div id="se:ideallistarch"></div>
<div id="ideallistarch"></div>
<h4>ideallistarch(<em>nf</em>, <em>list</em>, <em>arch</em>)</h4>
<p>
<em>list</em> is a vector of vectors of bid's, as output by <code><a href="General_number_fields.html#se:ideallist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallist</a></code> with
flag 0 to 3. Return a vector of vectors with the same number of
components as the original <em>list</em>. The leaves give information about
moduli whose finite part is as in original list, in the same order, and
Archimedean part is now <em>arch</em> (it was originally trivial). The
information contained is of the same kind as was present in the input; see
<code><a href="General_number_fields.html#se:ideallist"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallist</a></code>, in particular the meaning of <em>flag</em>.</p>
<p></p>
<p>
</p><pre class="code">  ? bnf = bnfinit(x^2-2);
  ? bnf.sign
  %2 = [2, 0]                         \\  two places at infinity
  ? L = ideallist(bnf, 100, 0);
  ? l = L[98]; vector(#l, i, l[i].clgp)
  %4 = [[42, [42]], [36, [6, 6]], [42, [42]]]
  ? La = ideallistarch(bnf, L, [1,1]); \\  add them to the modulus
  ? l = La[98]; vector(#l, i, l[i].clgp)
  %6 = [[168, [42, 2, 2]], [144, [6, 6, 2, 2]], [168, [42, 2, 2]]]
</pre><p></p>
<p>
Of course, the results above are obvious: adding t places at infinity will
add t copies of &Zopf;/2&Zopf; to (&Zopf;<sub>K</sub>/f)<sup>*</sup>. The following application
is more typical:</p>
<p>
</p><pre class="code">  ? L = ideallist(bnf, 100, 2);        \\  units are required now
  ? La = ideallistarch(bnf, L, [1,1]);
  ? H = bnrclassnolist(bnf, La);
  ? H[98];
  %4 = [2, 12, 2]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>ideallistarch</b>(GEN nf, GEN list, GEN arch)</code>.</p>
<p>

<hr>
<div id="se:ideallog"></div>
<div id="ideallog"></div>
<h4>ideallog({<em>nf</em>}, x, <em>bid</em>)</h4>
<p>
<em>nf</em> is a number field,
<em>bid</em> is as output by <code>idealstar(nf, D,...)</code> and x a
non-necessarily integral element of <em>nf</em> which must have valuation
equal to 0 at all prime ideals in the support of <code>D</code>. This function
computes the discrete logarithm of x on the generators given in
<code><em>bid</em>.gen</code>. In other words, if g<sub>i</sub> are these generators, of orders
d<sub>i</sub> respectively, the result is a column vector of integers (x<sub>i</sub>) such
that 0 &leq; x<sub>i</sub> &lt; d<sub>i</sub> and
x = &prod;<sub>i</sub> g<sub>i</sub><sup>x<sub>i</sub></sup> (mod <sup>*</sup>D) .
Note that when the support of <code>D</code> contains places at infinity, this
congruence implies also sign conditions on the attached real embeddings.
See <code><a href="Arithmetic_functions.html#se:znlog"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">znlog</a></code> for the limitations of the underlying discrete log algorithms.</p>
<p>
When <em>nf</em> is omitted, take it to be the rational number field. In that
case, x must be a <code>t_INT</code> and <em>bid</em> must have been initialized by
<code>znstar(N,1)</code>.</p>
<p>
The library syntax is <code>GEN <b>ideallog</b>(GEN nf = NULL, GEN x, GEN bid)</code>.
Also available is
<code>GEN <b>Zideallog</b>(GEN bid, GEN x)</code> when <code>nf</code> is <code>NULL</code>.</p>
<p>

<hr>
<div id="se:idealmin"></div>
<div id="idealmin"></div>
<h4>idealmin(<em>nf</em>, <em>ix</em>, {<em>vdir</em>})</h4>
<p>
<em>This function is useless and kept for backward compatibility only,
use <code><a href="General_number_fields.html#se:idealred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealred</a></code></em>. Computes a pseudo-minimum of the ideal x in the
direction <em>vdir</em> in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>idealmin</b>(GEN nf, GEN ix, GEN vdir = NULL)</code>.</p>
<p>

<hr>
<div id="se:idealmul"></div>
<div id="idealmul"></div>
<h4>idealmul(<em>nf</em>, x, y, {<em>flag</em> = 0})</h4>
<p>
Ideal multiplication of the ideals x and y in the number field
<em>nf</em>; the result is the ideal product in HNF. If either x or y
are extended ideals, their principal part is suitably
updated: i.e. multiplying [I,t], [J,u] yields [IJ, tu]; multiplying
I and [J, u] yields [IJ, u].</p>
<p>
</p><pre class="code">  ? nf = nfinit(x^2 + 1);
  ? idealmul(nf, 2, x+1)
  %2 =
  [4 2]
  
  [0 2]
  ? idealmul(nf, [2, x], x+1)        \\ extended ideal * ideal
  %3 = [[4, 2; 0, 2], x]
  ? idealmul(nf, [2, x], [x+1, x])   \\ two extended ideals
  %4 = [[4, 2; 0, 2], [-1, 0]~]
</pre><p></p>
<p>
If <em>flag</em> is non-zero, reduce the result using <code><a href="General_number_fields.html#se:idealred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealred</a></code>.</p>
<p>
The library syntax is <code>GEN <b>idealmul0</b>(GEN nf, GEN x, GEN y, long flag)</code>.</p>
<p>
See also
<code>GEN <b>idealmul</b>(GEN nf, GEN x, GEN y)</code> (<em>flag</em> = 0) and
<code>GEN <b>idealmulred</b>(GEN nf, GEN x, GEN y)</code> (<em>flag</em> != 0).</p>
<p>

<hr>
<div id="se:idealnorm"></div>
<div id="idealnorm"></div>
<h4>idealnorm(<em>nf</em>, x)</h4>
<p>
Computes the norm of the ideal&nbsp;x in the number field&nbsp;<em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>idealnorm</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:idealnumden"></div>
<div id="idealnumden"></div>
<h4>idealnumden(<em>nf</em>, x)</h4>
<p>
Returns [A,B], where A,B are coprime integer ideals
such that x = A/B, in the number field <em>nf</em>.</p>
<p>
</p><pre class="code">  ? nf = nfinit(x^2+1);
  ? idealnumden(nf, (x+1)/2)
  %2 = [[1, 0; 0, 1], [2, 1; 0, 1]]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealnumden</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:idealpow"></div>
<div id="idealpow"></div>
<h4>idealpow(<em>nf</em>, x, k, {<em>flag</em> = 0})</h4>
<p>
Computes the k-th power of
the ideal x in the number field <em>nf</em>; k &in; &Zopf;.
If x is an extended
ideal, its principal part is suitably
updated: i.e. raising [I,t] to the k-th power, yields [I^k, t^k].</p>
<p>
If <em>flag</em> is non-zero, reduce the result using <code><a href="General_number_fields.html#se:idealred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealred</a></code>, <em>throughout
the (binary) powering process</em>; in particular, this is <em>not</em> the same
as <code><a href="General_number_fields.html#se:idealpow"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealpow</a></code>(<em>nf</em>,x,k) followed by reduction.</p>
<p>
The library syntax is <code>GEN <b>idealpow0</b>(GEN nf, GEN x, GEN k, long flag)</code>.</p>
<p>
See also
<code>GEN <b>idealpow</b>(GEN nf, GEN x, GEN k)</code> and
<code>GEN <b>idealpows</b>(GEN nf, GEN x, long k)</code> (<em>flag</em> = 0).
Corresponding to <em>flag</em> = 1 is <code>GEN <b>idealpowred</b>(GEN nf, GEN vp, GEN k)</code>.</p>
<p>

<hr>
<div id="se:idealprimedec"></div>
<div id="idealprimedec"></div>
<h4>idealprimedec(<em>nf</em>, p, {f = 0})</h4>
<p>
Computes the prime ideal
decomposition of the (positive) prime number p in the number field K
represented by <em>nf</em>. If a non-prime p is given the result is undefined.
If f is present and non-zero, restrict the result to primes of residue
degree  &leq; f.</p>
<p>
The result is a vector of <em>prid</em> structures, each representing one of the
prime ideals above p in the number field <em>nf</em>. The representation
<code>pr</code> = [p,a,e,f,<em>mb</em>] of a prime ideal means the following: a
is an algebraic integer in the maximal order &Zopf;<sub>K</sub> and the prime ideal is
equal to &pfr; = p&Zopf;<sub>K</sub> + a&Zopf;<sub>K</sub>;
e is the ramification index; f is the residual index;
finally, <em>mb</em> is the multiplication table attached to the algebraic
integer b is such that &pfr;<sup>-1</sup> = &Zopf;<sub>K</sub>+ b/ p&Zopf;<sub>K</sub>, which is used
internally to compute valuations. In other words if p is inert,
then <em>mb</em> is the integer 1, and otherwise it is a square <code>t_MAT</code>
whose j-th column is b.<code>nf.zk[j]</code>.</p>
<p>
The algebraic number a is guaranteed to have a
valuation equal to 1 at the prime ideal (this is automatic if e &gt; 1).</p>
<p>
The components of <code>pr</code> should be accessed by member functions: <code>pr.p</code>,
<code>pr.e</code>, <code>pr.f</code>, and <code>pr.gen</code> (returns the vector [p,a]):</p>
<p>
</p><pre class="code">  ? K = nfinit(x^3-2);
  ? P = idealprimedec(K, 5);
  ? #P       \\ 2 primes above 5 in Q(2^(1/3))
  %3 = 2
  ? [p1,p2] = P;
  ? [p1.e, p1.f]    \\ the first is unramified of degree 1
  %5 = [1, 1]
  ? [p2.e, p2.f]    \\ the second is unramified of degree 2
  %6 = [1, 2]
  ? p1.gen
  %7 = [5, [2, 1, 0]~]
  ? nfbasistoalg(K, %[2])  \\ a uniformizer for p1
  %8 = Mod(x + 2, x^3 - 2)
  ? #idealprimedec(K, 5, 1) \\ restrict to f = 1
  %9 = 1            \\ now only p1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealprimedec_limit<sub>f</sub></b>(GEN nf, GEN p, long f)</code>.</p>
<p>

<hr>
<div id="se:idealprincipalunits"></div>
<div id="idealprincipalunits"></div>
<h4>idealprincipalunits(<em>nf</em>, <em>pr</em>, k)</h4>
<p>
Given a prime ideal in <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> format,
returns the multiplicative group (1 + <em>pr</em>) / (1 + <em>pr</em>^k) as an
abelian group. This function is much faster than <code><a href="General_number_fields.html#se:idealstar"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealstar</a></code> when the
norm of <em>pr</em> is large, since it avoids (useless) work in the
multiplicative group of the residue field.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K,2)[1];
  ? G = idealprincipalunits(K, P, 20);
  ? G.cyc
  %4 = [512, 256, 4]   \\ Z/512 x Z/256 x Z/4
  ? G.gen
  %5 = [[-1, -2]~, 1021, [0, -1]~] \\ minimal generators of given order
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealprincipalunits</b>(GEN nf, GEN pr, long k)</code>.</p>
<p>

<hr>
<div id="se:idealramgroups"></div>
<div id="idealramgroups"></div>
<h4>idealramgroups(<em>nf</em>, <em>gal</em>, <em>pr</em>)</h4>
<p>
Let K be the number field defined by <em>nf</em> and assume that K/&Qopf; is
Galois with Galois group G given by <code>gal = galoisinit(nf)</code>.
Let <em>pr</em> be the prime ideal &Pfr; in prid format.
This function returns a vector g of subgroups of <code>gal</code>
as follow:</p>
<p>
<b>*</b> <code>g[1]</code> is the decomposition group of &Pfr;,</p>
<p>
<b>*</b> <code>g[2]</code> is G<sub>0</sub>(&Pfr;), the inertia group of &Pfr;,</p>
<p>
and for i &geq; 2,</p>
<p>
<b>*</b> <code>g[i]</code> is G<sub>i-2</sub>(&Pfr;), the i-2-th
ramification group of &Pfr;.</p>
<p>
The length of g is the number of non-trivial groups in the
sequence, thus is 0 if e = 1 and f = 1, and 1 if f &gt; 1 and e = 1.
The following function computes the cardinality of a subgroup of G,
as given by the components of g:</p>
<p>
</p><pre class="code">  card(H) =my(o=H[2]); prod(i=1,#o,o[i]);
</pre><p></p>
<p></p>
<p>
</p><pre class="code">  ? nf=nfinit(x^6+3); gal=galoisinit(nf); pr=idealprimedec(nf,3)[1];
  ? g = idealramgroups(nf, gal, pr);
  ? apply(card,g)
  %3 = [6, 6, 3, 3, 3] \\ cardinalities of the G<sub>i</sub>
</pre><p></p>
<p></p>
<p></p>
<p>
</p><pre class="code">  ? nf=nfinit(x^6+108); gal=galoisinit(nf); pr=idealprimedec(nf,2)[1];
  ? iso=idealramgroups(nf,gal,pr)[2]
  %5 = [[Vecsmall([2, 3, 1, 5, 6, 4])], Vecsmall([3])]
  ? nfdisc(galoisfixedfield(gal,iso,1))
  %6 = -3
</pre><p>
The field fixed by the inertia group of 2 is not ramified at
2.</p>
<p>
The library syntax is <code>GEN <b>idealramgroups</b>(GEN nf, GEN gal, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:idealred"></div>
<div id="idealred"></div>
<h4>idealred(<em>nf</em>, I, {v = 0})</h4>
<p>
LLL reduction of
the ideal I in the number field K attached to <em>nf</em>, along the
direction v. The v parameter is best left omitted, but if it is present,
it must be an <code>nf.r1</code> + <code>nf.r2</code>-component vector of
<em>non-negative</em> integers. (What counts is the relative magnitude of the
entries: if all entries are equal, the effect is the same as if the vector
had been omitted.)</p>
<p>
This function finds an a &in;  K<sup>*</sup> such that J = (a)I is
"small" and integral (see the end for technical details).
The result is the Hermite normal form of
the "reduced" ideal J.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K,5)[1];
  ? idealred(K, P)
  %3 =
  [1 0]
  
  [0 1]
</pre><p>
More often than not, a principal ideal yields the unit
ideal as above. This is a quick and dirty way to check if ideals are principal,
but it is not a necessary condition: a non-trivial result does not prove that
the ideal is non-principal. For guaranteed results, see <code><a href="General_number_fields.html#se:bnfisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisprincipal</a></code>,
which requires the computation of a full <code>bnf</code> structure.</p>
<p>
If the input is an extended ideal [I,s], the output is [J, sa]; in
this way, one keeps track of the principal ideal part:</p>
<p>
</p><pre class="code">  ? idealred(K, [P, 1])
  %5 = [[1, 0; 0, 1], [2, -1]~]
</pre><p></p>
<p>
meaning that P is generated by [2, -1]&nbsp;. The number field element in the
extended part is an algebraic number in any form <em>or</em> a factorization
matrix (in terms of number field elements, not ideals!). In the latter case,
elements stay in factored form, which is a convenient way to avoid
coefficient explosion; see also <code><a href="General_number_fields.html#se:idealpow"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealpow</a></code>.</p>
<p>
<b>Technical note.</b> The routine computes an LLL-reduced
basis for the lattice I<sup>-1</sup> equipped with the quadratic
form
|| x ||<sub>v</sub>^2 = &sum;<sub>i = 1</sub><sup>r<sub>1</sub>+r<sub>2</sub></sup> 2<sup>v<sub>i</sub></sup>&varepsilon;<sub>i</sub>|&sigma;<sub>i</sub>(x)|^2,
where as usual the &sigma;<sub>i</sub> are the (real and) complex embeddings and
&varepsilon;<sub>i</sub> = 1, resp.&nbsp;2, for a real, resp.&nbsp;complex place. The element
a is simply the first vector in the LLL basis. The only reason you may want
to try to change some directions and set some v<sub>i</sub> != 0 is to randomize
the elements found for a fixed ideal, which is heuristically useful in index
calculus algorithms like <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> and <code><a href="General_number_fields.html#se:bnfisprincipal"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisprincipal</a></code>.</p>
<p>
<b>Even more technical note.</b> In fact, the above is a white lie.
We do not use ||.||<sub>v</sub> exactly but a rescaled rounded variant which
gets us faster and simpler LLLs. There's no harm since we are not using any
theoretical property of a after all, except that it belongs to I<sup>-1</sup>
and that a I is "expected to be small".</p>
<p>
The library syntax is <code>GEN <b>idealred0</b>(GEN nf, GEN I, GEN v = NULL)</code>.</p>
<p>

<hr>
<div id="se:idealredmodpower"></div>
<div id="idealredmodpower"></div>
<h4>idealredmodpower(<em>nf</em>, x, n, {B = <em>primelimit</em>})</h4>
<p>
Let <em>nf</em> be a number field, x an ideal in <em>nf</em> and n &gt; 0 be a
positive integer. Return a number field element b such that x b^n = v
is small. If x is integral, then v is also integral.</p>
<p>
More precisely, <code><a href="General_number_fields.html#se:idealnumden"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealnumden</a></code> reduces the problem to x integral. Then,
factoring out the prime ideals dividing a rational prime p &leq; B,
we rewrite x = I J^n where the ideals I and J are both integral and
I is B-smooth. Then we return a small element b in J<sup>-1</sup>.</p>
<p>
The bound B avoids a costly complete factorization of x; as soon as the
n-core of x is B-smooth (i.e., as soon as I is n-power free),
then J is as large as possible and so is the expected reduction.</p>
<p>
</p><pre class="code">  ? T = x^6+108; nf = nfinit(T); a = Mod(x,T);
  ? setrand(1); u = (2*a^2+a+3)*random(2^1000*x^6)^6;
  ? sizebyte(u)
  %3 = 4864
  ? b = idealredmodpower(nf,u,2);
  ? v2 = nfeltmul(nf,u, nfeltpow(nf,b,2))
  %5 = [34, 47, 15, 35, 9, 3]~
  ? b = idealredmodpower(nf,u,6);
  ? v6 = nfeltmul(nf,u, nfeltpow(nf,b,6))
  %7 = [3, 0, 2, 6, -7, 1]~
</pre><p>
The last element <code>v6</code>, obtained by reducing
modulo 6-th powers instead of squares, looks smaller than <code>v2</code>
but its norm is actually a little larger:</p>
<p>
</p><pre class="code">  ? idealnorm(nf,v2)
  %8 = 81309
  ? idealnorm(nf,v6)
  %9 = 731781
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealredmodpower</b>(GEN nf, GEN x, ulong n, ulong B)</code>.</p>
<p>

<hr>
<div id="se:idealstar"></div>
<div id="idealstar"></div>
<h4>idealstar({<em>nf</em>}, N, {<em>flag</em> = 1})</h4>
<p>
Outputs a <code>bid</code> structure,
necessary for computing in the finite abelian group G = (&Zopf;<sub>K</sub>/N)<sup>*</sup>. Here,
<em>nf</em> is a number field and N is a <em>modulus</em>: either an ideal in any
form, or a row vector whose first component is an ideal and whose second
component is a row vector of r<sub>1</sub> 0 or 1. Ideals can also be given
by a factorization into prime ideals, as produced by <code><a href="General_number_fields.html#se:idealfactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealfactor</a></code>.</p>
<p>
This <em>bid</em> is used in <code><a href="General_number_fields.html#se:ideallog"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">ideallog</a></code> to compute discrete logarithms. It
also contains useful information which can be conveniently retrieved as
<code><em>bid</em>.mod</code> (the modulus),
<code><em>bid</em>.clgp</code> (G as a finite abelian group),
<code><em>bid</em>.no</code> (the cardinality of G),
<code><em>bid</em>.cyc</code> (elementary divisors) and
<code><em>bid</em>.gen</code> (generators).</p>
<p>
If <em>flag</em> = 1 (default), the result is a <code>bid</code> structure without
generators: they are well defined but not explicitly computed, which saves
time.</p>
<p>
If <em>flag</em> = 2, as <em>flag</em> = 1, but including generators.</p>
<p>
If <em>flag</em> = 0, only outputs (&Zopf;<sub>K</sub>/N)<sup>*</sup> as an abelian group,
i.e as a 3-component vector [h,d,g]: h is the order, d is the vector of
SNF cyclic components and g the corresponding
generators.</p>
<p>
If <em>nf</em> is omitted, we take it to be the rational number fields, N must
be an integer and we return the structure of (&Zopf;/N&Zopf;)<sup>*</sup>. In other words
<code>idealstar(, N, flag)</code> is short for</p>
<p>
</p><pre class="code">    idealstar(nfinit(x), N, flag)
</pre><p>
but faster. The alternative syntax <code>znstar(N, flag)</code>
is also available for an analogous effect but, due to an unfortunate
historical oversight, the default value of <code>flag</code> is different in
the two functions (<code><a href="Arithmetic_functions.html#se:znstar"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">znstar</a></code> does not initialize by default, you probably
want <code>znstar(N,1)</code>).</p>
<p>
The library syntax is <code>GEN <b>idealstar0</b>(GEN nf = NULL, GEN N, long flag)</code>.
Instead the above hardcoded numerical flags, one should rather use
<code>GEN <b>Idealstar</b>(GEN nf, GEN ideal, long flag)</code>, where <code>flag</code> is
an or-ed combination of <code>nf_GEN</code> (include generators) and <code>nf_INIT</code>
(return a full <code>bid</code>, not a group), possibly 0. This offers
one more combination: gen, but no init.</p>
<p>

<hr>
<div id="se:idealtwoelt"></div>
<div id="idealtwoelt"></div>
<h4>idealtwoelt(<em>nf</em>, x, {a})</h4>
<p>
Computes a two-element representation of the ideal x in the number
field <em>nf</em>, combining a random search and an approximation theorem; x
is an ideal in any form (possibly an extended ideal, whose principal part is
ignored)</p>
<p>
<b>*</b> When called as <code>idealtwoelt(nf,x)</code>, the result is a row vector
[a,&alpha;] with two components such that x = a&Zopf;<sub>K</sub>+&alpha;&Zopf;<sub>K</sub> and a is
chosen to be the positive generator of x&cap;&Zopf;, unless x was given as a
principal ideal in which case we may choose a = 0. The algorithm
uses a fast lazy factorization of x&cap; &Zopf; and runs in randomized
polynomial time.</p>
<p></p>
<p>
</p><pre class="code">  ? K = nfinit(t^5-23);
  ? x = idealhnf(K, t^2*(t+1), t^3*(t+1))
  %2 =  \\ some random ideal of norm 552*23
  [552 23 23 529 23]
  
  [  0 23  0   0  0]
  
  [  0  0  1   0  0]
  
  [  0  0  0   1  0]
  
  [  0  0  0   0  1]
  
  ? [a,alpha] = idealtwoelt(K, x)
  %3 = [552, [23, 0, 1, 0, 0]~]
  ? nfbasistoalg(K, alpha)
  %4 = Mod(t^2 + 23, t^5 - 23)
</pre><p></p>
<p></p>
<p>
<b>*</b> When called as <code>idealtwoelt(nf,x,a)</code> with an explicit non-zero a
supplied as third argument, the function assumes that a  &in;  x and returns
&alpha; &in;  x such that x = a&Zopf;<sub>K</sub> + &alpha;&Zopf;<sub>K</sub>. Note that we must factor
a in this case, and the algorithm is generally slower than the
default variant and gives larger generators:</p>
<p>
</p><pre class="code">  ? alpha2 = idealtwoelt(K, x, 552)
  %5 = [-161, -161, -183, -207, 0]~
  ? idealhnf(K, 552, alpha2) == x
  %6 = 1
</pre><p>
Note that, in both cases, the return value is <em>not</em>
recognized as an ideal by GP functions; one must use <code><a href="General_number_fields.html#se:idealhnf"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealhnf</a></code> as
above to recover a valid ideal structure from the two-element representation.</p>
<p>
The library syntax is <code>GEN <b>idealtwoelt0</b>(GEN nf, GEN x, GEN a = NULL)</code>.
Also available are
<code>GEN <b>idealtwoelt</b>(GEN nf, GEN x)</code> and
<code>GEN <b>idealtwoelt2</b>(GEN nf, GEN x, GEN a)</code>.</p>
<p>

<hr>
<div id="se:idealval"></div>
<div id="idealval"></div>
<h4>idealval(<em>nf</em>, x, <em>pr</em>)</h4>
<p>
Gives the valuation of the ideal x at the prime ideal <em>pr</em> in the
number field <em>nf</em>, where <em>pr</em> is in <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> format.
The valuation of the 0 ideal is <code>+oo</code>.</p>
<p>
The library syntax is <code>GEN <b>gpidealval</b>(GEN nf, GEN x, GEN pr)</code>.
Also available is
<code>long <b>idealval</b>(GEN nf, GEN x, GEN pr)</code>, which returns
<code>LONG_MAX</code> if x = 0 and the valuation as a <code>long</code> integer.</p>
<p>

<hr>
<div id="se:matalgtobasis"></div>
<div id="matalgtobasis"></div>
<h4>matalgtobasis(<em>nf</em>, x)</h4>
<p>
This function is deprecated, use <code><a href="Programming_in_GP__other_specific_functions.html#se:apply"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__other_specific_functions.html'">apply</a></code>.</p>
<p>
<em>nf</em> being a number field in <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> format, and x a
(row or column) vector or matrix, apply <code><a href="General_number_fields.html#se:nfalgtobasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfalgtobasis</a></code> to each entry
of x.</p>
<p>
The library syntax is <code>GEN <b>matalgtobasis</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:matbasistoalg"></div>
<div id="matbasistoalg"></div>
<h4>matbasistoalg(<em>nf</em>, x)</h4>
<p>
This function is deprecated, use <code><a href="Programming_in_GP__other_specific_functions.html#se:apply"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__other_specific_functions.html'">apply</a></code>.</p>
<p>
<em>nf</em> being a number field in <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> format, and x a
(row or column) vector or matrix, apply <code><a href="General_number_fields.html#se:nfbasistoalg"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfbasistoalg</a></code> to each entry
of x.</p>
<p>
The library syntax is <code>GEN <b>matbasistoalg</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:modreverse"></div>
<div id="modreverse"></div>
<h4>modreverse(z)</h4>
<p>
Let z = <code>Mod(A, T)</code> be a polmod, and Q be its minimal
polynomial, which must satisfy deg(Q) = deg(T).
Returns a "reverse polmod" <code>Mod(B, Q)</code>, which is a root of T.</p>
<p>
This is quite useful when one changes the generating element in algebraic
extensions:</p>
<p>
</p><pre class="code">  ? u = Mod(x, x^3 - x -1); v = u^5;
  ? w = modreverse(v)
  %2 = Mod(x^2 - 4*x + 1, x^3 - 5*x^2 + 4*x - 1)
</pre><p></p>
<p>
which means that x^3 - 5x^2 + 4x -1 is another defining polynomial for the
cubic field
&Qopf;(u) = &Qopf;[x]/(x^3 - x - 1) = &Qopf;[x]/(x^3 - 5x^2 + 4x - 1) = &Qopf;(v),
and that u  &rightarrow;  v^2 - 4v + 1 gives an explicit isomorphism. From this, it is
easy to convert elements between the A(u) &in;  &Qopf;(u) and B(v) &in;  &Qopf;(v)
representations:</p>
<p>
</p><pre class="code">  ? A = u^2 + 2*u + 3; subst(lift(A), 'x, w)
  %3 = Mod(x^2 - 3*x + 3, x^3 - 5*x^2 + 4*x - 1)
  ? B = v^2 + v + 1;   subst(lift(B), 'x, v)
  %4 = Mod(26*x^2 + 31*x + 26, x^3 - x - 1)
</pre><p></p>
<p>
If the minimal polynomial of z has lower degree than expected, the routine
fails</p>
<p>
</p><pre class="code">  ? u = Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)
  ? modreverse(u)
   *** modreverse: domain error in modreverse: deg(minpoly(z)) &lt; 4
   ***   Break loop: type 'break' to go back to GP prompt
  break&gt; Vec( dbg_err() ) \\ ask for more info
  ["e_DOMAIN", "modreverse", "deg(minpoly(z))", "&lt;", 4,
    Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)]
  break&gt; minpoly(u)
  x^2 - 8
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>modreverse</b>(GEN z)</code>.</p>
<p>

<hr>
<div id="se:newtonpoly"></div>
<div id="newtonpoly"></div>
<h4>newtonpoly(x, p)</h4>
<p>
Gives the vector of the slopes of the Newton
polygon of the polynomial x with respect to the prime number p. The n
components of the vector are in decreasing order, where n is equal to the
degree of x. Vertical slopes occur iff the constant coefficient of x is
zero and are denoted by <code>+oo</code>.</p>
<p>
The library syntax is <code>GEN <b>newtonpoly</b>(GEN x, GEN p)</code>.</p>
<p>

<hr>
<div id="se:nfalgtobasis"></div>
<div id="nfalgtobasis"></div>
<h4>nfalgtobasis(<em>nf</em>, x)</h4>
<p>
Given an algebraic number x in the number field <em>nf</em>,
transforms it to a column vector on the integral basis <code><em>nf</em>.zk</code>.</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2 + 4);
  ? nf.zk
  %2 = [1, 1/2*y]
  ? nfalgtobasis(nf, [1,1]~)
  %3 = [1, 1]~
  ? nfalgtobasis(nf, y)
  %4 = [0, 2]~
  ? nfalgtobasis(nf, Mod(y, y^2+4))
  %5 = [0, 2]~
</pre><p></p>
<p>
This is the inverse function of <code><a href="General_number_fields.html#se:nfbasistoalg"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfbasistoalg</a></code>.</p>
<p>
The library syntax is <code>GEN <b>algtobasis</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:nfbasis"></div>
<div id="nfbasis"></div>
<h4>nfbasis(T)</h4>
<p>
Let T(X) be an irreducible polynomial with integral coefficients. This
function returns an integral basis of the number field defined by T,
that is a &Zopf;-basis of its maximal order. The basis elements are given as
elements in &Qopf;[X]/(T):</p>
<p>
</p><pre class="code">  ? nfbasis(x^2 + 1)
  %1 = [1, x]
</pre><p></p>
<p>
This function uses a modified version of the round 4 algorithm,
due to David Ford, Sebastian Pauli and Xavier Roblot.</p>
<p>
<b>Local basis, orders maximal at certain primes.</b></p>
<p>
Obtaining the maximal order is hard: it requires factoring the discriminant
D of T. Obtaining an order which is maximal at a finite explicit set of
primes is easy, but it may then be a strict suborder of the maximal order. To
specify that we are interested in a given set of places only, we can replace
the argument T by an argument [T,<em>listP</em>], where <em>listP</em> encodes
the primes we are interested in: it must be a factorization matrix, a vector
of integers or a single integer.</p>
<p>
<b>*</b> Vector: we assume that it contains distinct <em>prime</em> numbers.</p>
<p>
<b>*</b> Matrix: we assume that it is a two-column matrix of a
(partial) factorization of D; namely the first column contains
distinct <em>primes</em> and the second one the valuation of D at each of
these primes.</p>
<p>
<b>*</b> Integer B: this is replaced by the vector of primes up to B. Note
that the function will use at least O(B) time: a small value, about
10^5, should be enough for most applications. Values larger than 2<sup>32</sup>
are not supported.</p>
<p>
In all these cases, the primes may or may not divide the discriminant D
of T. The function then returns a &Zopf;-basis of an order whose index is
not divisible by any of these prime numbers. The result is actually a global
integral basis if all prime divisors of the <em>field</em> discriminant are
included! Note that <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> has built-in support for such
a check:</p>
<p>
</p><pre class="code">  ? K = nfinit([T, listP]);
  ? nfcertify(K)   \\ we computed an actual maximal order
  %2 = [];
</pre><p>
The first line initializes a number field structure
incorporating <code>nfbasis([T, listP]</code> in place of a proven integral basis.
The second line certifies that the resulting structure is correct. This
allows to create an <code>nf</code> structure attached to the number field K = 
&Qopf;[X]/(T), when the discriminant of T cannot be factored completely,
whereas the prime divisors of disc K are known.</p>
<p>
Of course, if <em>listP</em> contains a single prime number p,
the function returns a local integral basis for &Zopf;<sub>p</sub>[X]/(T):</p>
<p>
</p><pre class="code">  ? nfbasis(x^2+x-1001)
  %1 = [1, 1/3*x - 1/3]
  ? nfbasis( [x^2+x-1001, [2]] )
  %2 = [1, x]
</pre><p></p>
<p></p>
<p>
<b>The Buchmann-Lenstra algorithm.</b></p>
<p>
We now complicate the picture: it is in fact allowed to include
<em>composite</em> numbers instead of primes
in <code>listP</code> (Vector or Matrix case), provided they are pairwise coprime.
The result will still be a correct integral basis <em>if</em>
the field discriminant factors completely over the actual primes in the list.
Adding a composite C such that C^2 <em>divides</em> D may help because
when we consider C as a prime and run the algorithm, two good things can
happen: either we
succeed in proving that no prime dividing C can divide the index
(without actually needing to find those primes), or the computation
exhibits a non-trivial zero divisor, thereby factoring C and
we go on with the refined factorization. (Note that including a C
such that C^2 does not divide D is useless.) If neither happen, then the
computed basis need not generate the maximal order. Here is an example:</p>
<p>
</p><pre class="code">  ? B = 10^5;
  ? P = factor(poldisc(T), B)[,1]; \\ primes &lt;= B dividing D + cofactor
  ? basis = nfbasis([T, listP])
  ? disc = nfdisc([T, listP])
</pre><p>
We obtain the maximal order and its discriminant if the
field discriminant factors
completely over the primes less than B (together with the primes
contained in the <code><a href="Arithmetic_functions.html#se:addprimes"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">addprimes</a></code> table). This can be tested as follows:</p>
<p>
</p><pre class="code">    check = factor(disc, B);
    lastp = check[-1..-1,1];
    if (lastp &gt; B && !setsearch(addprimes(), lastp),
      warning("nf may be incorrect!"))
</pre><p></p>
<p>
This is a sufficient but not a necessary condition, hence the warning,
instead of an error. N.B. <code>lastp</code> is the last entry
in the first column of the <code>check</code> matrix, i.e. the largest prime
dividing <code>nf.disc</code> if  &leq; B or if it belongs to the prime table.</p>
<p>
The function <code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code> speeds up and automates the above process:</p>
<p>
</p><pre class="code">  ? B = 10^5;
  ? nf = nfinit([T, B]);
  ? nfcertify(nf)
  %3 = []      \\ nf is unconditionally correct
  ? basis = nf.zk;
  ? disc = nf.disc;
</pre><p></p>
<p></p>
<p>
The library syntax is <code><b>nfbasis</b>(GEN T, GEN *d, GEN listP = NULL)</code>, which returns the order
basis, and where <code>*d</code> receives the order discriminant.</p>
<p>

<hr>
<div id="se:nfbasistoalg"></div>
<div id="nfbasistoalg"></div>
<h4>nfbasistoalg(<em>nf</em>, x)</h4>
<p>
Given an algebraic number x in the number field <em>nf</em>, transforms it
into <code>t_POLMOD</code> form.</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2 + 4);
  ? nf.zk
  %2 = [1, 1/2*y]
  ? nfbasistoalg(nf, [1,1]~)
  %3 = Mod(1/2*y + 1, y^2 + 4)
  ? nfbasistoalg(nf, y)
  %4 = Mod(y, y^2 + 4)
  ? nfbasistoalg(nf, Mod(y, y^2+4))
  %5 = Mod(y, y^2 + 4)
</pre><p></p>
<p>
This is the inverse function of <code><a href="General_number_fields.html#se:nfalgtobasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfalgtobasis</a></code>.</p>
<p>
The library syntax is <code>GEN <b>basistoalg</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:nfcertify"></div>
<div id="nfcertify"></div>
<h4>nfcertify(<em>nf</em>)</h4>
<p>
<em>nf</em> being as output by
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, checks whether the integer basis is known unconditionally.
This is in particular useful when the argument to <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> was of the
form [T, <code>listP</code>], specifying a finite list of primes when
p-maximality had to be proven, or a list of coprime integers to which
Buchmann-Lenstra algorithm was to be applied.</p>
<p>
The function returns a vector of coprime composite integers. If this vector
is empty, then <code>nf.zk</code> and <code>nf.disc</code> are correct. Otherwise, the
result is dubious. In order to obtain a certified result, one must completely
factor each of the given integers, then <code>addprime</code> each of their prime
factors, then check whether <code>nfdisc(nf.pol)</code> is equal to <code>nf.disc</code>.</p>
<p>
The library syntax is <code>GEN <b>nfcertify</b>(GEN nf)</code>.</p>
<p>

<hr>
<div id="se:nfcompositum"></div>
<div id="nfcompositum"></div>
<h4>nfcompositum(<em>nf</em>, P, Q, {<em>flag</em> = 0})</h4>
<p>
Let <em>nf</em> be a number field structure attached to the field K
and let  P and Q
be squarefree polynomials in K[X] in the same variable. Outputs
the simple factors of the &eacute;tale K-algebra A = K[X, Y] / (P(X), Q(Y)).
The factors are given by a list of polynomials R in K[X], attached to
the number field K[X]/ (R), and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.</p>
<p>
Note that it is more efficient to reduce to the case where P and Q are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor R if and only if the number
fields defined by P and Q are linearly disjoint (their intersection is
K).</p>
<p>
The binary digits of <em>flag</em> mean</p>
<p>
1: outputs a vector of 4-component vectors [R,a,b,k], where R
ranges through the list of all possible compositums as above, and a
(resp. b) expresses the root of P (resp. Q) as an element of
K[X]/(R). Finally, k is a small integer such that b + ka = X modulo
R.</p>
<p>
2: assume that P and Q define number fields that are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides K. This allows to save a costly
factorization over K. In this case return the single simple factor
instead of a vector with one element.</p>
<p>
A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field K(&zeta;<sub>5</sub>, 5<sup>1/10</sup>), K = &Qopf;(sqrt{5}):</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2-5);
  ? L = nfcompositum(K, x^5 - y, polcyclo(5), 1); \\  list of [R,a,b,k]
  ? [R, a] = L[1];  \\  pick the single factor, extract R,a (ignore b,k)
  ? lift(R)         \\  defines the compositum
  %4 = x^10 + (-5/2*y + 5/2)*x^9 + (-5*y + 20)*x^8 + (-20*y + 30)*x^7 + \
  (-45/2*y + 145/2)*x^6 + (-71/2*y + 121/2)*x^5 + (-20*y + 60)*x^4 +    \
  (-25*y + 5)*x^3 + 45*x^2 + (-5*y + 15)*x + (-2*y + 6)
  ? a^5 - y         \\  a fifth root of y
  %5 = 0
  ? [T, X] = rnfpolredbest(K, R, 1);
  ? lift(T)     \\  simpler defining polynomial for K[x]/(R)
  %7 = x^10 + (-11/2*y + 25/2)
  ? liftall(X)  \\   root of R in K[x]/(T(x))
  %8 = (3/4*y + 7/4)*x^7 + (-1/2*y - 1)*x^5 + 1/2*x^2 + (1/4*y - 1/4)
  ? a = subst(a.pol, 'x, X);  \\  <code>a</code> in the new coordinates
  ? liftall(a)
  %10 = (-3/4*y - 7/4)*x^7 - 1/2*x^2
  ? a^5 - y
  %11 = 0
</pre><p></p>
<p></p>
<p>
The main variables of P and Q must be the same and have higher priority
than that of <em>nf</em> (see&nbsp;<code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:varhigher"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">varhigher</a></code> and&nbsp;<code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:varlower"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">varlower</a></code>).</p>
<p>
The library syntax is <code>GEN <b>nfcompositum</b>(GEN nf, GEN P, GEN Q, long flag)</code>.</p>
<p>

<hr>
<div id="se:nfdetint"></div>
<div id="nfdetint"></div>
<h4>nfdetint(<em>nf</em>, x)</h4>
<p>
Given a pseudo-matrix x, computes a
non-zero ideal contained in (i.e.&nbsp;multiple of) the determinant of x. This
is particularly useful in conjunction with <code><a href="General_number_fields.html#se:nfhnfmod"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfhnfmod</a></code>.</p>
<p>
The library syntax is <code>GEN <b>nfdetint</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:nfdisc"></div>
<div id="nfdisc"></div>
<h4>nfdisc(T)</h4>
<p>
field discriminant of the number field defined by the integral,
preferably monic, irreducible polynomial T(X). Returns the discriminant of
the number field &Qopf;[X]/(T), using the Round 4 algorithm.</p>
<p>
<b>Local discriminants, valuations at certain primes.</b></p>
<p>
As in <code><a href="General_number_fields.html#se:nfbasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfbasis</a></code>, the argument T can be replaced by [T,<em>listP</em>],
where <code>listP</code> is as in <code><a href="General_number_fields.html#se:nfbasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfbasis</a></code>: a vector of
pairwise coprime integers (usually distinct primes), a factorization matrix,
or a single integer. In that case, the function returns the discriminant of
an order whose basis is given by <code>nfbasis(T,listP)</code>, which need not be
the maximal order, and whose valuation at a prime entry in <code>listP</code> is the
same as the valuation of the field discriminant.</p>
<p>
In particular, if <code>listP</code> is [p] for a prime p, we can
return the p-adic discriminant of the maximal order of &Zopf;<sub>p</sub>[X]/(T),
as a power of p, as follows:</p>
<p>
</p><pre class="code">  ? padicdisc(T,p) = p^valuation(nfdisc(T,[p]), p);
  ? nfdisc(x^2 + 6)
  %2 = -24
  ? padicdisc(x^2 + 6, 2)
  %3 = 8
  ? padicdisc(x^2 + 6, 3)
  %4 = 3
</pre><p></p>
<p></p>
<p>
The library syntax is <code><b>nfdisc</b>(GEN T)</code> (<code>listP = NULL</code>). Also available is
<code>GEN <b>nfbasis</b>(GEN T, GEN *d, GEN listP = NULL)</code>, which returns the order
basis, and where <code>*d</code> receives the order discriminant.</p>
<p>

<hr>
<div id="se:nfeltadd"></div>
<div id="nfeltadd"></div>
<h4>nfeltadd(<em>nf</em>, x, y)</h4>
<p>
Given two elements x and y in
<em>nf</em>, computes their sum x+y in the number field <em>nf</em>.</p>
<p></p>
<p>
</p><pre class="code">  ? nf = nfinit(1+x^2);
  ? nfeltadd(nf, 1, x) \\ 1 + I
  %2 = [1, 1]~
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfadd</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:nfeltdiv"></div>
<div id="nfeltdiv"></div>
<h4>nfeltdiv(<em>nf</em>, x, y)</h4>
<p>
Given two elements x and y in
<em>nf</em>, computes their quotient x/y in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfdiv</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:nfeltdiveuc"></div>
<div id="nfeltdiveuc"></div>
<h4>nfeltdiveuc(<em>nf</em>, x, y)</h4>
<p>
Given two elements x and y in
<em>nf</em>, computes an algebraic integer q in the number field <em>nf</em>
such that the components of x-qy are reasonably small. In fact, this is
functionally identical to <code>round(nfdiv(<em>nf</em>,x,y))</code>.</p>
<p>
The library syntax is <code>GEN <b>nfdiveuc</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:nfeltdivmodpr"></div>
<div id="nfeltdivmodpr"></div>
<h4>nfeltdivmodpr(<em>nf</em>, x, y, <em>pr</em>)</h4>
<p>
This function is obsolete, use <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code>.</p>
<p>
Given two elements x
and y in <em>nf</em> and <em>pr</em> a prime ideal in <code>modpr</code> format (see
<code><a href="General_number_fields.html#se:nfmodprinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprinit</a></code>), computes their quotient x / y modulo the prime ideal
<em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfdivmodpr</b>(GEN nf, GEN x, GEN y, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>
<p>

<hr>
<div id="se:nfeltdivrem"></div>
<div id="nfeltdivrem"></div>
<h4>nfeltdivrem(<em>nf</em>, x, y)</h4>
<p>
Given two elements x and y in
<em>nf</em>, gives a two-element row vector [q,r] such that x = qy+r, q is
an algebraic integer in <em>nf</em>, and the components of r are
reasonably small.</p>
<p>
The library syntax is <code>GEN <b>nfdivrem</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:nfeltembed"></div>
<div id="nfeltembed"></div>
<h4>nfeltembed(<em>nf</em>, x, {<em>pl</em>})</h4>
<p>
Given an element x in the number field <em>nf</em>, return
the (real or) complex embeddings of x specified by optional argument
<em>pl</em>, at the current <code>realprecision</code>:</p>
<p>
<b>*</b> <em>pl</em> omitted: return the vector of embeddings at all r<sub>1</sub>+r<sub>2</sub>
places;</p>
<p>
<b>*</b> <em>pl</em> an integer between 1 and r<sub>1</sub>+r<sub>2</sub>: return the
i-th embedding of x, attached to the i-th root of <code>nf.pol</code>,
i.e. <code>nf.roots[i]</code>;</p>
<p>
<b>*</b> <em>pl</em> a vector or <code>t_VECSMALL</code>: return the vector of embeddings; the i-th
entry gives the embedding at the place attached to the <em>pl</em>[i]-th real
root of <code>nf.pol</code>.</p>
<p></p>
<p>
</p><pre class="code">  ? nf = nfinit('y^3 - 2);
  ? nf.sign
  %2 = [1, 1]
  ? nfeltembed(nf, 'y)
  %3 = [1.25992[...], -0.62996[...] + 1.09112[...]*I]]
  ? nfeltembed(nf, 'y, 1)
  %4 = 1.25992[...]
  ? nfeltembed(nf, 'y, 3) \\ there are only 2 arch. places
   ***   at top-level: nfeltembed(nf,'y,3)
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
   *** nfeltembed: domain error in nfeltembed: index &gt; 2
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfeltembed</b>(GEN nf, GEN x, GEN pl = NULL, long prec)</code>.</p>
<p>

<hr>
<div id="se:nfeltmod"></div>
<div id="nfeltmod"></div>
<h4>nfeltmod(<em>nf</em>, x, y)</h4>
<p>
Given two elements x and y in
<em>nf</em>, computes an element r of <em>nf</em> of the form r = x-qy with
q and algebraic integer, and such that r is small. This is functionally
identical to
<code>x - nfmul(<em>nf</em>,round(nfdiv(<em>nf</em>,x,y)),y)</code>.</p>
<p>
The library syntax is <code>GEN <b>nfmod</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:nfeltmul"></div>
<div id="nfeltmul"></div>
<h4>nfeltmul(<em>nf</em>, x, y)</h4>
<p>
Given two elements x and y in
<em>nf</em>, computes their product x*y in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfmul</b>(GEN nf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:nfeltmulmodpr"></div>
<div id="nfeltmulmodpr"></div>
<h4>nfeltmulmodpr(<em>nf</em>, x, y, <em>pr</em>)</h4>
<p>
This function is obsolete, use <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code>.</p>
<p>
Given two elements x and
y in <em>nf</em> and <em>pr</em> a prime ideal in <code>modpr</code> format (see
<code><a href="General_number_fields.html#se:nfmodprinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprinit</a></code>), computes their product x*y modulo the prime ideal
<em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfmulmodpr</b>(GEN nf, GEN x, GEN y, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>
<p>

<hr>
<div id="se:nfeltnorm"></div>
<div id="nfeltnorm"></div>
<h4>nfeltnorm(<em>nf</em>, x)</h4>
<p>
Returns the absolute norm of x.</p>
<p>
The library syntax is <code>GEN <b>nfnorm</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:nfeltpow"></div>
<div id="nfeltpow"></div>
<h4>nfeltpow(<em>nf</em>, x, k)</h4>
<p>
Given an element x in <em>nf</em>, and a positive or negative integer k,
computes x^k in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfpow</b>(GEN nf, GEN x, GEN k)</code>.
<code>GEN <b>nfinv</b>(GEN nf, GEN x)</code> correspond to k = -1, and
<code>GEN <b>nfsqr</b>(GEN nf,GEN x)</code> to k = 2.</p>
<p>

<hr>
<div id="se:nfeltpowmodpr"></div>
<div id="nfeltpowmodpr"></div>
<h4>nfeltpowmodpr(<em>nf</em>, x, k, <em>pr</em>)</h4>
<p>
This function is obsolete, use <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code>.</p>
<p>
Given an element x in <em>nf</em>, an integer k and a prime ideal
<em>pr</em> in <code>modpr</code> format
(see <code><a href="General_number_fields.html#se:nfmodprinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprinit</a></code>), computes x^k modulo the prime ideal <em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfpowmodpr</b>(GEN nf, GEN x, GEN k, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>
<p>

<hr>
<div id="se:nfeltreduce"></div>
<div id="nfeltreduce"></div>
<h4>nfeltreduce(<em>nf</em>, a, <em>id</em>)</h4>
<p>
Given an ideal <em>id</em> in
Hermite normal form and an element a of the number field <em>nf</em>,
finds an element r in <em>nf</em> such that a-r belongs to the ideal
and r is small.</p>
<p>
The library syntax is <code>GEN <b>nfreduce</b>(GEN nf, GEN a, GEN id)</code>.</p>
<p>

<hr>
<div id="se:nfeltreducemodpr"></div>
<div id="nfeltreducemodpr"></div>
<h4>nfeltreducemodpr(<em>nf</em>, x, <em>pr</em>)</h4>
<p>
This function is obsolete, use <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code>.</p>
<p>
Given an element x of the number field <em>nf</em> and a prime ideal
<em>pr</em> in <code>modpr</code> format compute a canonical representative for the
class of x modulo <em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfreducemodpr</b>(GEN nf, GEN x, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>
<p>

<hr>
<div id="se:nfeltsign"></div>
<div id="nfeltsign"></div>
<h4>nfeltsign(<em>nf</em>, x, {<em>pl</em>})</h4>
<p>
Given an element x in the number field <em>nf</em>, returns the signs of
the real embeddings of x specified by optional argument <em>pl</em>:</p>
<p>
<b>*</b> <em>pl</em> omitted: return the vector of signs at all r<sub>1</sub> real places;</p>
<p>
<b>*</b> <em>pl</em> an integer between 1 and r<sub>1</sub>: return the sign of the
i-th embedding of x, attached to the i-th real root of <code>nf.pol</code>,
i.e. <code>nf.roots[i]</code>;</p>
<p>
<b>*</b> <em>pl</em> a vector or <code>t_VECSMALL</code>: return the vector of signs; the i-th
entry gives the sign at the real place attached to the <em>pl</em>[i]-th real
root of <code>nf.pol</code>.</p>
<p></p>
<p>
</p><pre class="code">  ? nf = nfinit(polsubcyclo(11,5,'y)); \\ Q(cos(2 pi/11))
  ? nf.sign
  %2 = [5, 0]
  ? x = Mod('y, nf.pol);
  ? nfeltsign(nf, x)
  %4 = [-1, -1, -1, 1, 1]
  ? nfeltsign(nf, x, 1)
  %5 = -1
  ? nfeltsign(nf, x, [1..4])
  %6 = [-1, -1, -1, 1]
  ? nfeltsign(nf, x, 6) \\ there are only 5 real embeddings
   ***   at top-level: nfeltsign(nf,x,6)
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
   *** nfeltsign: domain error in nfeltsign: index &gt; 5
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfeltsign</b>(GEN nf, GEN x, GEN pl = NULL)</code>.</p>
<p>

<hr>
<div id="se:nfelttrace"></div>
<div id="nfelttrace"></div>
<h4>nfelttrace(<em>nf</em>, x)</h4>
<p>
Returns the absolute trace of x.</p>
<p>
The library syntax is <code>GEN <b>nftrace</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:nfeltval"></div>
<div id="nfeltval"></div>
<h4>nfeltval(<em>nf</em>, x, <em>pr</em>, {&y})</h4>
<p>
Given an element x in
<em>nf</em> and a prime ideal <em>pr</em> in the format output by
<code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code>, computes the valuation v at <em>pr</em> of the
element x. The valuation of 0 is <code>+oo</code>.</p>
<p>
</p><pre class="code">  ? nf = nfinit(x^2 + 1);
  ? P = idealprimedec(nf, 2)[1];
  ? nfeltval(nf, x+1, P)
  %3 = 1
</pre><p></p>
<p>
This particular valuation can also be obtained using
<code>idealval(<em>nf</em>,x,<em>pr</em>)</code>, since x is then converted to a
principal ideal.</p>
<p>
If the y argument is present, sets y = x &tau;^v, where &tau; is a
fixed "anti-uniformizer" for <em>pr</em>: its valuation at <em>pr</em> is -1;
its valuation is 0 at other prime ideals dividing <code><em>pr</em>.p</code> and
nonnegative at all other primes. In other words y is the part of x
coprime to <em>pr</em>. If x is an algebraic integer, so is y.</p>
<p>
</p><pre class="code">  ? nfeltval(nf, x+1, P, &y); y
  %4 = [0, 1]~
</pre><p></p>
<p>
For instance if x = &prod;<sub>i</sub> x<sub>i</sub><sup>e<sub>i</sub></sup> is known to be coprime to <em>pr</em>,
where the x<sub>i</sub> are algebraic integers and e<sub>i</sub> &in; &Zopf; then,
if v<sub>i</sub> = <code><a href="General_number_fields.html#se:nfeltval"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfeltval</a></code>(<em>nf</em>, x<sub>i</sub>, <em>pr</em>, &y<sub>i</sub>), we still
have x = &prod;<sub>i</sub> y<sub>i</sub><sup>e<sub>i</sub></sup>, where the y<sub>i</sub> are still algebraic integers
but now all of them are coprime to <em>pr</em>. They can then be mapped to
the residue field of <em>pr</em> more efficiently than if the product had
been expanded beforehand: we can reduce mod <em>pr</em> after each ring
operation.</p>
<p>
The library syntax is <code>GEN <b>gpnfvalrem</b>(GEN nf, GEN x, GEN pr, GEN *y = NULL)</code>.
Also available are
<code>long <b>nfvalrem</b>(GEN nf, GEN x, GEN pr, GEN *y = NULL)</code>, which returns
<code>LONG_MAX</code> if x = 0 and the valuation as a <code>long</code> integer,
and <code>long <b>nfval</b>(GEN nf, GEN x, GEN pr)</code>, which only returns the
valuation (y = <code>NULL</code>).</p>
<p>

<hr>
<div id="se:nffactor"></div>
<div id="nffactor"></div>
<h4>nffactor(<em>nf</em>, T)</h4>
<p>
Factorization of the univariate
polynomial T over the number field <em>nf</em> given by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>; T
has coefficients in <em>nf</em> (i.e.&nbsp;either scalar, polmod, polynomial or
column vector). The factors are sorted by increasing degree.</p>
<p>
The main variable of <em>nf</em> must be of <em>lower</em>
priority than that of T, see Section se:priority. However if
the polynomial defining the number field occurs explicitly  in the
coefficients of T as modulus of a <code>t_POLMOD</code> or as a <code>t_POL</code>
coefficient, its main variable must be <em>the same</em> as the main variable
of T. For example,</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2 + 1);
  ? nffactor(nf, x^2 + y); \\  OK
  ? nffactor(nf, x^2 + Mod(y, y^2+1)); \\   OK
  ? nffactor(nf, x^2 + Mod(z, z^2+1)); \\   WRONG
</pre><p></p>
<p></p>
<p>
It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <code>nf</code>
structure will then be computed internally. This is useful in two
situations: when you do not need the <code>nf</code> elsewhere, or when you cannot
initialize an <code>nf</code> due to integer factorization difficulties when
attempting to compute the field discriminant and maximal order. In all
cases, the function runs in polynomial time using Belabas's variant
of van Hoeij's algorithm, which copes with hundreds of modular factors.</p>
<p>
<b>Caveat.</b> <code>nfinit([T, listP])</code> allows to compute in polynomial
time a conditional <em>nf</em> structure, which sets <code>nf.zk</code> to an order
which is not guaranteed to be maximal at all primes. Always either use
<code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code> first (which may not run in polynomial time) or make sure
to input <code>nf.pol</code> instead of the conditional <em>nf</em>: <code><a href="General_number_fields.html#se:nffactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nffactor</a></code> is
able to recover in polynomial time in this case, instead of potentially
missing a factor.</p>
<p>
The library syntax is <code>GEN <b>nffactor</b>(GEN nf, GEN T)</code>.</p>
<p>

<hr>
<div id="se:nffactorback"></div>
<div id="nffactorback"></div>
<h4>nffactorback(<em>nf</em>, f, {e})</h4>
<p>
Gives back the <em>nf</em> element corresponding to a factorization.
The integer 1 corresponds to the empty factorization.</p>
<p>
If e is present, e and f must be vectors of the same length (e being
integral), and the corresponding factorization is the product of the
f[i]<sup>e[i]</sup>.</p>
<p>
If not, and f is vector, it is understood as in the preceding case with e
a vector of 1s: we return the product of the f[i]. Finally, f can be a
regular factorization matrix.</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2+1);
  ? nffactorback(nf, [3, y+1, [1,2]~], [1, 2, 3])
  %2 = [12, -66]~
  ? 3 * (I+1)^2 * (1+2*I)^3
  %3 = 12 - 66*I
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nffactorback</b>(GEN nf, GEN f, GEN e = NULL)</code>.</p>
<p>

<hr>
<div id="se:nffactormod"></div>
<div id="nffactormod"></div>
<h4>nffactormod(<em>nf</em>, Q, <em>pr</em>)</h4>
<p>
This routine is obsolete, use <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code> and <code><a href="Arithmetic_functions.html#se:factormod"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">factormod</a></code>.</p>
<p>
Factors the univariate polynomial Q modulo the prime ideal <em>pr</em> in
the number field <em>nf</em>. The coefficients of Q belong to the number
field (scalar, polmod, polynomial, even column vector) and the main variable
of <em>nf</em> must be of lower priority than that of Q (see
Section se:priority). The prime ideal <em>pr</em> is either in
<code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> or (preferred) <code>modprinit</code> format. The coefficients
of the polynomial factors are lifted to elements of <em>nf</em>:</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K, 3)[1];
  ? nffactormod(K, x^2 + y*x + 18*y+1, P)
  %3 =
  [x + (2*y + 1) 1]
  
  [x + (2*y + 2) 1]
  ? P = nfmodprinit(K, P);  \\ convert to nfmodprinit format
  ? nffactormod(K, x^2 + y*x + 18*y+1)
  %5 =
  [x + (2*y + 1) 1]
  
  [x + (2*y + 2) 1]
</pre><p>
Same result, of course, here about 10% faster due to the
precomputation.</p>
<p>
The library syntax is <code>GEN <b>nffactormod</b>(GEN nf, GEN Q, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:nfgaloisapply"></div>
<div id="nfgaloisapply"></div>
<h4>nfgaloisapply(<em>nf</em>, <em>aut</em>, x)</h4>
<p>
Let <em>nf</em> be a
number field as output by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, and let <em>aut</em> be a Galois
automorphism of <em>nf</em> expressed by its image on the field generator
(such automorphisms can be found using <code><a href="General_number_fields.html#se:nfgaloisconj"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfgaloisconj</a></code>). The function
computes the action of the automorphism <em>aut</em> on the object x in the
number field; x can be a number field element, or an ideal (possibly
extended). Because of possible confusion with elements and ideals, other
vector or matrix arguments are forbidden.</p>
<p>
</p><pre class="code">   ? nf = nfinit(x^2+1);
   ? L = nfgaloisconj(nf)
   %2 = [-x, x]~
   ? aut = L[1]; /* the non-trivial automorphism */
   ? nfgaloisapply(nf, aut, x)
   %4 = Mod(-x, x^2 + 1)
   ? P = idealprimedec(nf,5); /* prime ideals above 5 */
   ? nfgaloisapply(nf, aut, P[2]) == P[1]
   %6 = 0 \\ !!!!
   ? idealval(nf, nfgaloisapply(nf, aut, P[2]), P[1])
   %7 = 1
</pre><p>
The surprising failure of the equality test (<code>%7</code>) is
due to the fact that although the corresponding prime ideals are equal, their
representations are not. (A prime ideal is specified by a uniformizer, and
there is no guarantee that applying automorphisms yields the same elements
as a direct <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> call.)</p>
<p>
The automorphism can also be given as a column vector, representing the
image of <code>Mod(x, nf.pol)</code> as an algebraic number. This last
representation is more efficient and should be preferred if a given
automorphism must be used in many such calls.</p>
<p>
</p><pre class="code">   ? nf = nfinit(x^3 - 37*x^2 + 74*x - 37);
   ? aut = nfgaloisconj(nf)[2]; \\   an automorphism in basistoalg form
   %2 = -31/11*x^2 + 1109/11*x - 925/11
   ? AUT = nfalgtobasis(nf, aut); \\   same in algtobasis form
   %3 = [16, -6, 5]~
   ? v = [1, 2, 3]~; nfgaloisapply(nf, aut, v) == nfgaloisapply(nf, AUT, v)
   %4 = 1 \\   same result...
   ? for (i=1,10^5, nfgaloisapply(nf, aut, v))
   time = 463 ms.
   ? for (i=1,10^5, nfgaloisapply(nf, AUT, v))
   time = 343 ms.  \\   but the latter is faster
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisapply</b>(GEN nf, GEN aut, GEN x)</code>.</p>
<p>

<hr>
<div id="se:nfgaloisconj"></div>
<div id="nfgaloisconj"></div>
<h4>nfgaloisconj(<em>nf</em>, {<em>flag</em> = 0}, {d})</h4>
<p>
<em>nf</em> being a number field as output by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, computes the
conjugates of a root r of the non-constant polynomial x = <em>nf</em>[1]
expressed as polynomials in r. This also makes sense when the number field
is not Galois since some conjugates may lie in the field.
<em>nf</em> can simply be a polynomial.</p>
<p>
If no flags or <em>flag</em> = 0, use a combination of flag 4 and 1 and the result
is always complete. There is no point whatsoever in using the other flags.</p>
<p>
If <em>flag</em> = 1, use <code><a href="General_number_fields.html#se:nfroots"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfroots</a></code>: a little slow, but guaranteed to work in
polynomial time.</p>
<p>
If <em>flag</em> = 4, use <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>: very fast, but only applies to (most)
Galois fields. If the field is Galois with weakly super-solvable Galois
group (see <code><a href="General_number_fields.html#se:galoisinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoisinit</a></code>), return the complete list of automorphisms, else
only the identity element. If present, d is assumed to be a multiple of the
least common denominator of the conjugates expressed as polynomial in a root
of <em>pol</em>.</p>
<p>
This routine can only compute &Qopf;-automorphisms, but it may be used to get
K-automorphism for any base field K as follows:</p>
<p>
</p><pre class="code">  rnfgaloisconj(nfK, R) = \\ K-automorphisms of L = K[X] / (R)
  {
    my(polabs, N,al,S, ala,k, vR);
    R *= Mod(1, nfK.pol); \\ convert coeffs to polmod elts of K
    vR = variable(R);
    al = Mod(variable(nfK.pol),nfK.pol);
    [polabs,ala,k] = rnfequation(nfK, R, 1);
    Rt = if(k==0,R,subst(R,vR,vR-al*k));
    N = nfgaloisconj(polabs) % Rt; \\ Q-automorphisms of L
    S = select(s-&gt;subst(Rt, vR, Mod(s,Rt)) == 0, N);
    if (k==0, S, apply(s-&gt;subst(s,vR,vR+k*al)-k*al,S));
  }
  K  = nfinit(y^2 + 7);
  rnfgaloisconj(K, x^4 - y*x^3 - 3*x^2 + y*x + 1)  \\ K-automorphisms of L
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisconj0</b>(GEN nf, long flag, GEN d = NULL, long prec)</code>.
Use directly
<code>GEN <b>galoisconj</b>(GEN nf, GEN d)</code>, corresponding to <em>flag</em> = 0, the others
only have historical interest.</p>
<p>

<hr>
<div id="se:nfgrunwaldwang"></div>
<div id="nfgrunwaldwang"></div>
<h4>nfgrunwaldwang(<em>nf</em>, <em>Lpr</em>, <em>Ld</em>, <em>pl</em>, {v = 'x})</h4>
<p>
Given <em>nf</em> a number field in <em>nf</em> or <em>bnf</em> format,
a <code>t_VEC</code> <em>Lpr</em> of primes of <em>nf</em> and a <code>t_VEC</code> <em>Ld</em> of
positive integers of the same length, a <code>t_VECSMALL</code> <em>pl</em> of length
r<sub>1</sub> the number of real places of <em>nf</em>, computes a polynomial with
coefficients in <em>nf</em> defining a cyclic extension of <em>nf</em> of
minimal degree satisfying certain local conditions:</p>
<p>
<b>*</b> at the prime&nbsp;Lpr[i], the extension has local degree a multiple
of&nbsp;Ld[i];</p>
<p>
<b>*</b> at the i-th real place of <em>nf</em>, it is complex if pl[i] = -1
(no condition if pl[i] = 0).</p>
<p>
The extension has degree the LCM of the local degrees. Currently, the degree
is restricted to be a prime power for the search, and to be prime for the
construction because of the <code><a href="General_number_fields.html#se:rnfkummer"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfkummer</a></code> restrictions.</p>
<p>
When <em>nf</em> is &Qopf;, prime integers are accepted instead of <code>prid</code>
structures. However, their primality is not checked and the behavior is
undefined if you provide a composite number.</p>
<p>
<b>Warning.</b> If the number field <em>nf</em> does not contain the n-th
roots of unity where n is the degree of the extension to be computed,
triggers the computation of the <em>bnf</em> of nf(&zeta;<sub>n</sub>), which may be
costly.</p>
<p></p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2-5);
  ? pr = idealprimedec(nf,13)[1];
  ? pol = nfgrunwaldwang(nf, [pr], [2], [0,-1], 'x)
  %3 = x^2 + Mod(3/2*y + 13/2, y^2 - 5)
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfgrunwaldwang</b>(GEN nf, GEN Lpr, GEN Ld, GEN pl, long v = -1)</code> where <code>v</code> is a variable number.</p>
<p>

<hr>
<div id="se:nfhilbert"></div>
<div id="nfhilbert"></div>
<h4>nfhilbert(<em>nf</em>, a, b, {<em>pr</em>})</h4>
<p>
If <em>pr</em> is omitted,
compute the global quadratic Hilbert symbol (a,b) in <em>nf</em>, that
is 1 if x^2 - a y^2 - b z^2 has a non trivial solution (x,y,z) in
<em>nf</em>, and -1 otherwise. Otherwise compute the local symbol modulo
the prime ideal <em>pr</em>, as output by <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code>.</p>
<p>
The library syntax is <code>long <b>nfhilbert0</b>(GEN nf, GEN a, GEN b, GEN pr = NULL)</code>.</p>
<p>
Also available is <code>long <b>nfhilbert</b>(GEN bnf,GEN a,GEN b)</code> (global
quadratic Hilbert symbol).</p>
<p>

<hr>
<div id="se:nfhnf"></div>
<div id="nfhnf"></div>
<h4>nfhnf(<em>nf</em>, x, {<em>flag</em> = 0})</h4>
<p>
Given a pseudo-matrix (A,I), finds a
pseudo-basis (B,J) in Hermite normal form of the module it generates.
If <em>flag</em> is non-zero, also return the transformation matrix U such that
AU = [0|B].</p>
<p>
The library syntax is <code>GEN <b>nfhnf0</b>(GEN nf, GEN x, long flag)</code>.
Also available:</p>
<p>
<code>GEN <b>nfhnf</b>(GEN nf, GEN x)</code> (<em>flag</em> = 0).</p>
<p>
<code>GEN <b>rnfsimplifybasis</b>(GEN bnf, GEN x)</code> simplifies the pseudo-basis
x = (A,I), returning a pseudo-basis (B,J). The ideals in the list J
are integral, primitive and either trivial (equal to the full ring of
integer) or non-principal.</p>
<p>

<hr>
<div id="se:nfhnfmod"></div>
<div id="nfhnfmod"></div>
<h4>nfhnfmod(<em>nf</em>, x, <em>detx</em>)</h4>
<p>
Given a pseudo-matrix (A,I)
and an ideal <em>detx</em> which is contained in (read integral multiple of) the
determinant of (A,I), finds a pseudo-basis in Hermite normal form
of the module generated by (A,I). This avoids coefficient explosion.
<em>detx</em> can be computed using the function <code><a href="General_number_fields.html#se:nfdetint"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfdetint</a></code>.</p>
<p>
The library syntax is <code>GEN <b>nfhnfmod</b>(GEN nf, GEN x, GEN detx)</code>.</p>
<p>

<hr>
<div id="se:nfinit"></div>
<div id="nfinit"></div>
<h4>nfinit(<em>pol</em>, {<em>flag</em> = 0})</h4>
<p>
<em>pol</em> being a non-constant,
preferably monic, irreducible polynomial in &Zopf;[X], initializes a
<em>number field</em> structure (<code>nf</code>) attached to the field K defined
by <em>pol</em>. As such, it's a technical object passed as the first argument
to most <code>nf</code><em>xxx</em> functions, but it contains some information which
may be directly useful. Access to this information via <em>member
functions</em> is preferred since the specific data organization given below
may change in the future. Currently, <code>nf</code> is a row vector with 9
components:</p>
<p>
<em>nf</em>[1] contains the polynomial <em>pol</em> (<code><em>nf</em>.pol</code>).</p>
<p>
<em>nf</em>[2] contains [r1,r2] (<code><em>nf</em>.sign</code>, <code><em>nf</em>.r1</code>,
<code><em>nf</em>.r2</code>), the number of real and complex places of K.</p>
<p>
<em>nf</em>[3] contains the discriminant d(K) (<code><em>nf</em>.disc</code>) of K.</p>
<p>
<em>nf</em>[4] contains the index of <em>nf</em>[1] (<code><em>nf</em>.index</code>),
i.e.&nbsp;[&Zopf;<sub>K</sub> : &Zopf;[&theta;]], where &theta; is any root of <em>nf</em>[1].</p>
<p>
<em>nf</em>[5] is a vector containing 7 matrices M, G, <em>roundG</em>, T,
MD, TI, MDI useful for certain computations in the number field K.</p>
<p>
&nbsp;&nbsp;<b>*</b> M is the (r1+r2) x n matrix whose columns represent
the numerical values of the conjugates of the elements of the integral
basis.</p>
<p>
&nbsp;&nbsp;<b>*</b> G is an n x n matrix such that T2 = ^t G G,
where T2 is the quadratic form T<sub>2</sub>(x) = &sum; |&sigma;(x)|^2, &sigma;
running over the embeddings of K into &Copf;.</p>
<p>
&nbsp;&nbsp;<b>*</b> <em>roundG</em> is a rescaled copy of G, rounded to nearest
integers.</p>
<p>
&nbsp;&nbsp;<b>*</b> T is the n x n matrix whose coefficients are
Tr(&omega;<sub>i</sub>&omega;<sub>j</sub>) where the &omega;<sub>i</sub> are the elements of the
integral basis. Note also that det(T) is equal to the discriminant of the
field K. Also, when understood as an ideal, the matrix T<sup>-1</sup>
generates the codifferent ideal.</p>
<p>
&nbsp;&nbsp;<b>*</b> The columns of MD (<code><em>nf</em>.diff</code>) express a &Zopf;-basis
of the different of K on the integral basis.</p>
<p>
&nbsp;&nbsp;<b>*</b> TI is equal to the primitive part of T<sup>-1</sup>, which has integral
coefficients.</p>
<p>
&nbsp;&nbsp;<b>*</b> Finally, MDI is a two-element representation (for faster
ideal product) of d(K) times the codifferent ideal
(<code><em>nf</em>.disc*<em>nf</em>.codiff</code>, which is an integral ideal). MDI
is only used in <code><a href="General_number_fields.html#se:idealinv"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealinv</a></code>.</p>
<p>
<em>nf</em>[6] is the vector containing the r1+r2 roots
(<code><em>nf</em>.roots</code>) of <em>nf</em>[1] corresponding to the r1+r2
embeddings of the number field into &Copf; (the first r1 components are real,
the next r2 have positive imaginary part).</p>
<p>
<em>nf</em>[7] is an integral basis for &Zopf;<sub>K</sub> (<code><em>nf</em>.zk</code>) expressed
on the powers of&nbsp;&theta;. Its first element is guaranteed to be 1. This
basis is LLL-reduced with respect to T<sub>2</sub> (strictly speaking, it is a
permutation of such a basis, due to the condition that the first element be
1).</p>
<p>
<em>nf</em>[8] is the n x n integral matrix expressing the power
basis in terms of the integral basis, and finally</p>
<p>
<em>nf</em>[9] is the n x n^2 matrix giving the multiplication table
of the integral basis.</p>
<p>
If a non monic polynomial is input, <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> will transform it into a
monic one, then reduce it (see <em>flag</em> = 3). It is allowed, though not very
useful given the existence of <code><a href="General_number_fields.html#se:nfnewprec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfnewprec</a></code>, to input a <em>nf</em> or a
<em>bnf</em> instead of a polynomial. It is also allowed to
input a <em>rnf</em>, in which case an <code>nf</code> structure attached to the
absolute defining polynomial <code>polabs</code> is returned (<em>flag</em> is then ignored).</p>
<p></p>
<p>
</p><pre class="code">  ? nf = nfinit(x^3 - 12); \\ initialize number field Q[X] / (X^3 - 12)
  ? nf.pol   \\ defining polynomial
  %2 = x^3 - 12
  ? nf.disc  \\ field discriminant
  %3 = -972
  ? nf.index \\ index of power basis order in maximal order
  %4 = 2
  ? nf.zk    \\ integer basis, lifted to Q[X]
  %5 = [1, x, 1/2*x^2]
  ? nf.sign  \\ signature
  %6 = [1, 1]
  ? factor(abs(nf.disc ))  \\ determines ramified primes
  %7 =
  [2 2]
  
  [3 5]
  ? idealfactor(nf, 2)
  %8 =
  [[2, [0, 0, -1]~, 3, 1, [0, 1, 0]~] 3]  \\   &pfr;<sub>2</sub>^3
</pre><p></p>
<p></p>
<p>
<b>Huge discriminants, helping nfdisc.</b></p>
<p>
In case <em>pol</em> has a huge discriminant which is difficult to factor,
it is hard to compute from scratch the maximal order. The special input
format [<em>pol</em>, B] is also accepted where <em>pol</em> is a polynomial as
above and B has one of the following forms</p>
<p>
<b>*</b> an integer basis, as would be computed by <code><a href="General_number_fields.html#se:nfbasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfbasis</a></code>: a vector of
polynomials with first element 1. This is useful if the maximal order is
known in advance.</p>
<p>
<b>*</b> an argument <code>listP</code> which specifies a list of primes (see
<code><a href="General_number_fields.html#se:nfbasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfbasis</a></code>). Instead of the maximal order, <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> then computes an
order which is maximal at these particular primes as well as the primes
contained in the private prime table (see <code><a href="Arithmetic_functions.html#se:addprimes"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">addprimes</a></code>). The result is
unconditionaly correct when the discriminant <code>nf.disc</code> factors
completely over this set of primes. The function <code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code> automates
this:</p>
<p>
</p><pre class="code">  ? pol = polcompositum(x^5 - 101, polcyclo(7))[1];
  ? nf = nfinit( [pol, 10^3] );
  ? nfcertify(nf)
  %3 = []
</pre><p>
A priori, <code>nf.zk</code> defines an order which is only known
to be maximal at all primes  &leq; 10^3 (no prime  &leq; 10^3 divides
<code>nf.index</code>). The certification step proves the correctness of the
computation. Had it failed, that particular <code>nf</code> structure could
not have been trusted and may have caused routines using it to fail randomly.
One particular function that remains trustworthy in all cases is
<code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code> when applied to a prime included in the above list
of primes or, more generally, a prime not dividing any entry in
<code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code> output.</p>
<p></p>
<p>
If <em>flag</em> = 2: <em>pol</em> is changed into another polynomial P defining the same
number field, which is as simple as can easily be found using the
<code><a href="General_number_fields.html#se:polredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredbest</a></code> algorithm, and all the subsequent computations are done
using this new polynomial. In particular, the first component of the result
is the modified polynomial.</p>
<p>
If <em>flag</em> = 3, apply <code><a href="General_number_fields.html#se:polredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredbest</a></code> as in case 2, but outputs
[<em>nf</em>,<code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:Mod"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">Mod</a></code>(a,P)], where <em>nf</em> is as before and
<code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:Mod"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">Mod</a></code>(a,P) = <code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:Mod"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">Mod</a></code>(x,<em>pol</em>) gives the change of
variables. This is implicit when <em>pol</em> is not monic: first a linear change
of variables is performed, to get a monic polynomial, then <code><a href="General_number_fields.html#se:polredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredbest</a></code>.</p>
<p>
The library syntax is <code>GEN <b>nfinit0</b>(GEN pol, long flag, long prec)</code>.
Also available are
<code>GEN <b>nfinit</b>(GEN x, long prec)</code> (<em>flag</em> = 0),
<code>GEN <b>nfinitred</b>(GEN x, long prec)</code> (<em>flag</em> = 2),
<code>GEN <b>nfinitred2</b>(GEN x, long prec)</code> (<em>flag</em> = 3).
Instead of the above hardcoded numerical flags in <code>nfinit0</code>, one should
rather use</p>
<p>
<code>GEN <b>nfinitall</b>(GEN x, long flag, long prec)</code>, where <em>flag</em> is an
or-ed combination of</p>
<p>
<b>*</b> <code>nf_RED</code>: find a simpler defining polynomial,</p>
<p>
<b>*</b> <code>nf_ORIG</code>: if <code>nf_RED</code> set, also return the change of variable,</p>
<p>
<b>*</b> <code>nf_ROUND2</code>: <em>Deprecated</em>. Slow down the routine by using an
obsolete normalization algorithm (do not use this one!),</p>
<p>
<b>*</b> <code>nf_PARTIALFACT</code>: <em>Deprecated</em>. Lazy factorization of the
polynomial discriminant. Result is conditional unless <code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code>
can certify it.</p>
<p>

<hr>
<div id="se:nfisideal"></div>
<div id="nfisideal"></div>
<h4>nfisideal(<em>nf</em>, x)</h4>
<p>
Returns 1 if x is an ideal in the number field <em>nf</em>, 0 otherwise.</p>
<p>
The library syntax is <code>long <b>isideal</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:nfisincl"></div>
<div id="nfisincl"></div>
<h4>nfisincl(f, g)</h4>
<p>
Let f and g define number fields, where f and g are irreducible
polynomials in &Qopf;[X] and <em>nf</em> structures as output by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>.
Tests whether the number field f is conjugate to a subfield of the field
g. If they are not, the output is the integer 0. If they are, the output is
a vector of polynomials, each polynomial a representing an embedding
i.e.&nbsp;being such that g | f o a. If either f or g is not
irreducible, the result is undefined.</p>
<p></p>
<p>
</p><pre class="code">  ? T = x^6 + 3*x^4 - 6*x^3 + 3*x^2 + 18*x + 10;
  ? U = x^3 + 3*x^2 + 3*x - 2
  
  ? v = nfisincl(U, T);
  %2 = [24/179*x^5-27/179*x^4+80/179*x^3-234/179*x^2+380/179*x+94/179]
  
  ? subst(U, x, Mod(v[1],T))
  %3 = Mod(0, x^6 + 3*x^4 - 6*x^3 + 3*x^2 + 18*x + 10)
  ? #nfisincl(x^2+1, T) \\ two embeddings
  %4 = 2
  
  \\ same result with nf structures
  ? nfisincl(U, L = nfinit(T)) == v
  %5 = 1
  ? nfisincl(K = nfinit(U), T) == v
  %6 = 1
  ? nfisincl(K, L) == v
  %7 = 1
  
  \\ comparative bench: an nf is a little faster, esp. for the subfield
  ? B = 10^3;
  ? for (i=1, B, nfisincl(U,T))
  time = 712 ms.
  
  ? for (i=1, B, nfisincl(K,T))
  time = 485 ms.
  
  ? for (i=1, B, nfisincl(U,L))
  time = 704 ms.
  
  ? for (i=1, B, nfisincl(K,L))
  time = 465 ms.
</pre><p>
Using an <em>nf</em> structure for the potential subfield is
faster if the structure is already available. On the other hand, the gain in
<code><a href="General_number_fields.html#se:nfisincl"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfisincl</a></code> is usually not sufficient to make it worthwhile to initialize
only for that purpose.</p>
<p>
</p><pre class="code">  ? for (i=1, B, nfinit(U))
  time = 308 ms.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfisincl</b>(GEN f, GEN g)</code>.</p>
<p>

<hr>
<div id="se:nfisisom"></div>
<div id="nfisisom"></div>
<h4>nfisisom(f, g)</h4>
<p>
As <code><a href="General_number_fields.html#se:nfisincl"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfisincl</a></code>, but tests for isomorphism. More efficient if
f or g is a number field structure.</p>
<p>
</p><pre class="code">  ? f = x^6 + 30*x^5 + 495*x^4 + 1870*x^3 + 16317*x^2 - 22560*x + 59648;
  ? g = x^6 + 42*x^5 + 999*x^4 + 8966*x^3 + 36117*x^2 + 21768*x + 159332;
  ? h = x^6 + 30*x^5 + 351*x^4 + 2240*x^3 + 10311*x^2 + 35466*x + 58321;
  
  ? #nfisisom(f,g)  \\ two isomorphisms
  %3 = 2
  ? nfisisom(f,h) \\ not isomorphic
  %4 = 0
  \\ comparative bench
  ? K = nfinit(f); L = nfinit(g); B = 10^3;
  ? for (i=1, B, nfisisom(f,g))
  time = 6,124 ms.
  ? for (i=1, B, nfisisom(K,g))
  time = 3,356 ms.
  ? for (i=1, B, nfisisom(f,L))
  time = 3,204 ms.
  ? for (i=1, B, nfisisom(K,L))
  time = 3,173 ms.
</pre><p></p>
<p>
The function is usually very fast when the fields are non-isomorphic,
whenever the fields can be distinguished via a simple invariant such as
degree, signature or discriminant. It may be slower when the fields
share all invariants, but still faster than computing actual isomorphisms:</p>
<p>
</p><pre class="code">  \\ usually very fast when the answer is 'no':
  ? for (i=1, B, nfisisom(f,h))
  time = 32 ms.
  
  \\ but not always
  ? u = x^6 + 12*x^5 + 6*x^4 - 377*x^3 - 714*x^2 + 5304*x + 15379
  ? v = x^6 + 12*x^5 + 60*x^4 + 166*x^3 + 708*x^2 + 6600*x + 23353
  ? nfisisom(u,v)
  %13 = 0
  ? polsturm(u) == polsturm(v)
  %14 = 1
  ? nfdisc(u) == nfdisc(v)
  %15 = 1
  ? for(i=1,B, nfisisom(u,v))
  time = 1,821 ms.
  ? K = nfinit(u); L = nfinit(v);
  ? for(i=1,B, nfisisom(K,v))
  time = 232 ms.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfisisom</b>(GEN f, GEN g)</code>.</p>
<p>

<hr>
<div id="se:nfislocalpower"></div>
<div id="nfislocalpower"></div>
<h4>nfislocalpower(<em>nf</em>, <em>pr</em>, a, n)</h4>
<p>
Let <em>nf</em> be a <em>nf</em> structure attached to a number field K,
let a  &in;  K and let <em>pr</em> be a <em>prid</em> structure attached to a
maximal ideal v. Return 1 if a is an n-th power in the completed
local field K<sub>v</sub>, and 0 otherwise.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K,2)[1]; \\ the ramified prime above 2
  ? nfislocalpower(K,P,-1, 2) \\ -1 is a square
  %3 = 1
  ? nfislocalpower(K,P,-1, 4) \\ ... but not a 4-th power
  %4 = 0
  ? nfislocalpower(K,P,2, 2)  \\ 2 is not a square
  %5 = 0
  
  ? Q = idealprimedec(K,5)[1]; \\ a prime above 5
  ? nfislocalpower(K,Q, [0, 32]~, 30)  \\ 32*I is locally a 30-th power
  %7 = 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>nfislocalpower</b>(GEN nf, GEN pr, GEN a, GEN n)</code>.</p>
<p>

<hr>
<div id="se:nfkermodpr"></div>
<div id="nfkermodpr"></div>
<h4>nfkermodpr(<em>nf</em>, x, <em>pr</em>)</h4>
<p>
This function is obsolete, use <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code>.</p>
<p>
Kernel of the matrix a in &Zopf;<sub>K</sub>/<em>pr</em>, where <em>pr</em> is in
<b>modpr</b> format (see <code><a href="General_number_fields.html#se:nfmodprinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprinit</a></code>).</p>
<p>
The library syntax is <code>GEN <b>nfkermodpr</b>(GEN nf, GEN x, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nfM_to_FqM</code>, then work there.</p>
<p>

<hr>
<div id="se:nfmodpr"></div>
<div id="nfmodpr"></div>
<h4>nfmodpr(<em>nf</em>, x, <em>pr</em>)</h4>
<p>
Map x to a <code>t_FFELT</code> in the residue field modulo <em>pr</em>.
The argument <em>pr</em> is either a maximal ideal in <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code>
format or, preferably, a <em>modpr</em> structure from <code><a href="General_number_fields.html#se:nfmodprinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprinit</a></code>. The
function <code><a href="General_number_fields.html#se:nfmodprlift"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprlift</a></code> allows to lift back to &Zopf;<sub>K</sub>.</p>
<p>
Note that the function applies to number field elements and not to
vector / matrices / polynomials of such. Use <code><a href="Programming_in_GP__other_specific_functions.html#se:apply"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__other_specific_functions.html'">apply</a></code> to convert
recursive structures.</p>
<p></p>
<p>
</p><pre class="code">  ? K = nfinit(y^3-250);
  ? P = idealprimedec(K, 5)[2];
  ? modP = nfmodprinit(K,P);
  ? K.zk
  %4 = [1, 1/5*y, 1/25*y^2]
  ? apply(t-&gt;nfmodpr(K,t,modP), K.zk)
  %5 = [1, y, 2*y + 1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfmodpr</b>(GEN nf, GEN x, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:nfmodprinit"></div>
<div id="nfmodprinit"></div>
<h4>nfmodprinit(<em>nf</em>, <em>pr</em>)</h4>
<p>
Transforms the prime ideal <em>pr</em> into <code>modpr</code> format necessary
for all operations modulo <em>pr</em> in the number field <em>nf</em>.
The functions <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code> and <code><a href="General_number_fields.html#se:nfmodprlift"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprlift</a></code> allow to project
to and lift from the residue field.</p>
<p>
The library syntax is <code>GEN <b>nfmodprinit</b>(GEN nf, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:nfmodprlift"></div>
<div id="nfmodprlift"></div>
<h4>nfmodprlift(<em>nf</em>, x, <em>pr</em>)</h4>
<p>
Lift the <code>t_FFELT</code> x (from <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code>) in the residue field
modulo <em>pr</em> to the ring of integers. Vectors and matrices are also
supported. For polynomials, use <code><a href="Programming_in_GP__other_specific_functions.html#se:apply"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__other_specific_functions.html'">apply</a></code> and the present function.</p>
<p>
The argument <em>pr</em> is either a maximal ideal in <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code>
format or, preferably, a <em>modpr</em> structure from <code><a href="General_number_fields.html#se:nfmodprinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprinit</a></code>.
There are no compatibility checks to try and decide whether x is attached
the same residue field as defined by <em>pr</em>: the result is undefined
if not.</p>
<p>
The function <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code> allows to reduce to the residue field.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^3-250);
  ? P = idealprimedec(K, 5)[2];
  ? modP = nfmodprinit(K,P);
  ? K.zk
  %4 = [1, 1/5*y, 1/25*y^2]
  ? apply(t-&gt;nfmodpr(K,t,modP), K.zk)
  %5 = [1, y, 2*y + 1]
  ? nfmodprlift(K, %, modP)
  %6 = [1, 1/5*y, 2/5*y + 1]
  ? nfeltval(K, %[3] - K.zk[3], P)
  %7 = 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfmodprlift</b>(GEN nf, GEN x, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:nfnewprec"></div>
<div id="nfnewprec"></div>
<h4>nfnewprec(<em>nf</em>)</h4>
<p>
Transforms the number field <em>nf</em>
into the corresponding data using current (usually larger) precision. This
function works as expected if <em>nf</em> is in fact a <em>bnf</em> or a <em>bnr</em>
(update structure to current precision) but may be quite slow: many
generators of principal ideals have to be computed; note that in this latter
case, the <em>bnf</em> must contain fundamental units.</p>
<p>
The library syntax is <code>GEN <b>nfnewprec</b>(GEN nf, long prec)</code>.
See also <code>GEN <b>bnfnewprec</b>(GEN bnf, long prec)</code> and
<code>GEN <b>bnrnewprec</b>(GEN bnr, long prec)</code>.</p>
<p>

<hr>
<div id="se:nfpolsturm"></div>
<div id="nfpolsturm"></div>
<h4>nfpolsturm(<em>nf</em>, T, {<em>pl</em>})</h4>
<p>
Given a polynomial T with coefficients in the number field <em>nf</em>,
returns the number of real roots of the s(T) where s runs through
the real embeddings of the field specified by optional argument <em>pl</em>:</p>
<p>
<b>*</b> <em>pl</em> omitted: all r<sub>1</sub> real places;</p>
<p>
<b>*</b> <em>pl</em> an integer between 1 and r<sub>1</sub>: the embedding attached to
the i-th real root of <code>nf.pol</code>, i.e. <code>nf.roots[i]</code>;</p>
<p>
<b>*</b> <em>pl</em> a vector or <code>t_VECSMALL</code>: the embeddings
attached to the <em>pl</em>[i]-th real roots of <code>nf.pol</code>.</p>
<p></p>
<p>
</p><pre class="code">  ? nf = nfinit('y^2 - 2);
  ? nf.sign
  %2 = [2, 0]
  ? nf.roots
  %3 = [-1.414..., 1.414...]
  ? T = x^2 + 'y;
  ? nfpolsturm(nf, T, 1) \\ subst(T,y,sqrt(2)) has two real roots
  %5 = 2
  ? nfpolsturm(nf, T, 2) \\ subst(T,y,-sqrt(2)) has no real root
  %6 = 0
  ? nfpolsturm(nf, T) \\ all embeddings together
  %7 = [2, 0]
  ? nfpolsturm(nf, T, [2,1]) \\ second then first embedding
  %8 = [0, 2]
  ? nfpolsturm(nf, x^3)  \\ number of distinct roots !
  %9 = [1, 1]
  ? nfpolsturm(nf, x, 6) \\ there are only 2 real embeddings !
   ***   at top-level: nfpolsturm(nf,x,6)
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
   *** nfpolsturm: domain error in nfpolsturm: index &gt; 2
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfpolsturm</b>(GEN nf, GEN T, GEN pl = NULL)</code>.</p>
<p>

<hr>
<div id="se:nfroots"></div>
<div id="nfroots"></div>
<h4>nfroots({<em>nf</em>}, x)</h4>
<p>
Roots of the polynomial x in the
number field <em>nf</em> given by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> without multiplicity (in &Qopf;
if <em>nf</em> is omitted). x has coefficients in the number field (scalar,
polmod, polynomial, column vector). The main variable of <em>nf</em> must be
of lower priority than that of x (see Section se:priority). However if the
coefficients of the number field occur explicitly (as polmods) as
coefficients of x, the variable of these polmods <em>must</em> be the same as
the main variable of t (see <code><a href="General_number_fields.html#se:nffactor"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nffactor</a></code>).</p>
<p>
It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <code>nf</code>
structure will then be computed internally. This is useful in two
situations: when you do not need the <code>nf</code> elsewhere, or when you cannot
initialize an <code>nf</code> due to integer factorization difficulties when
attempting to compute the field discriminant and maximal order.</p>
<p>
<b>Caveat.</b> <code>nfinit([T, listP])</code> allows to compute in polynomial
time a conditional <em>nf</em> structure, which sets <code>nf.zk</code> to an order
which is not guaranteed to be maximal at all primes. Always either use
<code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code> first (which may not run in polynomial time) or make sure
to input <code>nf.pol</code> instead of the conditional <em>nf</em>: <code><a href="General_number_fields.html#se:nfroots"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfroots</a></code> is
able to recover in polynomial time in this case, instead of potentially
missing a factor.</p>
<p>
The library syntax is <code>GEN <b>nfroots</b>(GEN nf = NULL, GEN x)</code>.
See also <code>GEN <b>nfrootsQ</b>(GEN x)</code>,
corresponding to <code>nf</code> = <code>NULL</code>.</p>
<p>

<hr>
<div id="se:nfrootsof1"></div>
<div id="nfrootsof1"></div>
<h4>nfrootsof1(<em>nf</em>)</h4>
<p>
Returns a two-component vector [w,z] where w is the number of roots of
unity in the number field <em>nf</em>, and z is a primitive w-th root
of unity.</p>
<p>
</p><pre class="code">  ? K = nfinit(polcyclo(11));
  ? nfrootsof1(K)
  %2 = [22, [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]~]
  ? z = nfbasistoalg(K, %[2])   \\ in algebraic form
  %3 = Mod(-x^5, x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)
  ? [lift(z^11), lift(z^2)]     \\ proves that the order of z is 22
  %4 = [-1, -x^9 - x^8 - x^7 - x^6 - x^5 - x^4 - x^3 - x^2 - x - 1]
</pre><p></p>
<p>
This function guesses the number w as the gcd of the #k(v)<sup>*</sup> for
unramified v above odd primes, then computes the roots in <em>nf</em>
of the w-th cyclotomic polynomial: the algorithm is polynomial time with
respect to the field degree and the bitsize of the multiplication table in
<em>nf</em> (both of them polynomially bounded in terms of the size of the
discriminant). Fields of degree up to 100 or so should require less than
one minute.</p>
<p>
The library syntax is <code>GEN <b>rootsof1</b>(GEN nf)</code>.
Also available is <code>GEN <b>rootsof1_kannan</b>(GEN nf)</code>, that computes
all algebraic integers of T<sub>2</sub> norm equal to the field degree
(all roots of 1, by Kronecker's theorem). This is in general a little
faster than the default when there <em>are</em> roots of 1 in the field
(say twice faster), but can be much slower (say, <em>days</em> slower), since
the algorithm is a priori exponential in the field degree.</p>
<p>

<hr>
<div id="se:nfsnf"></div>
<div id="nfsnf"></div>
<h4>nfsnf(<em>nf</em>, x, {<em>flag</em> = 0})</h4>
<p>
Given a torsion &Zopf;<sub>K</sub>-module x attached to the square integral
invertible pseudo-matrix (A,I,J), returns an ideal list
D = [d<sub>1</sub>,...,d<sub>n</sub>] which is the Smith normal form of x. In other
words, x is isomorphic to &Zopf;<sub>K</sub>/d<sub>1</sub>&bigoplus; ...&bigoplus; &Zopf;<sub>K</sub>/d<sub>n</sub> and d<sub>i</sub>
divides d<sub>i-1</sub> for i &geq; 2. If <em>flag</em> is non-zero return [D,U,V], where
UAV is the identity.</p>
<p>
See Section <a href="General_number_fields.html#se:ZKmodules"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:ZKmodules</a> for the definition of integral pseudo-matrix;
briefly, it is input as a 3-component row vector [A,I,J] where
I = [b<sub>1</sub>,...,b<sub>n</sub>] and J = [a<sub>1</sub>,...,a<sub>n</sub>] are two ideal lists,
and A is a square n x n matrix with columns (A<sub>1</sub>,...,A<sub>n</sub>),
seen as elements in K^n (with canonical basis (e<sub>1</sub>,...,e<sub>n</sub>)).
This data defines the &Zopf;<sub>K</sub> module x given by
 (b_1e<sub>1</sub>&bigoplus; ...&bigoplus;  b_ne<sub>n</sub>) / (a_1A<sub>1</sub>&bigoplus; ...&bigoplus;  a_nA<sub>n</sub>)
 , 
The integrality condition is a<sub>i,j</sub>  &in;  b<sub>i</sub> a<sub>j</sub><sup>-1</sup> for all i,j. If it
is not satisfied, then the d<sub>i</sub> will not be integral. Note that every
finitely generated torsion module is isomorphic to a module of this form and
even with b<sub>i</sub> = Z<sub>K</sub> for all i.</p>
<p>
The library syntax is <code>GEN <b>nfsnf0</b>(GEN nf, GEN x, long flag)</code>.
Also available:</p>
<p>
<code>GEN <b>nfsnf</b>(GEN nf, GEN x)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:nfsolvemodpr"></div>
<div id="nfsolvemodpr"></div>
<h4>nfsolvemodpr(<em>nf</em>, a, b, P)</h4>
<p>
This function is obsolete, use <code><a href="General_number_fields.html#se:nfmodpr"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodpr</a></code>.</p>
<p>
Let P be a prime ideal in <b>modpr</b> format (see <code><a href="General_number_fields.html#se:nfmodprinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfmodprinit</a></code>),
let a be a matrix, invertible over the residue field, and let b be
a column vector or matrix. This function returns a solution of a.x = 
b; the coefficients of x are lifted to <em>nf</em> elements.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K, 3)[1];
  ? P = nfmodprinit(K, P);
  ? a = [y+1, y; y, 0]; b = [1, y]~
  ? nfsolvemodpr(K, a,b, P)
  %5 = [1, 2]~
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfsolvemodpr</b>(GEN nf, GEN a, GEN b, GEN P)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nfM_to_FqM</code>, then work there.</p>
<p>

<hr>
<div id="se:nfsplitting"></div>
<div id="nfsplitting"></div>
<h4>nfsplitting(P, {d})</h4>
<p>
Defining polynomial over&nbsp;&Qopf; for the splitting field of <em>P</em>,
that is the smallest field over which P is totally split. If P
can also be given by a&nbsp;<code>nf</code> structure, which is more efficient.
If d is given, it must be a multiple of the splitting field degree.
Note that if P is reducible the splitting field degree can be smaller
than the degree of P.</p>
<p>
</p><pre class="code">  ? K = nfinit(x^3-2);
  ? nfsplitting(K)
  %2 = x^6 + 108
  ? nfsplitting(x^8-2)
  %3 = x^16 + 272*x^8 + 64
  ? S = nfsplitting(x^6-8) // reducible
  %4 = x^4+2*x^2+4
  ? lift(nfroots(subst(S,x,a),x^6-8))
  %5 = [-a,a,-1/2*a^3-a,-1/2*a^3,1/2*a^3,1/2*a^3+a]
</pre><p></p>
<p></p>
<p>Specifying the degree of the splitting field can make the computation faster.</p>
<p>
</p><pre class="code">  ? nfsplitting(x^17-123);
  time = 3,607 ms.
  ? poldegree(%)
  %2 = 272
  ? nfsplitting(x^17-123,272);
  time = 150 ms.
  ? nfsplitting(x^17-123,273);
   *** nfsplitting: Warning: ignoring incorrect degree bound 273
  time = 3,611 ms.
</pre><p></p>
<p></p>
<p>The complexity of the algorithm is polynomial in the degree d of the
splitting field and the bitsize of T; if d is large the result will
likely be unusable, e.g. <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> will not be an option:</p>
<p>
</p><pre class="code">  ? nfsplitting(x^6-x-1)
  [... degree 720 polynomial deleted ...]
  time = 11,020 ms.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfsplitting</b>(GEN P, GEN d = NULL)</code>.</p>
<p>

<hr>
<div id="se:nfsubfields"></div>
<div id="nfsubfields"></div>
<h4>nfsubfields(<em>pol</em>, {d = 0})</h4>
<p>
Finds all subfields of degree
d of the number field defined by the (monic, integral) polynomial
<em>pol</em> (all subfields if d is null or omitted). The result is a vector
of subfields, each being given by [g,h], where g is an absolute equation
and h expresses one of the roots of g in terms of the root x of the
polynomial defining <em>nf</em>. This routine uses J.&nbsp;Kl&uuml;ners's algorithm
in the general case, and B.&nbsp;Allombert's <code><a href="General_number_fields.html#se:galoissubfields"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">galoissubfields</a></code> when <em>nf</em>
is Galois (with weakly supersolvable Galois group).</p>
<p>
The library syntax is <code>GEN <b>nfsubfields</b>(GEN pol, long d)</code>.</p>
<p>

<hr>
<div id="se:polcompositum"></div>
<div id="polcompositum"></div>
<h4>polcompositum(P, Q, {<em>flag</em> = 0})</h4>
<p>
 P and Q
being squarefree polynomials in &Zopf;[X] in the same variable, outputs
the simple factors of the &eacute;tale &Qopf;-algebra A = &Qopf;(X, Y) / (P(X), Q(Y)).
The factors are given by a list of polynomials R in &Zopf;[X], attached to
the number field &Qopf;(X)/ (R), and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.</p>
<p>
Note that it is more efficient to reduce to the case where P and Q are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor R if and only if the number
fields defined by P and Q are linearly disjoint (their intersection is
&Qopf;).</p>
<p>
Assuming P is irreducible (of smaller degree than Q for efficiency), it
is in general much faster to proceed as follows</p>
<p>
</p><pre class="code">  nf = nfinit(P); L = nffactor(nf, Q)[,1];
  vector(#L, i, rnfequation(nf, L[i]))
</pre><p></p>
<p>
to obtain the same result. If you are only interested in the degrees of the
simple factors, the <code><a href="General_number_fields.html#se:rnfequation"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfequation</a></code> instruction can be replaced by a
trivial <code>poldegree(P) * poldegree(L[i])</code>.</p>
<p>
The binary digits of <em>flag</em> mean</p>
<p>
1: outputs a vector of 4-component vectors [R,a,b,k], where R
ranges through the list of all possible compositums as above, and a
(resp. b) expresses the root of P (resp. Q) as an element of
&Qopf;(X)/(R). Finally, k is a small integer such that b + ka = X modulo
R.</p>
<p>
2: assume that P and Q define number fields which are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides &Qopf;. This allows to save a costly
factorization over &Qopf;. In this case return the single simple factor
instead of a vector with one element.</p>
<p>
A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field &Qopf;(&zeta;<sub>5</sub>, 5<sup>1/5</sup>):</p>
<p>
</p><pre class="code">  ? L = polcompositum(x^5 - 5, polcyclo(5), 1); \\  list of [R,a,b,k]
  ? [R, a] = L[1];  \\  pick the single factor, extract R,a (ignore b,k)
  ? R               \\  defines the compositum
  %3 = x^20 + 5*x^19 + 15*x^18 + 35*x^17 + 70*x^16 + 141*x^15 + 260*x^14\
  + 355*x^13 + 95*x^12 - 1460*x^11 - 3279*x^10 - 3660*x^9 - 2005*x^8    \
  + 705*x^7 + 9210*x^6 + 13506*x^5 + 7145*x^4 - 2740*x^3 + 1040*x^2     \
  - 320*x + 256
  ? a^5 - 5         \\  a fifth root of 5
  %4 = 0
  ? [T, X] = polredbest(R, 1);
  ? T     \\  simpler defining polynomial for &Qopf;[x]/(R)
  %6 = x^20 + 25*x^10 + 5
  ? X     \\   root of R in &Qopf;[y]/(T(y))
  %7 = Mod(-1/11*x^15 - 1/11*x^14 + 1/22*x^10 - 47/22*x^5 - 29/11*x^4 + 7/22,\
  x^20 + 25*x^10 + 5)
  ? a = subst(a.pol, 'x, X)  \\  <code>a</code> in the new coordinates
  %8 = Mod(1/11*x^14 + 29/11*x^4, x^20 + 25*x^10 + 5)
  ? a^5 - 5
  %9 = 0
</pre><p>
In the above example, x^5-5 and the 5-th cyclotomic
polynomial are irreducible over &Qopf;; they have coprime degrees so
define linearly disjoint extensions and we could have started by</p>
<p>
</p><pre class="code">  ? [R,a] = polcompositum(x^5 - 5, polcyclo(5), 3); \\  [R,a,b,k]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>polcompositum0</b>(GEN P, GEN Q, long flag)</code>.
Also available are
<code>GEN <b>compositum</b>(GEN P, GEN Q)</code> (<em>flag</em> = 0) and
<code>GEN <b>compositum2</b>(GEN P, GEN Q)</code> (<em>flag</em> = 1).</p>
<p>

<hr>
<div id="se:polgalois"></div>
<div id="polgalois"></div>
<h4>polgalois(T)</h4>
<p>
Galois group of the non-constant
polynomial T &in; &Qopf;[X]. In the present version <b>2.12.1</b>, T must be irreducible
and the degree d of T must be less than or equal to 7. If the
<code>galdata</code> package has been installed, degrees 8, 9, 10 and 11 are also
implemented. By definition, if K = &Qopf;[x]/(T), this computes the action of
the Galois group of the Galois closure of K on the d distinct roots of
T, up to conjugacy (corresponding to different root orderings).</p>
<p>
The output is a 4-component vector [n,s,k,name] with the
following meaning: n is the cardinality of the group, s is its signature
(s = 1 if the group is a subgroup of the alternating group A<sub>d</sub>, s = -1
otherwise) and name is a character string containing name of the transitive
group according to the GAP 4 transitive groups library by Alexander Hulpke.</p>
<p>
k is more arbitrary and the choice made up to version&nbsp;2.2.3 of PARI is rather
unfortunate: for d &gt; 7, k is the numbering of the group among all
transitive subgroups of S<sub>d</sub>, as given in "The transitive groups of degree up
to eleven", G.&nbsp;Butler and J.&nbsp;McKay, <em>Communications in Algebra</em>, vol.&nbsp;11,
1983,
pp.&nbsp;863--911 (group k is denoted T<sub>k</sub> there). And for d &leq; 7, it was ad
hoc, so as to ensure that a given triple would denote a unique group.
Specifically, for polynomials of degree d &leq; 7, the groups are coded as
follows, using standard notations</p>
<p>
In degree 1: S<sub>1</sub> = [1,1,1].</p>
<p>
In degree 2: S<sub>2</sub> = [2,-1,1].</p>
<p>
In degree 3: A<sub>3</sub> = C<sub>3</sub> = [3,1,1], S<sub>3</sub> = [6,-1,1].</p>
<p>
In degree 4: C<sub>4</sub> = [4,-1,1], V<sub>4</sub> = [4,1,1], D<sub>4</sub> = [8,-1,1], A<sub>4</sub> = [12,1,1],
S<sub>4</sub> = [24,-1,1].</p>
<p>
In degree 5: C<sub>5</sub> = [5,1,1], D<sub>5</sub> = [10,1,1], M<sub>20</sub> = [20,-1,1],
A<sub>5</sub> = [60,1,1], S<sub>5</sub> = [120,-1,1].</p>
<p>
In degree 6: C<sub>6</sub> = [6,-1,1], S<sub>3</sub> = [6,-1,2], D<sub>6</sub> = [12,-1,1], A<sub>4</sub> = [12,1,1],
G<sub>18</sub> = [18,-1,1], S<sub>4</sub>^ -= [24,-1,1], A<sub>4</sub> x C<sub>2</sub> = [24,-1,2],
S<sub>4</sub>^ += [24,1,1], G<sub>36</sub>^ -= [36,-1,1], G<sub>36</sub>^ += [36,1,1],
S<sub>4</sub> x C<sub>2</sub> = [48,-1,1], A<sub>5</sub> = PSL<sub>2</sub>(5) = [60,1,1], G<sub>72</sub> = [72,-1,1],
S<sub>5</sub> = PGL<sub>2</sub>(5) = [120,-1,1], A<sub>6</sub> = [360,1,1], S<sub>6</sub> = [720,-1,1].</p>
<p>
In degree 7: C<sub>7</sub> = [7,1,1], D<sub>7</sub> = [14,-1,1], M<sub>21</sub> = [21,1,1],
M<sub>42</sub> = [42,-1,1], PSL<sub>2</sub>(7) = PSL<sub>3</sub>(2) = [168,1,1], A<sub>7</sub> = [2520,1,1],
S<sub>7</sub> = [5040,-1,1].</p>
<p>
This is deprecated and obsolete, but for reasons of backward compatibility,
we cannot change this behavior yet. So you can use the default
<code>new_galois_format</code> to switch to a consistent naming scheme, namely k is
always the standard numbering of the group among all transitive subgroups of
S<sub>n</sub>. If this default is in effect, the above groups will be coded as:</p>
<p>
In degree 1: S<sub>1</sub> = [1,1,1].</p>
<p>
In degree 2: S<sub>2</sub> = [2,-1,1].</p>
<p>
In degree 3: A<sub>3</sub> = C<sub>3</sub> = [3,1,1], S<sub>3</sub> = [6,-1,2].</p>
<p>
In degree 4: C<sub>4</sub> = [4,-1,1], V<sub>4</sub> = [4,1,2], D<sub>4</sub> = [8,-1,3], A<sub>4</sub> = [12,1,4],
S<sub>4</sub> = [24,-1,5].</p>
<p>
In degree 5: C<sub>5</sub> = [5,1,1], D<sub>5</sub> = [10,1,2], M<sub>20</sub> = [20,-1,3],
A<sub>5</sub> = [60,1,4], S<sub>5</sub> = [120,-1,5].</p>
<p>
In degree 6: C<sub>6</sub> = [6,-1,1], S<sub>3</sub> = [6,-1,2], D<sub>6</sub> = [12,-1,3], A<sub>4</sub> = [12,1,4],
G<sub>18</sub> = [18,-1,5], A<sub>4</sub> x C<sub>2</sub> = [24,-1,6], S<sub>4</sub>^ += [24,1,7],
S<sub>4</sub>^ -= [24,-1,8], G<sub>36</sub>^ -= [36,-1,9], G<sub>36</sub>^ += [36,1,10],
S<sub>4</sub> x C<sub>2</sub> = [48,-1,11], A<sub>5</sub> = PSL<sub>2</sub>(5) = [60,1,12], G<sub>72</sub> = [72,-1,13],
S<sub>5</sub> = PGL<sub>2</sub>(5) = [120,-1,14], A<sub>6</sub> = [360,1,15], S<sub>6</sub> = [720,-1,16].</p>
<p>
In degree 7: C<sub>7</sub> = [7,1,1], D<sub>7</sub> = [14,-1,2], M<sub>21</sub> = [21,1,3],
M<sub>42</sub> = [42,-1,4], PSL<sub>2</sub>(7) = PSL<sub>3</sub>(2) = [168,1,5], A<sub>7</sub> = [2520,1,6],
S<sub>7</sub> = [5040,-1,7].</p>
<p></p>
<p>
<b>Warning.</b> The method used is that of resolvent polynomials and is
sensitive to the current precision. The precision is updated internally but,
in very rare cases, a wrong result may be returned if the initial precision
was not sufficient.</p>
<p>
The library syntax is <code>GEN <b>polgalois</b>(GEN T, long prec)</code>.
To enable the new format in library mode,
set the global variable <code>new_galois_format</code> to 1.</p>
<p>

<hr>
<div id="se:polred"></div>
<div id="polred"></div>
<h4>polred(T, {<em>flag</em> = 0})</h4>
<p>
This function is <em>deprecated</em>, use <code><a href="General_number_fields.html#se:polredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredbest</a></code> instead.
Finds polynomials with reasonably small coefficients defining subfields of
the number field defined by T. One of the polynomials always defines &Qopf;
(hence has degree 1), and another always defines the same number field
as T if T is irreducible.</p>
<p>
All T accepted by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> are also allowed here;
in particular, the format <code>[T, listP]</code> is recommended, e.g. with
<code>listP</code> = 10^5 or a vector containing all ramified primes. Otherwise,
the maximal order of &Qopf;[x]/(T) must be computed.</p>
<p>
The following binary digits of <em>flag</em> are significant:</p>
<p>
1: Possibly use a suborder of the maximal order. The
primes dividing the index of the order chosen are larger than
<code>primelimit</code> or divide integers stored in the <code><a href="Arithmetic_functions.html#se:addprimes"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">addprimes</a></code> table.
This flag is <em>deprecated</em>, the <code>[T, listP]</code> format is more
flexible.</p>
<p>
2: gives also elements. The result is a two-column matrix, the first column
giving primitive elements defining these subfields, the second giving the
corresponding minimal polynomials.</p>
<p>
</p><pre class="code">  ? M = polred(x^4 + 8, 2)
  %1 =
  [           1         x - 1]
  
  [ 1/2*x^2 + 1 x^2 - 2*x + 3]
  
  [-1/2*x^2 + 1 x^2 - 2*x + 3]
  
  [     1/2*x^2       x^2 + 2]
  
  [     1/4*x^3       x^4 + 2]
  ? minpoly(Mod(M[2,1], x^4+8))
  %2 = x^2 + 2
</pre><p></p>
<p></p>
<p>
The library syntax is <code><b>polred</b>(GEN T)</code> (<em>flag</em> = 0). Also available is
<code>GEN <b>polred2</b>(GEN T)</code> (<em>flag</em> = 2). The function <code>polred0</code> is
deprecated, provided for backward compatibility.</p>
<p>

<hr>
<div id="se:polredabs"></div>
<div id="polredabs"></div>
<h4>polredabs(T, {<em>flag</em> = 0})</h4>
<p>
Returns a canonical defining polynomial P for the number field
&Qopf;[X]/(T) defined by T, such that the sum of the squares of the modulus
of the roots (i.e.&nbsp;the T<sub>2</sub>-norm) is minimal. Different T defining
isomorphic number fields will yield the same P. All T accepted by
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> are also allowed here, e.g. non-monic polynomials, or pairs
<code>[T, listP]</code> specifying that a non-maximal order may be used. For
convenience, any number field structure (<em>nf</em>, <em>bnf</em>,...) can also
be used instead of T.</p>
<p>
</p><pre class="code">  ? polredabs(x^2 + 16)
  %1 = x^2 + 1
  ? K = bnfinit(x^2 + 16); polredabs(K)
  %2 = x^2 + 1
</pre><p></p>
<p></p>
<p>
<b>Warning 1.</b> Using a <code>t_POL</code> T requires computing
and fully factoring the discriminant d<sub>K</sub> of the maximal order which may be
very hard. You can use the format <code>[T, listP]</code>, where <code>listP</code>
encodes a list of known coprime divisors of disc(T) (see <code>??nfbasis</code>),
to help the routine, thereby replacing this part of the algorithm by a
polynomial time computation But this may only compute a suborder of the
maximal order, when the divisors are not squarefree or do not include all
primes dividing d<sub>K</sub>. The routine attempts to certify the result
independently of this order computation as per <code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code>: we try to
prove that the computed order is maximal. If the certification fails,
the routine then fully factors the integers returned by <code><a href="General_number_fields.html#se:nfcertify"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfcertify</a></code>.
You can use <code><a href="General_number_fields.html#se:polredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredbest</a></code> or <code>polredabs(,16)</code> to avoid this
factorization step; in both cases, the result is no longer canonical.</p>
<p>
<b>Warning 2.</b> Apart from the factorization of the discriminant of
T, this routine runs in polynomial time for a <em>fixed</em> degree.
But the complexity is exponential in the degree: this routine
may be exceedingly slow when the number field has many subfields, hence a
lot of elements of small T<sub>2</sub>-norm. If you do not need a canonical
polynomial, the function <code><a href="General_number_fields.html#se:polredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredbest</a></code> is in general much faster (it runs
in polynomial time), and tends to return polynomials with smaller
discriminants.</p>
<p>
The binary digits of <em>flag</em> mean</p>
<p>
1: outputs a two-component row vector [P,a], where P is the default
output and <code>Mod(a, P)</code> is a root of the original T.</p>
<p>
4: gives <em>all</em> polynomials of minimal T<sub>2</sub> norm; of the two polynomials
P(x) and &#177; P(-x), only one is given.</p>
<p>
16: Possibly use a suborder of the maximal order, <em>without</em> attempting to
certify the result as in Warning 1: we always return a polynomial and never
0. The result is a priori not canonical.</p>
<p></p>
<p>
</p><pre class="code">  ? T = x^16 - 136*x^14 + 6476*x^12 - 141912*x^10 + 1513334*x^8 \
        - 7453176*x^6 + 13950764*x^4 - 5596840*x^2 + 46225
  ? T1 = polredabs(T); T2 = polredbest(T);
  ? [ norml2(polroots(T1)), norml2(polroots(T2)) ]
  %3 = [88.0000000, 120.000000]
  ? [ sizedigit(poldisc(T1)), sizedigit(poldisc(T2)) ]
  %4 = [75, 67]
</pre><p></p>
<p></p>
<p>
The precise definition of the output of <code><a href="General_number_fields.html#se:polredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredabs</a></code> is as follows.</p>
<p>
<b>*</b> Consider the finite list of characteristic polynomials of primitive
elements of&nbsp;K that are in&nbsp;&Zopf;<sub>K</sub> and minimal for the&nbsp;T<sub>2</sub> norm;
now remove from the list the polynomials whose discriminant do not have
minimal absolute value. Note that this condition is restricted to the
original list of polynomials with minimal T<sub>2</sub> norm and does not imply that
the defining polynomial for the field with smallest discriminant belongs to
the list !</p>
<p>
<b>*</b> To a polynomial P(x) = x^n +...+ a<sub>n</sub>  &in;  &Ropf;[x] we attach
the sequence S(P) given by |a<sub>1</sub>|, a<sub>1</sub>,..., |a<sub>n</sub>|, a<sub>n</sub>.
Order the polynomials P by the lexicographic order on the coefficient
vectors S(P). Then the output of <code><a href="General_number_fields.html#se:polredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredabs</a></code> is the smallest
polynomial in the above list for that order. In other words, the monic
polynomial which is lexicographically smallest with respect to the absolute
values of coefficients, favouring negative coefficients to break ties, i.e.
choosing x^3-2 rather than x^3+2.</p>
<p>
The library syntax is <code>GEN <b>polredabs0</b>(GEN T, long flag)</code>.
Instead of the above hardcoded numerical flags, one should use an
or-ed combination of</p>
<p>
<b>*</b> <code>nf_PARTIALFACT</code>: possibly use a suborder of the maximal order,
<em>without</em> attempting to certify the result.</p>
<p>
<b>*</b> <code>nf_ORIG</code>: return [P, a], where <code>Mod(a, P)</code> is a root of T.</p>
<p>
<b>*</b> <code>nf_RAW</code>: return [P, b], where <code>Mod(b, T)</code> is a root of P.
The algebraic integer b is the raw result produced by the small vectors
enumeration in the maximal order; P was computed as the characteristic
polynomial of <code>Mod(b, T)</code>. <code>Mod(a, P)</code> as in <code>nf_ORIG</code>
is obtained with <code><a href="General_number_fields.html#se:modreverse"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">modreverse</a></code>.</p>
<p>
<b>*</b> <code>nf_ADDZK</code>: if r is the result produced with some of the above
flags (of the form P or [P,c]), return <code>[r,zk]</code>, where <code>zk</code> is a
&Zopf;-basis for the maximal order of &Qopf;[X]/(P).</p>
<p>
<b>*</b> <code>nf_ALL</code>: return a vector of results of the above form, for all
polynomials of minimal T<sub>2</sub>-norm.</p>
<p>

<hr>
<div id="se:polredbest"></div>
<div id="polredbest"></div>
<h4>polredbest(T, {<em>flag</em> = 0})</h4>
<p>
Finds a polynomial with reasonably
small coefficients defining the same number field as T.
All T accepted by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> are also allowed here (e.g. non-monic
polynomials, <code>nf</code>, <code>bnf</code>, <code>[T,Z_K_basis]</code>). Contrary to
<code><a href="General_number_fields.html#se:polredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredabs</a></code>, this routine runs in polynomial time, but it offers no
guarantee as to the minimality of its result.</p>
<p>
This routine computes an LLL-reduced basis for the ring of integers of
&Qopf;[X]/(T), then examines small linear combinations of the basis vectors,
computing their characteristic polynomials. It returns the <em>separable</em>
P polynomial of smallest discriminant (the one with lexicographically
smallest <code>abs(Vec(P))</code> in case of ties). This is a good candidate
for subsequent number field computations, since it guarantees that
the denominators of algebraic integers, when expressed in the power basis,
are reasonably small. With no claim of minimality, though.</p>
<p>
It can happen that iterating this functions yields better and better
polynomials, until it stabilizes:</p>
<p>
</p><pre class="code">  ? \p5
  ? P = X^12+8*X^8-50*X^6+16*X^4-3069*X^2+625;
  ? poldisc(P)*1.
  %2 = 1.2622 E55
  ? P = polredbest(P);
  ? poldisc(P)*1.
  %4 = 2.9012 E51
  ? P = polredbest(P);
  ? poldisc(P)*1.
  %6 = 8.8704 E44
</pre><p>
In this example, the initial polynomial P is the one
returned by <code><a href="General_number_fields.html#se:polredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredabs</a></code>, and the last one is stable.</p>
<p>
If <em>flag</em> = 1: outputs a two-component row vector [P,a],  where P is the
default output and <code>Mod(a, P)</code> is a root of the original T.</p>
<p>
</p><pre class="code">  ? [P,a] = polredbest(x^4 + 8, 1)
  %1 = [x^4 + 2, Mod(x^3, x^4 + 2)]
  ? charpoly(a)
  %2 = x^4 + 8
</pre><p>
In particular, the map &Qopf;[x]/(T)  &rightarrow;  &Qopf;[x]/(P),
x<code> &longmapsto; </code><code>Mod(a,P)</code> defines an isomorphism of number fields, which can
be computed as</p>
<p>
</p><pre class="code">    subst(lift(Q), 'x, a)
</pre><p>
if Q is a <code>t_POLMOD</code> modulo T; <code>b = modreverse(a)</code>
returns a <code>t_POLMOD</code> giving the inverse of the above map (which should be
useless since &Qopf;[x]/(P) is a priori a better representation for the number
field and its elements).</p>
<p>
The library syntax is <code>GEN <b>polredbest</b>(GEN T, long flag)</code>.</p>
<p>

<hr>
<div id="se:polredord"></div>
<div id="polredord"></div>
<h4>polredord(x)</h4>
<p>
This function is obsolete, use polredbest.</p>
<p>
The library syntax is <code>GEN <b>polredord</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:poltschirnhaus"></div>
<div id="poltschirnhaus"></div>
<h4>poltschirnhaus(x)</h4>
<p>
Applies a random Tschirnhausen
transformation to the polynomial x, which is assumed to be non-constant
and separable, so as to obtain a new equation for the &eacute;tale algebra
defined by x. This is for instance useful when computing resolvents,
hence is used by the <code><a href="General_number_fields.html#se:polgalois"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polgalois</a></code> function.</p>
<p>
The library syntax is <code>GEN <b>tschirnhaus</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfalgtobasis"></div>
<div id="rnfalgtobasis"></div>
<h4>rnfalgtobasis(<em>rnf</em>, x)</h4>
<p>
Expresses x on the relative
integral basis. Here, <em>rnf</em> is a relative number field extension L/K
as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code>, and x an element of L in absolute form, i.e.
expressed as a polynomial or polmod with polmod coefficients, <em>not</em> on
the relative integral basis.</p>
<p>
The library syntax is <code>GEN <b>rnfalgtobasis</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfbasis"></div>
<div id="rnfbasis"></div>
<h4>rnfbasis(<em>bnf</em>, M)</h4>
<p>
Let K the field represented by
<em>bnf</em>, as output by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>. M is a projective &Zopf;<sub>K</sub>-module
of rank n (M &bigotimes;  K is an n-dimensional K-vector space), given by a
pseudo-basis of size n. The routine returns either a true &Zopf;<sub>K</sub>-basis of
M (of size n) if it exists, or an n+1-element generating set of M if
not.</p>
<p>
It is allowed to use a monic irreducible polynomial P in K[X] instead of
M, in which case, M is defined as the ring of integers of K[X]/(P),
viewed as a &Zopf;<sub>K</sub>-module.</p>
<p>
The library syntax is <code>GEN <b>rnfbasis</b>(GEN bnf, GEN M)</code>.</p>
<p>

<hr>
<div id="se:rnfbasistoalg"></div>
<div id="rnfbasistoalg"></div>
<h4>rnfbasistoalg(<em>rnf</em>, x)</h4>
<p>
Computes the representation of x
as a polmod with polmods coefficients. Here, <em>rnf</em> is a relative number
field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code>, and x an element of
L expressed on the relative integral basis.</p>
<p>
The library syntax is <code>GEN <b>rnfbasistoalg</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfcharpoly"></div>
<div id="rnfcharpoly"></div>
<h4>rnfcharpoly(<em>nf</em>, T, a, {<em>var</em> = 'x})</h4>
<p>
Characteristic polynomial of
a over <em>nf</em>, where a belongs to the algebra defined by T over
<em>nf</em>, i.e.&nbsp;<em>nf</em>[X]/(T). Returns a polynomial in variable v
(x by default).</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2+1);
  ? rnfcharpoly(nf, x^2+y*x+1, x+y)
  %2 = x^2 + Mod(-y, y^2 + 1)*x + 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfcharpoly</b>(GEN nf, GEN T, GEN a, long var = -1)</code> where <code>var</code> is a variable number.</p>
<p>

<hr>
<div id="se:rnfconductor"></div>
<div id="rnfconductor"></div>
<h4>rnfconductor(<em>bnf</em>, T)</h4>
<p>
Given a <em>bnf</em> structure attached to a number field K, as produced
by <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, and T a monic irreducible polynomial in K[x]
defining an Abelian extension L = K[x]/(T), computes the class field
theory conductor of this Abelian extension. The result is a 3-component vector
[<em>conductor</em>,<em>bnr</em>,<em>subgroup</em>], where <em>conductor</em> is
the conductor of the extension given as a 2-component row vector
[f<sub>0</sub>,f_ oo ], <em>bnr</em> is the attached <code>bnr</code> structure
and <em>subgroup</em> is a matrix in HNF defining the subgroup of the ray class
group on the ray class group generators <code>bnr.gen</code>.</p>
<p>
<b>Huge discriminants, helping rnfdisc.</b> the format [T,B] is
also accepted instead of T and computes the conductor of the extension
provided it factors completely over prime divisors of rational primes p &lt; B,
see <code>??rnfinit</code>: the valuation of f<sub>0</sub> is then correct at all prime
ideals &pfr; above a rational prime p &lt; B but may be incorrect at other
primes.</p>
<p>
The library syntax is <code>GEN <b>rnfconductor</b>(GEN bnf, GEN T)</code>.</p>
<p>

<hr>
<div id="se:rnfdedekind"></div>
<div id="rnfdedekind"></div>
<h4>rnfdedekind(<em>nf</em>, <em>pol</em>, {<em>pr</em>}, {<em>flag</em> = 0})</h4>
<p>
Given a number field K coded by <em>nf</em> and a monic
polynomial P &in;  &Zopf;<sub>K</sub>[X], irreducible over K and thus defining a relative
extension L of K, applies Dedekind's criterion to the order
&Zopf;<sub>K</sub>[X]/(P), at the prime ideal <em>pr</em>. It is possible to set <em>pr</em>
to a vector of prime ideals (test maximality at all primes in the vector),
or to omit altogether, in which case maximality at <em>all</em> primes is tested;
in this situation <em>flag</em> is automatically set to 1.</p>
<p>
The default historic behavior (<em>flag</em> is 0 or omitted and <em>pr</em> is a
single prime ideal) is not so useful since
<code><a href="General_number_fields.html#se:rnfpseudobasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpseudobasis</a></code> gives more information and is generally not that
much slower. It returns a 3-component vector [<em>max</em>, <em>basis</em>, v]:</p>
<p>
<b>*</b> <em>basis</em> is a pseudo-basis of an enlarged order O produced by
Dedekind's criterion, containing the original order &Zopf;<sub>K</sub>[X]/(P)
with index a power of <em>pr</em>. Possibly equal to the original order.</p>
<p>
<b>*</b> <em>max</em> is a flag equal to 1 if the enlarged order O
could be proven to be <em>pr</em>-maximal and to 0 otherwise; it may still be
maximal in the latter case if <em>pr</em> is ramified in L,</p>
<p>
<b>*</b> v is the valuation at <em>pr</em> of the order discriminant.</p>
<p>
If <em>flag</em> is non-zero, on the other hand, we just return 1 if the order
&Zopf;<sub>K</sub>[X]/(P) is <em>pr</em>-maximal (resp.&nbsp;maximal at all relevant primes, as
described above), and 0 if not. This is much faster than the default,
since the enlarged order is not computed.</p>
<p>
</p><pre class="code">  ? nf = nfinit(y^2-3); P = x^3 - 2*y;
  ? pr3 = idealprimedec(nf,3)[1];
  ? rnfdedekind(nf, P, pr3)
  %3 = [1, [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, 1]], 8]
  ? rnfdedekind(nf, P, pr3, 1)
  %4 = 1
</pre><p>
In this example, <code>pr3</code> is the ramified ideal above 3,
and the order generated by the cube roots of y is already
<code>pr3</code>-maximal. The order-discriminant has valuation 8. On the other
hand, the order is not maximal at the prime above 2:</p>
<p>
</p><pre class="code">  ? pr2 = idealprimedec(nf,2)[1];
  ? rnfdedekind(nf, P, pr2, 1)
  %6 = 0
  ? rnfdedekind(nf, P, pr2)
  %7 = [0, [[2, 0, 0; 0, 1, 0; 0, 0, 1], [[1, 0; 0, 1], [1, 0; 0, 1],
       [1, 1/2; 0, 1/2]]], 2]
</pre><p></p>
<p>
The enlarged order is not proven to be <code>pr2</code>-maximal yet. In fact, it
is; it is in fact the maximal order:</p>
<p>
</p><pre class="code">  ? B = rnfpseudobasis(nf, P)
  %8 = [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, [1, 1/2; 0, 1/2]],
       [162, 0; 0, 162], -1]
  ? idealval(nf,B[3], pr2)
  %9 = 2
</pre><p></p>
<p>
It is possible to use this routine with non-monic
P = &sum;<sub>i &leq; n</sub> a<sub>i</sub> X^i  &in;  &Zopf;<sub>K</sub>[X] if <em>flag</em> = 1;
in this case, we test maximality of Dedekind's order generated by
1, a<sub>n</sub> &alpha;, a<sub>n</sub>&alpha;^2 + a<sub>n-1</sub>&alpha;,...,
a<sub>n</sub>&alpha;<sup>n-1</sup> + a<sub>n-1</sub>&alpha;<sup>n-2</sup> +...+ a<sub>1</sub>&alpha;.
The routine will fail if P is 0 on the projective line over the residue
field &Zopf;<sub>K</sub>/<code>pr</code> (FIXME).</p>
<p>
The library syntax is <code>GEN <b>rnfdedekind</b>(GEN nf, GEN pol, GEN pr = NULL, long flag)</code>.</p>
<p>

<hr>
<div id="se:rnfdet"></div>
<div id="rnfdet"></div>
<h4>rnfdet(<em>nf</em>, M)</h4>
<p>
Given a pseudo-matrix M over the maximal
order of <em>nf</em>, computes its determinant.</p>
<p>
The library syntax is <code>GEN <b>rnfdet</b>(GEN nf, GEN M)</code>.</p>
<p>

<hr>
<div id="se:rnfdisc"></div>
<div id="rnfdisc"></div>
<h4>rnfdisc(<em>nf</em>, T)</h4>
<p>
Given an <em>nf</em> structure attached to a number field K, as output
by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, and a monic irreducible polynomial T &in;  K[x] defining a
relative extension L = K[x]/(T), compute the relative discriminant of L.
This is a vector [D,d], where D is the relative ideal discriminant and
d is the relative discriminant considered as an element of K<sup>*</sup>/{K<sup>*</sup>}^2.
The main variable of <em>nf</em> <em>must</em> be of lower priority than that of
T, see Section se:priority.</p>
<p>
<b>Huge discriminants, helping rnfdisc.</b> the format [T,B] is
also accepted instead of T and computes an order which is maximal at all
p &lt; B, see <code>??rnfinit</code>: the valuation of D is then correct at all
prime ideals &pfr; above a rational prime p &lt; B but may be incorrect
at other primes.</p>
<p>
The library syntax is <code>GEN <b>rnfdiscf</b>(GEN nf, GEN T)</code>.</p>
<p>

<hr>
<div id="se:rnfeltabstorel"></div>
<div id="rnfeltabstorel"></div>
<h4>rnfeltabstorel(<em>rnf</em>, x)</h4>
<p>
Let <em>rnf</em> be a relative
number field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and let x be an
element of L expressed as a polynomial modulo the absolute equation
<code><em>rnf</em>.pol</code>, or in terms of the absolute &Zopf;-basis for &Zopf;<sub>L</sub>
if <em>rnf</em> contains one (as in <code>rnfinit(nf,pol,1)</code>, or after
a call to <code>nfinit(rnf)</code>).
Computes x as an element of the relative extension
L/K as a polmod with polmod coefficients.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.polabs
  %2 = x^4 + 1
  ? rnfeltabstorel(L, Mod(x, L.polabs))
  %3 = Mod(x, x^2 + Mod(-y, y^2 + 1))
  ? rnfeltabstorel(L, 1/3)
  %4 = 1/3
  ? rnfeltabstorel(L, Mod(x, x^2-y))
  %5 = Mod(x, x^2 + Mod(-y, y^2 + 1))
  
  ? rnfeltabstorel(L, [0,0,0,1]~) \\ Z<sub>L</sub> not initialized yet
   ***   at top-level: rnfeltabstorel(L,[0,
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
   *** rnfeltabstorel: incorrect type in rnfeltabstorel, apply nfinit(rnf).
  ? nfinit(L); \\ initialize now
  ? rnfeltabstorel(L, [0,0,0,1]~)
  %6 = Mod(Mod(y, y^2 + 1)*x, x^2 + Mod(-y, y^2 + 1))
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltabstorel</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfeltdown"></div>
<div id="rnfeltdown"></div>
<h4>rnfeltdown(<em>rnf</em>, x, {<em>flag</em> = 0})</h4>
<p>
<em>rnf</em> being a relative number
field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x being an element of
L expressed as a polynomial or polmod with polmod coefficients (or as a
<code>t_COL</code> on <code>nfinit(rnf).zk</code>), computes
x as an element of K as a <code>t_POLMOD</code> if <em>flag</em> = 0 and as a <code>t_COL</code>
otherwise. If x is not in K, a domain error occurs.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.pol
  %2 = x^4 + 1
  ? rnfeltdown(L, Mod(x^2, L.pol))
  %3 = Mod(y, y^2 + 1)
  ? rnfeltdown(L, Mod(x^2, L.pol), 1)
  %4 = [0, 1]~
  ? rnfeltdown(L, Mod(y, x^2-y))
  %5 = Mod(y, y^2 + 1)
  ? rnfeltdown(L, Mod(y,K.pol))
  %6 = Mod(y, y^2 + 1)
  ? rnfeltdown(L, Mod(x, L.pol))
   ***   at top-level: rnfeltdown(L,Mod(x,x
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
   *** rnfeltdown: domain error in rnfeltdown: element not in the base field
  ? rnfeltdown(L, Mod(y, x^2-y), 1) \\ as a t_COL
  %7 = [0, 1]~
  ? rnfeltdown(L, [0,1,0,0]~) \\ not allowed without absolute nf struct
    *** rnfeltdown: incorrect type in rnfeltdown (t_COL).
  ? nfinit(L); \\ add absolute nf structure to L
  ? rnfeltdown(L, [0,1,0,0]~) \\ now OK
  %8 = Mod(y, y^2 + 1)
</pre><p>
If we had started with
<code>L = rnfinit(K, x^2-y, 1)</code>, then the final would have worked directly.</p>
<p>
The library syntax is <code>GEN <b>rnfeltdown0</b>(GEN rnf, GEN x, long flag)</code>.
Also available is
<code>GEN <b>rnfeltdown</b>(GEN rnf, GEN x)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:rnfeltnorm"></div>
<div id="rnfeltnorm"></div>
<h4>rnfeltnorm(<em>rnf</em>, x)</h4>
<p>
<em>rnf</em> being a relative number field extension L/K as output by
<code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x being an element of L, returns the relative norm
N<sub>L/K</sub>(x) as an element of K.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? rnfeltnorm(L, Mod(x, L.pol))
  %2 = Mod(x, x^2 + Mod(-y, y^2 + 1))
  ? rnfeltnorm(L, 2)
  %3 = 4
  ? rnfeltnorm(L, Mod(x, x^2-y))
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltnorm</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfeltreltoabs"></div>
<div id="rnfeltreltoabs"></div>
<h4>rnfeltreltoabs(<em>rnf</em>, x)</h4>
<p>
<em>rnf</em> being a relative
number field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x being an
element of L expressed as a polynomial or polmod with polmod
coefficients, computes x as an element of the absolute extension L/&Qopf; as
a polynomial modulo the absolute equation <code><em>rnf</em>.pol</code>.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.pol
  %2 = x^4 + 1
  ? rnfeltreltoabs(L, Mod(x, L.pol))
  %3 = Mod(x, x^4 + 1)
  ? rnfeltreltoabs(L, Mod(y, x^2-y))
  %4 = Mod(x^2, x^4 + 1)
  ? rnfeltreltoabs(L, Mod(y,K.pol))
  %5 = Mod(x^2, x^4 + 1)
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltreltoabs</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfelttrace"></div>
<div id="rnfelttrace"></div>
<h4>rnfelttrace(<em>rnf</em>, x)</h4>
<p>
<em>rnf</em> being a relative number field extension L/K as output by
<code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x being an element of L, returns the relative trace
Tr<sub>L/K</sub>(x) as an element of K.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? rnfelttrace(L, Mod(x, L.pol))
  %2 = 0
  ? rnfelttrace(L, 2)
  %3 = 4
  ? rnfelttrace(L, Mod(x, x^2-y))
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfelttrace</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfeltup"></div>
<div id="rnfeltup"></div>
<h4>rnfeltup(<em>rnf</em>, x, {<em>flag</em> = 0})</h4>
<p>
<em>rnf</em> being a relative number field extension L/K as output by
<code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x being an element of K, computes x as an element of
the absolute extension L/&Qopf;. As a <code>t_POLMOD</code> modulo <code><em>rnf</em>.pol</code>
if <em>flag</em> = 0 and as a <code>t_COL</code> on the absolute field integer basis if
<em>flag</em> = 1.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.pol
  %2 = x^4 + 1
  ? rnfeltup(L, Mod(y, K.pol))
  %3 = Mod(x^2, x^4 + 1)
  ? rnfeltup(L, y)
  %4 = Mod(x^2, x^4 + 1)
  ? rnfeltup(L, [1,2]~) \\ in terms of K.zk
  %5 = Mod(2*x^2 + 1, x^4 + 1)
  ? rnfeltup(L, y, 1) \\ in terms of nfinit(L).zk
  %6 = [0, 1, 0, 0]~
  ? rnfeltup(L, [1,2]~, 1)
  %7 = [1, 2, 0, 0]~
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltup0</b>(GEN rnf, GEN x, long flag)</code>.</p>
<p>

<hr>
<div id="se:rnfequation"></div>
<div id="rnfequation"></div>
<h4>rnfequation(<em>nf</em>, <em>pol</em>, {<em>flag</em> = 0})</h4>
<p>
Given a number field
<em>nf</em> as output by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> (or simply a polynomial) and a
polynomial <em>pol</em> with coefficients in <em>nf</em> defining a relative
extension L of <em>nf</em>, computes an absolute equation of L over
&Qopf;.</p>
<p>
The main variable of <em>nf</em> <em>must</em> be of lower priority than that
of <em>pol</em> (see Section se:priority). Note that for efficiency, this does
not check whether the relative equation is irreducible over <em>nf</em>, but
only if it is squarefree. If it is reducible but squarefree, the result will
be the absolute equation of the &eacute;tale algebra defined by <em>pol</em>. If
<em>pol</em> is not squarefree, raise an <code>e_DOMAIN</code> exception.</p>
<p>
</p><pre class="code">  ? rnfequation(y^2+1, x^2 - y)
  %1 = x^4 + 1
  ? T = y^3-2; rnfequation(nfinit(T), (x^3-2)/(x-Mod(y,T)))
  %2 = x^6 + 108  \\ Galois closure of Q(2^(1/3))
</pre><p></p>
<p></p>
<p>
If <em>flag</em> is non-zero, outputs a 3-component row vector [z,a,k], where</p>
<p>
<b>*</b> z is the absolute equation of L over &Qopf;, as in the default
behavior,</p>
<p>
<b>*</b> a expresses as a <code>t_POLMOD</code> modulo z a root &alpha; of the
polynomial defining the base field <em>nf</em>,</p>
<p>
<b>*</b> k is a small integer such that &theta; = &beta;+k&alpha;
is a root of z, where &beta; is a root of <em>pol</em>. It is guaranteed
that k = 0 whenever &Qopf;(&beta;) = L.</p>
<p>
</p><pre class="code">  ? T = y^3-2; pol = x^2 +x*y + y^2;
  ? [z,a,k] = rnfequation(T, pol, 1);
  ? z
  %3 = x^6 + 108
  ? subst(T, y, a)
  %4 = 0
  ? alpha= Mod(y, T);
  ? beta = Mod(x*Mod(1,T), pol);
  ? subst(z, x, beta + k*alpha)
  %7 = 0
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfequation0</b>(GEN nf, GEN pol, long flag)</code>.
Also available are
<code>GEN <b>rnfequation</b>(GEN nf, GEN pol)</code> (<em>flag</em> = 0) and
<code>GEN <b>rnfequation2</b>(GEN nf, GEN pol)</code> (<em>flag</em> = 1).</p>
<p>

<hr>
<div id="se:rnfhnfbasis"></div>
<div id="rnfhnfbasis"></div>
<h4>rnfhnfbasis(<em>bnf</em>, x)</h4>
<p>
Given <em>bnf</em> as output by
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, and either a polynomial x with coefficients in <em>bnf</em>
defining a relative extension L of <em>bnf</em>, or a pseudo-basis x of
such an extension, gives either a true <em>bnf</em>-basis of L in upper
triangular Hermite normal form, if it exists, and returns 0 otherwise.</p>
<p>
The library syntax is <code>GEN <b>rnfhnfbasis</b>(GEN bnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealabstorel"></div>
<div id="rnfidealabstorel"></div>
<h4>rnfidealabstorel(<em>rnf</em>, x)</h4>
<p>
Let <em>rnf</em> be a relative
number field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x be an ideal of
the absolute extension L/&Qopf; given by a &Zopf;-basis of elements of L.
Returns the relative pseudo-matrix in HNF giving the ideal x considered as
an ideal of the relative extension L/K, i.e.&nbsp;as a &Zopf;<sub>K</sub>-module.</p>
<p>
The reason why the input does not use the customary HNF in terms of a fixed
&Zopf;-basis for &Zopf;<sub>L</sub> is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <code>nf</code>
structure <code>Labs</code> attached to L, and m is in HNF, defining
an (absolute) ideal with respect to the &Zopf;-basis <code>Labs.zk</code>, then
<code>Labs.zk * m</code> is a suitable &Zopf;-basis for the ideal, and</p>
<p>
</p><pre class="code">    rnfidealabstorel(rnf, Labs.zk * m)
</pre><p>
converts m to a relative ideal.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y); Labs = nfinit(L);
  ? m = idealhnf(Labs, 17, x^3+2);
  ? B = rnfidealabstorel(L, Labs.zk * m)
  %3 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]]  \\ pseudo-basis for m as Z<sub>K</sub>-module
  ? A = rnfidealreltoabs(L, B)
  %4 = [17, x^2 + 4, x + 8, x^3 + 8*x^2]   \\ Z-basis for m in Q[x]/(L.pol)
  ? mathnf(matalgtobasis(Labs, A))
  %5 =
  [17 8 4 2]
  
  [ 0 1 0 0]
  
  [ 0 0 1 0]
  
  [ 0 0 0 1]
  ? % == m
  %6 = 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfidealabstorel</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealdown"></div>
<div id="rnfidealdown"></div>
<h4>rnfidealdown(<em>rnf</em>, x)</h4>
<p>
Let <em>rnf</em> be a relative number
field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code>, and x an ideal of
L, given either in relative form or by a &Zopf;-basis of elements of L
(see Section <a href="General_number_fields.html#se:rnfidealabstorel"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:rnfidealabstorel</a>). This function returns the ideal of K
below x, i.e.&nbsp;the intersection of x with K.</p>
<p>
The library syntax is <code>GEN <b>rnfidealdown</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealfactor"></div>
<div id="rnfidealfactor"></div>
<h4>rnfidealfactor(<em>rnf</em>, x)</h4>
<p>
Factor into prime ideal powers the
ideal x in the attached absolute number field L = <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>(<em>rnf</em>).
The output format is similar to the <code><a href="Arithmetic_functions.html#se:factor"
    onClick="parent.itemFrame.location='cont_Arithmetic_functions.html'">factor</a></code> function, and the prime
ideals are represented in the form output by the <code><a href="General_number_fields.html#se:idealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealprimedec</a></code>
function for L.</p>
<p>
</p><pre class="code">  ? rnf = rnfinit(nfinit(y^2+1), x^2-y+1);
  ? rnfidealfactor(rnf, y+1)  \\ P<sub>2</sub>^2
  %2 =
  [[2, [0,0,1,0]~, 4, 1, [0,0,0,2;0,0,-2,0;-1,-1,0,0;1,-1,0,0]] 2]
  
  ? rnfidealfactor(rnf, x) \\ P<sub>2</sub>
  %3 =
  [[2, [0,0,1,0]~, 4, 1, [0,0,0,2;0,0,-2,0;-1,-1,0,0;1,-1,0,0]] 1]
  
  ? L = nfinit(rnf);
  ? id = idealhnf(L, idealhnf(L, 25, (x+1)^2));
  ? idealfactor(L, id) == rnfidealfactor(rnf, id)
  %6 = 1
</pre><p>
Note that ideals of the base field K must be explicitly
lifted to L via <code><a href="General_number_fields.html#se:rnfidealup"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfidealup</a></code> before they can be factored.</p>
<p>
The library syntax is <code>GEN <b>rnfidealfactor</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealhnf"></div>
<div id="rnfidealhnf"></div>
<h4>rnfidealhnf(<em>rnf</em>, x)</h4>
<p>
<em>rnf</em> being a relative number
field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x being a relative
ideal (which can be, as in the absolute case, of many different types,
including of course elements), computes the HNF pseudo-matrix attached to
x, viewed as a &Zopf;<sub>K</sub>-module.</p>
<p>
The library syntax is <code>GEN <b>rnfidealhnf</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealmul"></div>
<div id="rnfidealmul"></div>
<h4>rnfidealmul(<em>rnf</em>, x, y)</h4>
<p>
<em>rnf</em> being a relative number
field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x and y being ideals
of the relative extension L/K given by pseudo-matrices, outputs the ideal
product, again as a relative ideal.</p>
<p>
The library syntax is <code>GEN <b>rnfidealmul</b>(GEN rnf, GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:rnfidealnormabs"></div>
<div id="rnfidealnormabs"></div>
<h4>rnfidealnormabs(<em>rnf</em>, x)</h4>
<p>
Let <em>rnf</em> be a relative
number field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and let x be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the norm of the
x considered as an ideal of the absolute extension L/&Qopf;. This is
identical to</p>
<p>
</p><pre class="code">     idealnorm(rnf, rnfidealnormrel(rnf,x))
</pre><p>
but faster.</p>
<p>
The library syntax is <code>GEN <b>rnfidealnormabs</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealnormrel"></div>
<div id="rnfidealnormrel"></div>
<h4>rnfidealnormrel(<em>rnf</em>, x)</h4>
<p>
Let <em>rnf</em> be a relative
number field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and let x be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the relative
norm of x as an ideal of K in HNF.</p>
<p>
The library syntax is <code>GEN <b>rnfidealnormrel</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealprimedec"></div>
<div id="rnfidealprimedec"></div>
<h4>rnfidealprimedec(<em>rnf</em>, <em>pr</em>)</h4>
<p>
Let <em>rnf</em> be a relative number
field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code>, and <em>pr</em> a maximal
ideal of K (<em>prid</em>), this function completes the <em>rnf</em>
with a <em>nf</em> structure attached to L (see Section <a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:rnfinit</a>)
and returns the prime ideal decomposition of <em>pr</em> in L/K.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); rnf = rnfinit(K, x^3+y+1);
  ? P = idealprimedec(K, 2)[1];
  ? S = rnfidealprimedec(rnf, P);
  ? #S
  %4 = 1
</pre><p></p>
<p>
The argument <em>pr</em> is also allowed to be a prime number p, in which
case the function returns a pair of vectors <code>[SK,SL]</code>, where <code>SK</code> contains
the primes of K above p and <code>SL</code>[i] is the vector of primes of L
above <code>SK</code>[i].</p>
<p>
</p><pre class="code">  ? [SK,SL] = rnfidealprimedec(rnf, 5);
  ? [#SK, vector(#SL,i,#SL[i])]
  %6 = [2, [2, 2]]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfidealprimedec</b>(GEN rnf, GEN pr)</code>.</p>
<p>

<hr>
<div id="se:rnfidealreltoabs"></div>
<div id="rnfidealreltoabs"></div>
<h4>rnfidealreltoabs(<em>rnf</em>, x, {<em>flag</em> = 0})</h4>
<p>
Let <em>rnf</em> be a relative
number field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and let x be a
relative ideal, given as a &Zopf;<sub>K</sub>-module by a pseudo matrix [A,I].
This function returns the ideal x as an absolute ideal of L/&Qopf;.
If <em>flag</em> = 0, the result is given by a vector of <code>t_POLMOD</code>s modulo
<code>rnf.pol</code> forming a &Zopf;-basis; if <em>flag</em> = 1, it is given in HNF in terms
of the fixed &Zopf;-basis for &Zopf;<sub>L</sub>, see Section <a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:rnfinit</a>.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y);
  ? P = idealprimedec(K,2)[1];
  ? P = rnfidealup(rnf, P)
  %3 = [2, x^2 + 1, 2*x, x^3 + x]
  ? Prel = rnfidealhnf(rnf, P)
  %4 = [[1, 0; 0, 1], [[2, 1; 0, 1], [2, 1; 0, 1]]]
  ? rnfidealreltoabs(rnf,Prel)
  %5 = [2, x^2 + 1, 2*x, x^3 + x]
  ? rnfidealreltoabs(rnf,Prel,1)
  %6 =
  [2 1 0 0]
  
  [0 1 0 0]
  
  [0 0 2 1]
  
  [0 0 0 1]
</pre><p></p>
<p>
The reason why we do not return by default (<em>flag</em> = 0) the customary HNF in
terms of a fixed &Zopf;-basis for &Zopf;<sub>L</sub> is precisely because
a <em>rnf</em> does not contain such a basis by default. Completing the
structure so that it contains a <em>nf</em> structure for L is polynomial
time but costly when the absolute degree is large, thus it is not done by
default. Note that setting <em>flag</em> = 1 will complete the <em>rnf</em>.</p>
<p>
The library syntax is <code>GEN <b>rnfidealreltoabs0</b>(GEN rnf, GEN x, long flag)</code>.
Also available is
<code>GEN <b>rnfidealreltoabs</b>(GEN rnf, GEN x)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:rnfidealtwoelt"></div>
<div id="rnfidealtwoelt"></div>
<h4>rnfidealtwoelt(<em>rnf</em>, x)</h4>
<p>
<em>rnf</em> being a relative
number field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and x being an
ideal of the relative extension L/K given by a pseudo-matrix, gives a
vector of two generators of x over &Zopf;<sub>L</sub> expressed as polmods with polmod
coefficients.</p>
<p>
The library syntax is <code>GEN <b>rnfidealtwoelement</b>(GEN rnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfidealup"></div>
<div id="rnfidealup"></div>
<h4>rnfidealup(<em>rnf</em>, x, {<em>flag</em> = 0})</h4>
<p>
Let <em>rnf</em> be a relative number
field extension L/K as output by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> and let x be an ideal of
K. This function returns the ideal x&Zopf;<sub>L</sub> as an absolute ideal of L/&Qopf;,
in the form of a &Zopf;-basis. If <em>flag</em> = 0, the result is given by a vector of
polynomials (modulo <code>rnf.pol</code>); if <em>flag</em> = 1, it is given in HNF in terms
of the fixed &Zopf;-basis for &Zopf;<sub>L</sub>, see Section <a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:rnfinit</a>.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y);
  ? P = idealprimedec(K,2)[1];
  ? rnfidealup(rnf, P)
  %3 = [2, x^2 + 1, 2*x, x^3 + x]
  ? rnfidealup(rnf, P,1)
  %4 =
  [2 1 0 0]
  
  [0 1 0 0]
  
  [0 0 2 1]
  
  [0 0 0 1]
</pre><p></p>
<p>
The reason why we do not return by default (<em>flag</em> = 0) the customary HNF in
terms of a fixed &Zopf;-basis for &Zopf;<sub>L</sub> is precisely because
a <em>rnf</em> does not contain such a basis by default. Completing the
structure so that it contains a <em>nf</em> structure for L is polynomial
time but costly when the absolute degree is large, thus it is not done by
default. Note that setting <em>flag</em> = 1 will complete the <em>rnf</em>.</p>
<p>
The library syntax is <code>GEN <b>rnfidealup0</b>(GEN rnf, GEN x, long flag)</code>.
Also available is
 <code>GEN <b>rnfidealup</b>(GEN rnf, GEN x)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:rnfinit"></div>
<div id="rnfinit"></div>
<h4>rnfinit(<em>nf</em>, T, {<em>flag</em> = 0})</h4>
<p>
Given an <em>nf</em> structure attached to a number field K, as output by
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, and a monic irreducible polynomial T in K[x] defining a
relative extension L = K[x]/(T), this computes data to work in L/K
The main variable of T must be of higher priority
(see Section se:priority) than that of <em>nf</em>, and the coefficients of
T must be in K.</p>
<p>
The result is a row vector, whose components are technical.
We let m = [K:&Qopf;] the degree of the base field, n = [L:K] the relative
degree, r<sub>1</sub> and r<sub>2</sub> the number of real and complex places of K. Access
to this information via <em>member functions</em> is preferred since the
specific data organization specified below will change in the future.</p>
<p>
If <em>flag</em> = 1, add an <em>nf</em> structure attached to L to <em>rnf</em>.
This is likely to be very expensive if the absolute degree mn is large,
but fixes an integer basis for &Zopf;<sub>L</sub> as a &Zopf;-module and allows to input
and output elements of L in absolute form: as <code>t_COL</code> for elements,
as <code>t_MAT</code> in HNF for ideals, as <code>prid</code> for prime ideals. Without such
a call, elements of L are represented as <code>t_POLMOD</code>, etc.
Note that a subsequent <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>(<em>rnf</em>) will also explicitly
add such a component, and so will the following functions <code><a href="General_number_fields.html#se:rnfidealmul"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfidealmul</a></code>,
<code><a href="General_number_fields.html#se:rnfidealtwoelt"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfidealtwoelt</a></code>, <code><a href="General_number_fields.html#se:rnfidealprimedec"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfidealprimedec</a></code>, <code><a href="General_number_fields.html#se:rnfidealup"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfidealup</a></code> (with flag 1)
and <code><a href="General_number_fields.html#se:rnfidealreltoabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfidealreltoabs</a></code> (with flag 1). The absolute <em>nf</em> structure
attached to L can be recovered using <code>nfinit(rnf)</code>.</p>
<p>
<em>rnf</em>[1](<code>rnf.pol</code>) contains the relative polynomial T.</p>
<p>
<em>rnf</em>[2] contains the integer basis [A,d] of K, as
(integral) elements of L/&Qopf;. More precisely, A is a vector of
polynomial with integer coefficients, d is a denominator, and the integer
basis is given by A/d.</p>
<p>
<em>rnf</em>[3] (<code>rnf.disc</code>) is a two-component row vector
[&dfr;(L/K),s] where &dfr;(L/K) is the relative ideal discriminant
of L/K and s is the discriminant of L/K viewed as an element of
K<sup>*</sup>/(K<sup>*</sup>)^2, in other words it is the output of <code><a href="General_number_fields.html#se:rnfdisc"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfdisc</a></code>.</p>
<p>
<em>rnf</em>[4](<code>rnf.index</code>) is the ideal index &ffr;, i.e.&nbsp;such
that d(T)&Zopf;<sub>K</sub> = &ffr;^2&dfr;(L/K).</p>
<p>
<em>rnf</em>[5] is currently unused.</p>
<p>
<em>rnf</em>[6] is currently unused.</p>
<p>
<em>rnf</em>[7] (<code>rnf.zk</code>) is the pseudo-basis (A,I) for the maximal
order &Zopf;<sub>L</sub> as a &Zopf;<sub>K</sub>-module: A is the relative integral pseudo basis
expressed as polynomials (in the variable of T) with polmod coefficients
in <em>nf</em>, and the second component I is the ideal list of the
pseudobasis in HNF.</p>
<p>
<em>rnf</em>[8] is the inverse matrix of the integral basis matrix, with
coefficients polmods in <em>nf</em>.</p>
<p>
<em>rnf</em>[9] is currently unused.</p>
<p>
<em>rnf</em>[10] (<code>rnf.nf</code>) is <em>nf</em>.</p>
<p>
<em>rnf</em>[11] is an extension of <code>rnfequation(K, T, 1)</code>. Namely, a
vector [P, a, k, <code>K.pol</code>, T] describing the <em>absolute</em>
extension L/&Qopf;: P is an absolute equation, more conveniently obtained
as <code>rnf.polabs</code>; a expresses the generator &alpha; = y mod <code>K.pol</code>
of the number field K as an element of L, i.e.&nbsp;a polynomial modulo the
absolute equation P;</p>
<p>
k is a small integer such that, if &beta; is an abstract root of T
and &alpha; the generator of K given above, then P(&beta; + k&alpha;) = 0.
It is guaranteed that k = 0 if &Qopf;(&beta;) = L.</p>
<p>
<b>Caveat.</b> Be careful if k != 0 when dealing simultaneously with
absolute and relative quantities since L = &Qopf;(&beta; + k&alpha;) = 
K(&alpha;), and the generator chosen for the absolute extension is not the
same as for the relative one. If this happens, one can of course go on
working, but we advise to change the relative polynomial so that its root
becomes &beta; + k &alpha;. Typical GP instructions would be</p>
<p>
</p><pre class="code">    [P,a,k] = rnfequation(K, T, 1);
    if (k, T = subst(T, x, x - k*Mod(y, K.pol)));
    L = rnfinit(K, T);
</pre><p></p>
<p></p>
<p>
<em>rnf</em>[12] is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available (which
is rarely needed, hence would be too expensive to compute during the initial
<code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> call).</p>
<p>
<b>Huge discriminants, helping rnfdisc.</b> When T has a
discriminant which is difficult to factor, it is hard to compute
&Zopf;<sub>L</sub>. As in <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, the special input format [T,B]
is also accepted, where T is a polynomial as above and B is
an integer. Instead of &Zopf;<sub>L</sub>, this produces an order which is maximal
at all primes less than B. The result is actually a complete and correct
<em>rnf</em> structure if all prime divisors of the relative ideal
discriminant divide a rational prime less than B. In general, the order
may not be maximal at primes &pfr; | p  for p &geq; B such that
&pfr;^2 divides the relative ideal discriminant.</p>
<p>
The library syntax is <code>GEN <b>rnfinit0</b>(GEN nf, GEN T, long flag)</code>.
Also available is
<code>GEN <b>rnfinit</b>(GEN nf,GEN T)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:rnfisabelian"></div>
<div id="rnfisabelian"></div>
<h4>rnfisabelian(<em>nf</em>, T)</h4>
<p>
T being a relative polynomial with coefficients
in <em>nf</em>, return 1 if it defines an abelian extension, and 0 otherwise.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2 + 23);
  ? rnfisabelian(K, x^3 - 3*x - y)
  %2 = 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>rnfisabelian</b>(GEN nf, GEN T)</code>.</p>
<p>

<hr>
<div id="se:rnfisfree"></div>
<div id="rnfisfree"></div>
<h4>rnfisfree(<em>bnf</em>, x)</h4>
<p>
Given <em>bnf</em> as output by
<code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code>, and either a polynomial x with coefficients in <em>bnf</em>
defining a relative extension L of <em>bnf</em>, or a pseudo-basis x of
such an extension, returns true (1) if L/<em>bnf</em> is free, false (0) if
not.</p>
<p>
The library syntax is <code>long <b>rnfisfree</b>(GEN bnf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:rnfislocalcyclo"></div>
<div id="rnfislocalcyclo"></div>
<h4>rnfislocalcyclo(<em>rnf</em>)</h4>
<p>
Let <em>rnf</em> be a relative number field extension L/K as output
by <code><a href="General_number_fields.html#se:rnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfinit</a></code> whose degree [L:K] is a power of a prime &ell;.
Return 1 if the &ell;-extension is locally cyclotomic (locally contained in
the cyclotomic &Zopf;_&ell;-extension of K<sub>v</sub> at all places v | &ell;), and
0 if not.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2 + y + 1);
  ? L = rnfinit(K, x^3 - y); /* = K(zeta<sub>9</sub>), globally cyclotomic */
  ? rnfislocalcyclo(L)
  %3 = 1
  \\ we expect 3-adic continuity by Krasner's lemma
  ? vector(5, i, rnfislocalcyclo(rnfinit(K, x^3 - y + 3^i)))
  %5 = [0, 1, 1, 1, 1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>rnfislocalcyclo</b>(GEN rnf)</code>.</p>
<p>

<hr>
<div id="se:rnfisnorm"></div>
<div id="rnfisnorm"></div>
<h4>rnfisnorm(T, a, {<em>flag</em> = 0})</h4>
<p>
Similar to
<code><a href="General_number_fields.html#se:bnfisnorm"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfisnorm</a></code> but in the relative case. T is as output by
<code><a href="General_number_fields.html#se:rnfisnorminit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfisnorminit</a></code> applied to the extension L/K. This tries to decide
whether the element a in K is the norm of some x in the extension
L/K.</p>
<p>
The output is a vector [x,q], where a = Norm(x)*q. The
algorithm looks for a solution x which is an S-integer, with S a list
of places of K containing at least the ramified primes, the generators of
the class group of L, as well as those primes dividing a. If L/K is
Galois, then this is enough; otherwise, <em>flag</em> is used to add more primes to
S: all the places above the primes p &leq; <em>flag</em> (resp.&nbsp;p|<em>flag</em>) if <em>flag</em> &gt; 0
(resp.&nbsp;<em>flag</em> &lt; 0).</p>
<p>
The answer is guaranteed (i.e.&nbsp;a is a norm iff q = 1) if the field is
Galois, or, under GRH, if S contains all primes less than
12log^2|disc(M)|, where M is the normal
closure of L/K.</p>
<p>
If <code><a href="General_number_fields.html#se:rnfisnorminit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfisnorminit</a></code> has determined (or was told) that L/K is
Galois, and <em>flag</em> != 0, a Warning is issued (so that you can set
<em>flag</em> = 1 to check whether L/K is known to be Galois, according to T).
Example:</p>
<p></p>
<p>
</p><pre class="code">  bnf = bnfinit(y^3 + y^2 - 2*y - 1);
  p = x^2 + Mod(y^2 + 2*y + 1, bnf.pol);
  T = rnfisnorminit(bnf, p);
  rnfisnorm(T, 17)
</pre><p></p>
<p>
checks whether 17 is a norm in the Galois extension &Qopf;(&beta;) /
&Qopf;(&alpha;), where &alpha;^3 + &alpha;^2 - 2&alpha; - 1 = 0 and &beta;^2 +
&alpha;^2 + 2&alpha; + 1 = 0 (it is).</p>
<p>
The library syntax is <code>GEN <b>rnfisnorm</b>(GEN T, GEN a, long flag)</code>.</p>
<p>

<hr>
<div id="se:rnfisnorminit"></div>
<div id="rnfisnorminit"></div>
<h4>rnfisnorminit(<em>pol</em>, <em>polrel</em>, {<em>flag</em> = 2})</h4>
<p>
Let K be defined by a root of <em>pol</em>, and L/K the extension defined
by the polynomial <em>polrel</em>. As usual, <em>pol</em> can in fact be an <em>nf</em>,
or <em>bnf</em>, etc; if <em>pol</em> has degree 1 (the base field is &Qopf;),
polrel is also allowed to be an <em>nf</em>, etc. Computes technical data needed
by <code><a href="General_number_fields.html#se:rnfisnorm"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfisnorm</a></code> to solve norm equations Nx = a, for x in L, and a
in K.</p>
<p>
If <em>flag</em> = 0, do not care whether L/K is Galois or not.</p>
<p>
If <em>flag</em> = 1, L/K is assumed to be Galois (unchecked), which speeds up
<code><a href="General_number_fields.html#se:rnfisnorm"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfisnorm</a></code>.</p>
<p>
If <em>flag</em> = 2, let the routine determine whether L/K is Galois.</p>
<p>
The library syntax is <code>GEN <b>rnfisnorminit</b>(GEN pol, GEN polrel, long flag)</code>.</p>
<p>

<hr>
<div id="se:rnfkummer"></div>
<div id="rnfkummer"></div>
<h4>rnfkummer(<em>bnr</em>, {<em>subgp</em>}, {d = 0})</h4>
<p>
<em>bnr</em>
being as output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>, finds a relative equation for the
class field corresponding to the module in <em>bnr</em> and the given
congruence subgroup (the full ray class field if <em>subgp</em> is omitted).
If d is positive, outputs the list of all relative equations of
degree d contained in the ray class field defined by <em>bnr</em>, with
the <em>same</em> conductor as (<em>bnr</em>, <em>subgp</em>).</p>
<p>
<b>Warning.</b> This routine only works for subgroups of prime index. It
uses Kummer theory, adjoining necessary roots of unity (it needs to compute a
tough <code><a href="General_number_fields.html#se:bnfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnfinit</a></code> here), and finds a generator via Hecke's characterization
of ramification in Kummer extensions of prime degree. If your extension does
not have prime degree, for the time being, you have to split it by hand as a
tower / compositum of such extensions.</p>
<p>
The library syntax is <code>GEN <b>rnfkummer</b>(GEN bnr, GEN subgp = NULL, long d, long prec)</code>.</p>
<p>

<hr>
<div id="se:rnflllgram"></div>
<div id="rnflllgram"></div>
<h4>rnflllgram(<em>nf</em>, <em>pol</em>, <em>order</em>)</h4>
<p>
Given a polynomial
<em>pol</em> with coefficients in <em>nf</em> defining a relative extension L and
a suborder <em>order</em> of L (of maximal rank), as output by
<code><a href="General_number_fields.html#se:rnfpseudobasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpseudobasis</a></code>(<em>nf</em>,<em>pol</em>) or similar, gives
[[<em>neworder</em>],U], where <em>neworder</em> is a reduced order and U is
the unimodular transformation matrix.</p>
<p>
The library syntax is <code>GEN <b>rnflllgram</b>(GEN nf, GEN pol, GEN order, long prec)</code>.</p>
<p>

<hr>
<div id="se:rnfnormgroup"></div>
<div id="rnfnormgroup"></div>
<h4>rnfnormgroup(<em>bnr</em>, <em>pol</em>)</h4>
<p>
<em>bnr</em> being a big ray
class field as output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code> and <em>pol</em> a relative polynomial
defining an Abelian extension, computes the norm group (alias Artin
or Takagi group) corresponding to the Abelian extension of
<em>bnf</em> = <code>bnr.bnf</code>
defined by <em>pol</em>, where the module corresponding to <em>bnr</em> is assumed
to be a multiple of the conductor (i.e.&nbsp;<em>pol</em> defines a subextension of
bnr). The result is the HNF defining the norm group on the given generators
of <code>bnr.gen</code>. Note that neither the fact that <em>pol</em> defines an
Abelian extension nor the fact that the module is a multiple of the conductor
is checked. The result is undefined if the assumption is not correct,
but the function will return the empty matrix <code>[;]</code> if it detects a
problem; it may also not detect the problem and return a wrong result.</p>
<p>
The library syntax is <code>GEN <b>rnfnormgroup</b>(GEN bnr, GEN pol)</code>.</p>
<p>

<hr>
<div id="se:rnfpolred"></div>
<div id="rnfpolred"></div>
<h4>rnfpolred(<em>nf</em>, <em>pol</em>)</h4>
<p>
This function is obsolete: use <code><a href="General_number_fields.html#se:rnfpolredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpolredbest</a></code> instead.
Relative version of <code><a href="General_number_fields.html#se:polred"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polred</a></code>. Given a monic polynomial <em>pol</em> with
coefficients in <em>nf</em>, finds a list of relative polynomials defining some
subfields, hopefully simpler and containing the original field. In the present
version <b>2.12.1</b>, this is slower and less efficient than <code><a href="General_number_fields.html#se:rnfpolredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpolredbest</a></code>.</p>
<p>
<b>Remark.</b> this function is based on an incomplete reduction
theory of lattices over number fields, implemented by <code><a href="General_number_fields.html#se:rnflllgram"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnflllgram</a></code>, which
deserves to be improved.</p>
<p>
The library syntax is <code>GEN <b>rnfpolred</b>(GEN nf, GEN pol, long prec)</code>.</p>
<p>

<hr>
<div id="se:rnfpolredabs"></div>
<div id="rnfpolredabs"></div>
<h4>rnfpolredabs(<em>nf</em>, <em>pol</em>, {<em>flag</em> = 0})</h4>
<p>
Relative version of <code><a href="General_number_fields.html#se:polredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredabs</a></code>. Given an irreducible monic polynomial
<em>pol</em> with coefficients in <em>nf</em>, finds a canonical relative
polynomial defining the same field, hopefully with small coefficients.
Note that the equation is only canonical for a fixed <em>nf</em>, using a
different defining polynomial in the <em>nf</em> structure will produce a
different relative equation.</p>
<p>
The binary digits of <em>flag</em> correspond to 1: add information to convert
elements to the new representation, 2: absolute polynomial, instead of
relative, 16: possibly use a suborder of the maximal order. More precisely:</p>
<p>
0: default, return P</p>
<p>
1: returns [P,a] where P is the default output and a,
a <code>t_POLMOD</code> modulo P, is a root of <em>pol</em>.</p>
<p>
2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
This polynomial is canonical and does not depend on the <em>nf</em> structure.
Same as but faster than</p>
<p>
</p><pre class="code">    polredabs(rnfequation(nf, pol))
</pre><p></p>
<p></p>
<p>
3: returns [<em>Pabs</em>,a,b], where <em>Pabs</em> is an absolute polynomial
as above, a, b are <code>t_POLMOD</code> modulo <em>Pabs</em>, roots of <code>nf.pol</code>
and <em>pol</em> respectively.</p>
<p>
16: possibly use a suborder of the maximal order. This is slower than the
default when the relative discriminant is smooth, and much faster otherwise.
In this case the result is no longer canonical; see Section <a href="General_number_fields.html#se:polredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">se:polredabs</a>.</p>
<p>
<b>Warning.</b> The complexity of <code><a href="General_number_fields.html#se:rnfpolredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpolredabs</a></code>
is exponential in the absolute degree. The function <code><a href="General_number_fields.html#se:rnfpolredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpolredbest</a></code> runs
in polynomial time, and  tends  to return polynomials with smaller
discriminants.</p>
<p>
The library syntax is <code>GEN <b>rnfpolredabs</b>(GEN nf, GEN pol, long flag)</code>.</p>
<p>

<hr>
<div id="se:rnfpolredbest"></div>
<div id="rnfpolredbest"></div>
<h4>rnfpolredbest(<em>nf</em>, <em>pol</em>, {<em>flag</em> = 0})</h4>
<p>
Relative version of <code><a href="General_number_fields.html#se:polredbest"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">polredbest</a></code>. Given a monic polynomial <em>pol</em>
with coefficients in <em>nf</em>, finds a simpler relative polynomial P
defining the same field. As opposed to <code><a href="General_number_fields.html#se:rnfpolredabs"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpolredabs</a></code> this function does
not return a <em>smallest</em> (canonical) polynomial with respect to some
measure, but it does run in polynomial time.</p>
<p>
The binary digits of <em>flag</em> correspond to 1: add information to convert
elements to the new representation, 2: absolute polynomial, instead of
relative. More precisely:</p>
<p>
0: default, return P</p>
<p>
1: returns [P,a] where P is the default output and a,
a <code>t_POLMOD</code> modulo P, is a root of <em>pol</em>.</p>
<p>
2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
Same as but faster than</p>
<p>
</p><pre class="code">    rnfequation(nf, rnfpolredbest(nf,pol))
</pre><p></p>
<p></p>
<p>
3: returns [<em>Pabs</em>,a,b], where <em>Pabs</em> is an absolute polynomial
as above, a, b are <code>t_POLMOD</code> modulo <em>Pabs</em>, roots of <code>nf.pol</code>
and <em>pol</em> respectively.</p>
<p></p>
<p>
</p><pre class="code">  ? K = nfinit(y^3-2); pol = x^2 +x*y + y^2;
  ? [P, a] = rnfpolredbest(K,pol,1);
  ? P
  %3 = x^2 - x + Mod(y - 1, y^3 - 2)
  ? a
  %4 = Mod(Mod(2*y^2+3*y+4,y^3-2)*x + Mod(-y^2-2*y-2,y^3-2),
           x^2 - x + Mod(y-1,y^3-2))
  ? subst(K.pol,y,a)
  %5 = 0
  ? [Pabs, a, b] = rnfpolredbest(K,pol,3);
  ? Pabs
  %7 = x^6 - 3*x^5 + 5*x^3 - 3*x + 1
  ? a
  %8 = Mod(-x^2+x+1, x^6-3*x^5+5*x^3-3*x+1)
  ? b
  %9 = Mod(2*x^5-5*x^4-3*x^3+10*x^2+5*x-5, x^6-3*x^5+5*x^3-3*x+1)
  ? subst(K.pol,y,a)
  %10 = 0
  ? substvec(pol,[x,y],[a,b])
  %11 = 0
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfpolredbest</b>(GEN nf, GEN pol, long flag)</code>.</p>
<p>

<hr>
<div id="se:rnfpseudobasis"></div>
<div id="rnfpseudobasis"></div>
<h4>rnfpseudobasis(<em>nf</em>, T)</h4>
<p>
Given an <em>nf</em> structure attached to a number field K, as output by
<code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code>, and a monic irreducible polynomial T in K[x] defining a
relative extension L = K[x]/(T), computes the relative discriminant of L
and a pseudo-basis (A,J) for the maximal order &Zopf;<sub>L</sub> viewed as a
&Zopf;<sub>K</sub>-module. This is output as a vector [A,J,D,d], where D is the
relative ideal discriminant and d is the relative discriminant considered
as an element of K<sup>*</sup>/{K<sup>*</sup>}^2.</p>
<p>
</p><pre class="code">  ? K = nfinit(y^2+1);
  ? [A,J,D,d] = rnfpseudobasis(K, x^2+y);
  ? A
  %3 =
  [1 0]
  
  [0 1]
  
  ? J
  %4 = [1, 1]
  ? D
  %5 = [0, -4]~
  ? d
  %6 = [0, -1]~
</pre><p></p>
<p></p>
<p>
<b>Huge discriminants, helping rnfdisc.</b> the format [T,B] is
also accepted instead of T and produce an order which is maximal at all
primes p &lt; B, see <code>??rnfinit</code>.</p>
<p>
</p><pre class="code">  ? p = 585403248812100232206609398101;
  ? q = 711171340236468512951957953369;
  ? T = x^2 + 3*(p*q)^2;
  ? [A,J,D,d] = V = rnfpseudobasis(K, T); D
  time = 22,178 ms.
  %10 =
  [3 0]
  
  [0 3]
  ? [A,J,D,d] = W = rnfpseudobasis(K, [T,100]); D
  time = 5 ms.
  %11 =
  [3 0]
  
  [0 3]
  ? V == W
  %12 = 1
</pre><p>
In this example, the results are identical since D &cap; &Zopf;
factors over primes less than 100. Had it not been the case, the
order would have been guaranteed maximal at primes &pfr; | p  for p
 &leq; 100 only (and might not have been maximal at any maximal ideal
&pfr; such that &pfr;^2 dividing D.</p>
<p>
The library syntax is <code>GEN <b>rnfpseudobasis</b>(GEN nf, GEN T)</code>.</p>
<p>

<hr>
<div id="se:rnfsteinitz"></div>
<div id="rnfsteinitz"></div>
<h4>rnfsteinitz(<em>nf</em>, x)</h4>
<p>
Given a number field <em>nf</em> as
output by <code><a href="General_number_fields.html#se:nfinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfinit</a></code> and either a polynomial x with coefficients in
<em>nf</em> defining a relative extension L of <em>nf</em>, or a pseudo-basis
x of such an extension as output for example by <code><a href="General_number_fields.html#se:rnfpseudobasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpseudobasis</a></code>,
computes another pseudo-basis (A,I) (not in HNF in general) such that all
the ideals of I except perhaps the last one are equal to the ring of
integers of <em>nf</em>, and outputs the four-component row vector [A,I,D,d]
as in <code><a href="General_number_fields.html#se:rnfpseudobasis"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfpseudobasis</a></code>. The name of this function comes from the fact
that the ideal class of the last ideal of I, which is well defined, is the
Steinitz class of the &Zopf;<sub>K</sub>-module &Zopf;<sub>L</sub> (its image in SK<sub>0</sub>(&Zopf;<sub>K</sub>)).</p>
<p>
The library syntax is <code>GEN <b>rnfsteinitz</b>(GEN nf, GEN x)</code>.</p>
<p>

<hr>
<div id="se:subgrouplist"></div>
<div id="subgrouplist"></div>
<h4>subgrouplist(<em>bnr</em>, {<em>bound</em>}, {<em>flag</em> = 0})</h4>
<p>
<em>bnr</em> being as output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code> or a list of cyclic components
of a finite Abelian group G, outputs the list of subgroups of G. Subgroups
are given as HNF left divisors of the SNF matrix corresponding to G.</p>
<p>
If <em>flag</em> = 0 (default) and <em>bnr</em> is as output by <code><a href="General_number_fields.html#se:bnrinit"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrinit</a></code>, gives
only the subgroups whose modulus is the conductor. Otherwise, the modulus is
not taken into account.</p>
<p>
If <em>bound</em> is present, and is a positive integer, restrict the output to
subgroups of index less than <em>bound</em>. If <em>bound</em> is a vector
containing a single positive integer B, then only subgroups of index
exactly equal to B are computed. For instance</p>
<p>
</p><pre class="code">  ? subgrouplist([6,2])
  %1 = [[6, 0; 0, 2], [2, 0; 0, 2], [6, 3; 0, 1], [2, 1; 0, 1], [3, 0; 0, 2],
  [1, 0; 0, 2], [6, 0; 0, 1], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
  ? subgrouplist([6,2],3)    \\  index less than 3
  %2 = [[2, 1; 0, 1], [1, 0; 0, 2], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
  ? subgrouplist([6,2],[3])  \\  index 3
  %3 = [[3, 0; 0, 1]]
  ? bnr = bnrinit(bnfinit(x), [120,[1]], 1);
  ? L = subgrouplist(bnr, [8]);
</pre><p></p>
<p>
In the last example, L corresponds to the 24 subfields of
&Qopf;(&zeta;<sub>120</sub>), of degree 8 and conductor 120 oo  (by setting <em>flag</em>,
we see there are a total of 43 subgroups of degree 8).</p>
<p>
</p><pre class="code">  ? vector(#L, i, galoissubcyclo(bnr, L[i]))
</pre><p></p>
<p>
will produce their equations. (For a general base field, you would
have to rely on <code><a href="General_number_fields.html#se:bnrstark"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">bnrstark</a></code>, or <code><a href="General_number_fields.html#se:rnfkummer"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">rnfkummer</a></code>.)</p>
<p>
The library syntax is <code>GEN <b>subgrouplist0</b>(GEN bnr, GEN bound = NULL, long flag)</code>.</p>
<p>

<hr>
</body>
