<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Catalogue of GP/PARI Functions: Vectors, matrices, linear algebra and sets</title>

  <meta name="author"       content="Karim Belabas">
  <meta name="created"      content="Wed Jan 22 18:53:36 2020">
  <meta name="author-email" content="pari@math.u-bordeaux.fr">
  <meta name="keywords"     content="PARI, GP, DOC">
  
  <link rel="stylesheet" href="/pari.css">
  <link rel="stylesheet" href="./gphtml.css">
</head>
<body >
<div id="se:linear_algebra"></div>
<h2 class="center">Vectors, matrices, linear algebra and sets</h2>

<p></p>
<p></p>
<p>
Note that most linear algebra functions operating on subspaces defined by
generating sets (such as <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:mathnf"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">mathnf</a></code>, <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qflll"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qflll</a></code>, etc.) take matrices as
arguments. As usual, the generating vectors are taken to be the
<em>columns</em> of the given matrix.</p>
<p>
Since PARI does not have a strong typing system, scalars live in
unspecified commutative base rings. It is very difficult to write
robust linear algebra routines in such a general setting. We thus
assume that the base ring is a domain and work over its field of
fractions. If the base ring is <em>not</em> a domain, one gets an error as soon
as a non-zero pivot turns out to be non-invertible. Some functions,
e.g.&nbsp;<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:mathnf"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">mathnf</a></code> or <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:mathnfmod"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">mathnfmod</a></code>, specifically assume that the base ring is
&Zopf;.</p>
<p>
<hr>
<div id="se:algdep"></div>
<div id="algdep"></div>
<h4>algdep(z, k, {<em>flag</em> = 0})</h4>
<p></p>
<p>
z being real/complex, or p-adic, finds a polynomial (in the variable
<code>'x</code>) of degree at most
k, with integer coefficients, having z as approximate root. Note that the
polynomial which is obtained is not necessarily the "correct" one. In fact
it is not even guaranteed to be irreducible. One can check the closeness
either by a polynomial evaluation (use <code><a href="Polynomials_and_power_series.html#se:subst"
    onClick="parent.itemFrame.location='cont_Polynomials_and_power_series.html'">subst</a></code>), or by computing the
roots of the polynomial given by <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:algdep"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">algdep</a></code> (use <code><a href="Polynomials_and_power_series.html#se:polroots"
    onClick="parent.itemFrame.location='cont_Polynomials_and_power_series.html'">polroots</a></code> or
<code><a href="Polynomials_and_power_series.html#se:polrootspadic"
    onClick="parent.itemFrame.location='cont_Polynomials_and_power_series.html'">polrootspadic</a></code>).</p>
<p>
Internally, <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:lindep"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">lindep</a></code>([1,z,...,z^k], <em>flag</em>) is used. A non-zero value of
<em>flag</em> may improve on the default behavior if the input number is known to a
<em>huge</em> accuracy, and you suspect the last bits are incorrect: if <em>flag</em> &gt; 0
the computation is done with an accuracy of <em>flag</em> decimal  digits; to get
meaningful results,  the parameter <em>flag</em> should be smaller than the number of
correct decimal digits in the input.
But default values are usually sufficient, so try without <em>flag</em> first:</p>
<p>
</p><pre class="code">  ? \p200
  ? z = 2^(1/6)+3^(1/5);
  ? algdep(z, 30);      \\ right in 280ms
  ? algdep(z, 30, 100); \\ wrong in 169ms
  ? algdep(z, 30, 170); \\ right in 288ms
  ? algdep(z, 30, 200); \\ wrong in 320ms
  ? \p250
  ? z = 2^(1/6)+3^(1/5); \\ recompute to new, higher, accuracy !
  ? algdep(z, 30);      \\ right in 329ms
  ? algdep(z, 30, 200); \\ right in 324ms
  ? \p500
  ? algdep(2^(1/6)+3^(1/5), 30); \\ right in 677ms
  ? \p1000
  ? algdep(2^(1/6)+3^(1/5), 30); \\ right in 1.5s
</pre><p></p>
<p>
The changes in <code>realprecision</code> only affect the quality of the
initial approximation to 2<sup>1/6</sup> + 3<sup>1/5</sup>, <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:algdep"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">algdep</a></code> itself uses
exact operations. The size of its operands depend on the accuracy of the
input of course: more accurate input means slower operations.</p>
<p>
Proceeding by increments of 5 digits of accuracy, <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:algdep"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">algdep</a></code> with default
flag produces its first correct result at 195 digits, and from then on a
steady stream of correct results:</p>
<p>
</p><pre class="code">    \\ assume T contains the correct result, for comparison
    forstep(d=100, 250, 5, localprec(d);\
      print(d, " ", algdep(2^(1/6)+3^(1/5),30) == T))
</pre><p></p>
<p></p>
<p>
The above example is the test case studied in a 2000 paper by Borwein and
Lisonek: Applications of integer relation algorithms, <em>Discrete Math.</em>,
<b>217</b>, p.&nbsp;65--82. The version of PARI tested there was 1.39, which
succeeded reliably from precision 265 on, in about 200 as much time as the
current version.</p>
<p>
The library syntax is <code>GEN <b>algdep0</b>(GEN z, long k, long flag)</code>.
Also available is <code>GEN <b>algdep</b>(GEN z, long k)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:bestapprnf"></div>
<div id="bestapprnf"></div>
<h4>bestapprnf(V, T, {<em>rootT</em>})</h4>
<p>
T being an integral polynomial and V being a scalar, vector, or
matrix with complex coefficients, return a reasonable approximation of V
with polmods modulo T. T can also be any number field structure, in which
case the minimal polynomial attached to the structure (<code>T</code>.pol) is
used. The <em>rootT</em> argument, if present, must be an element of
<code>polroots(T)</code> (or <code>T</code>.pol), i.e.&nbsp;a complex root of T fixing an embedding of
&Qopf;[x]/(T) into &Copf;.</p>
<p>
</p><pre class="code">  ? bestapprnf(sqrt(5), polcyclo(5))
  %1 = Mod(-2*x^3 - 2*x^2 - 1, x^4 + x^3 + x^2 + x + 1)
  ? bestapprnf(sqrt(5), polcyclo(5), exp(4*I*Pi/5))
  %2 = Mod(2*x^3 + 2*x^2 + 1, x^4 + x^3 + x^2 + x + 1)
</pre><p>
When the output has huge rational coefficients, try to
increase the working <code>realbitprecision</code>: if the answer does not
stabilize, consider that the reconstruction failed.
Beware that if T is not Galois over &Qopf;, some embeddings
may not allow to reconstruct V:</p>
<p>
</p><pre class="code">  ? T = x^3-2; vT = polroots(T); z = 3*2^(1/3)+1;
  ? bestapprnf(z, T, vT[1])
  %2 = Mod(3*x + 1, x^3 - 2)
  ? bestapprnf(z, T, vT[2])
  %3 = 4213714286230872/186454048314072  \\ close to 3*2^(1/3) + 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bestapprnf</b>(GEN V, GEN T, GEN rootT = NULL, long prec)</code>.</p>
<p>

<hr>
<div id="se:charpoly"></div>
<div id="charpoly"></div>
<h4>charpoly(A, {v = 'x}, {<em>flag</em> = 5})</h4>
<p>
characteristic polynomial
of A with respect to the variable v, i.e.&nbsp;determinant of v*I-A if A
is a square matrix.</p>
<p>
</p><pre class="code">  ? charpoly([1,2;3,4]);
  %1 = x^2 - 5*x - 2
  ? charpoly([1,2;3,4],, 't)
  %2 = t^2 - 5*t - 2
</pre><p></p>
<p>
If A is not a square matrix, the function returns the characteristic
polynomial of the map "multiplication by A" if A is a scalar:</p>
<p>
</p><pre class="code">  ? charpoly(Mod(x+2, x^3-2))
  %1 = x^3 - 6*x^2 + 12*x - 10
  ? charpoly(I)
  %2 = x^2 + 1
  ? charpoly(quadgen(5))
  %3 = x^2 - x - 1
  ? charpoly(ffgen(ffinit(2,4)))
  %4 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
</pre><p></p>
<p></p>
<p>
The value of <em>flag</em> is only significant for matrices, and we advise to stick
to the default value. Let n be the dimension of A.</p>
<p>
If <em>flag</em> = 0, same method (Le Verrier's) as for computing the adjoint matrix,
i.e.&nbsp;using the traces of the powers of A. Assumes that n! is
invertible; uses O(n^4) scalar operations.</p>
<p>
If <em>flag</em> = 1, uses Lagrange interpolation which is usually the slowest method.
Assumes that n! is invertible; uses O(n^4) scalar operations.</p>
<p>
If <em>flag</em> = 2, uses the Hessenberg form. Assumes that the base ring is a field.
Uses O(n^3) scalar operations, but suffers from coefficient explosion
unless the base field is finite or &Ropf;.</p>
<p>
If <em>flag</em> = 3, uses Berkowitz's division free algorithm, valid over any
ring (commutative, with unit). Uses O(n^4) scalar operations.</p>
<p>
If <em>flag</em> = 4, x must be integral. Uses a modular algorithm: Hessenberg form
for various small primes, then Chinese remainders.</p>
<p>
If <em>flag</em> = 5 (default), uses the "best" method given x.
This means we use Berkowitz unless the base ring is &Zopf; (use <em>flag</em> = 4)
or a field where coefficient explosion does not occur,
e.g.&nbsp;a finite field or the reals (use <em>flag</em> = 2).</p>
<p>
The library syntax is <code>GEN <b>charpoly0</b>(GEN A, long v = -1, long flag)</code> where <code>v</code> is a variable number.
Also available are
<code>GEN <b>charpoly</b>(GEN x, long v)</code> (<em>flag</em> = 5),
<code>GEN <b>caract</b>(GEN A, long v)</code> (<em>flag</em> = 1),
<code>GEN <b>carhess</b>(GEN A, long v)</code> (<em>flag</em> = 2),
<code>GEN <b>carberkowitz</b>(GEN A, long v)</code> (<em>flag</em> = 3) and
<code>GEN <b>caradj</b>(GEN A, long v, GEN *pt)</code>. In this
last case, if <em>pt</em> is not <code>NULL</code>, <code>*pt</code> receives the address of
the adjoint matrix of A (see <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matadjoint"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matadjoint</a></code>), so both can be obtained at
once.</p>
<p>

<hr>
<div id="se:concat"></div>
<div id="concat"></div>
<h4>concat(x, {y})</h4>
<p>
Concatenation of x and y. If x or y is
not a vector or matrix, it is considered as a one-dimensional vector. All
types are allowed for x and y, but the sizes must be compatible. Note
that matrices are concatenated horizontally, i.e.&nbsp;the number of rows stays
the same. Using transpositions, one can concatenate them vertically,
but it is often simpler to use <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matconcat"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matconcat</a></code>.</p>
<p>
</p><pre class="code">  ? x = matid(2); y = 2*matid(2);
  ? concat(x,y)
  %2 =
  [1 0 2 0]
  
  [0 1 0 2]
  ? concat(x~,y~)~
  %3 =
  [1 0]
  
  [0 1]
  
  [2 0]
  
  [0 2]
  ? matconcat([x;y])
  %4 =
  [1 0]
  
  [0 1]
  
  [2 0]
  
  [0 2]
</pre><p></p>
<p>
To concatenate vectors sideways (i.e.&nbsp;to obtain a two-row or two-column
matrix), use <code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:Mat"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">Mat</a></code> instead, or <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matconcat"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matconcat</a></code>:</p>
<p>
</p><pre class="code">  ? x = [1,2];
  ? y = [3,4];
  ? concat(x,y)
  %3 = [1, 2, 3, 4]
  
  ? Mat([x,y]~)
  %4 =
  [1 2]
  
  [3 4]
  ? matconcat([x;y])
  %5 =
  [1 2]
  
  [3 4]
</pre><p></p>
<p>
Concatenating a row vector to a matrix having the same number of columns will
add the row to the matrix (top row if the vector is x, i.e.&nbsp;comes first, and
bottom row otherwise).</p>
<p>
The empty matrix <code>[;]</code> is considered to have a number of rows compatible
with any operation, in particular concatenation. (Note that this is
<em>not</em> the case for empty vectors <code>[&nbsp;]</code> or <code>[&nbsp;]~</code>.)</p>
<p>
If y is omitted, x has to be a row vector or a list, in which case its
elements are concatenated, from left to right, using the above rules.</p>
<p>
</p><pre class="code">  ? concat([1,2], [3,4])
  %1 = [1, 2, 3, 4]
  ? a = [[1,2]~, [3,4]~]; concat(a)
  %2 =
  [1 3]
  
  [2 4]
  
  ? concat([1,2; 3,4], [5,6]~)
  %3 =
  [1 2 5]
  
  [3 4 6]
  ? concat([%, [7,8]~, [1,2,3,4]])
  %5 =
  [1 2 5 7]
  
  [3 4 6 8]
  
  [1 2 3 4]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>gconcat</b>(GEN x, GEN y = NULL)</code>.
<code>GEN <b>gconcat1</b>(GEN x)</code> is a shortcut for <code>gconcat(x,NULL)</code>.</p>
<p>

<hr>
<div id="se:forqfvec"></div>
<div id="forqfvec"></div>
<h4>forqfvec(v, q, b, <em>expr</em>)</h4>
<p>
q being a square and symmetric integral matrix representing a positive
definite
quadratic form, evaluate <code>expr</code> for all vector v such that q(v) &leq; b.
The formal variable v runs through all such vectors in turn.</p>
<p>
</p><pre class="code">  ? forqfvec(v, [3,2;2,3], 3, print(v))
  [0, 1]~
  [1, 0]~
  [-1, 1]~
</pre><p></p>
<p></p>
<p>
The library syntax is <code>void <b>forqfvec0</b>(GEN v, GEN q = NULL, GEN b)</code>.
The following function is also available:
<code>void <b>forqfvec</b>(void *E, long (*fun)(void *, GEN, GEN, double), GEN q, GEN b)</code>:
Evaluate <code>fun(E,w,v,m)</code> on all v such that q(v) &lt; b, where v is a
<code>t_VECSMALL</code> and m = q(v) is a C double. The function <code>fun</code> must
return 0, unless <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:forqfvec"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">forqfvec</a></code> should stop, in which case, it should
return 1.</p>
<p>

<hr>
<div id="se:lindep"></div>
<div id="lindep"></div>
<h4>lindep(v, {<em>flag</em> = 0})</h4>
<p>
 finds a small non-trivial integral linear
combination between components of v. If none can be found return an empty
vector.</p>
<p>
If v is a vector with real/complex entries we use a floating point
(variable precision) LLL algorithm. If <em>flag</em> = 0 the accuracy is chosen
internally using a crude heuristic. If <em>flag</em> &gt; 0 the computation is done with
an accuracy of <em>flag</em> decimal digits. To get meaningful results in the latter
case, the parameter <em>flag</em> should be smaller than the number of correct
decimal digits in the input.</p>
<p></p>
<p>
</p><pre class="code">  ? lindep([sqrt(2), sqrt(3), sqrt(2)+sqrt(3)])
  %1 = [-1, -1, 1]~
</pre><p></p>
<p></p>
<p>
If v is p-adic, <em>flag</em> is ignored and the algorithm LLL-reduces a
suitable (dual) lattice.</p>
<p>
</p><pre class="code">  ? lindep([1, 2 + 3 + 3^2 + 3^3 + 3^4 + O(3^5)])
  %2 = [1, -2]~
</pre><p></p>
<p></p>
<p>
If v is a matrix (or a vector of column vectors, or a vector of row
vectors), <em>flag</em> is ignored and the function returns a non trivial kernel
vector if one exists, else an empty vector.</p>
<p>
</p><pre class="code">  ? lindep([1,2,3;4,5,6;7,8,9])
  %3 = [1, -2, 1]~
  ? lindep([[1,0], [2,0]])
  %4 = [2, -1]~
  ? lindep([[1,0], [0,1]])
  %5 = []~
</pre><p></p>
<p></p>
<p>
If v contains polynomials or power series over some base field, finds a
linear relation with coefficients in the field.</p>
<p>
</p><pre class="code">  ? lindep([x*y, x^2 + y, x^2*y + x*y^2, 1])
  %4 = [y, y, -1, -y^2]~
</pre><p>
For better control, it is preferable to use <code>t_POL</code> rather
than <code>t_SER</code> in the input, otherwise one gets a linear combination which is
t-adically small, but not necessarily 0. Indeed, power series are first
converted to the minimal absolute accuracy occurring among the entries of v
(which can cause some coefficients to be ignored), then truncated to
polynomials:</p>
<p>
</p><pre class="code">  ? v = [t^2+O(t^4), 1+O(t^2)]; L=lindep(v)
  %1 = [1, 0]~
  ? v*L
  %2 = t^2+O(t^4)  \\ small but not 0
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>lindep0</b>(GEN v, long flag)</code>.</p>
<p>

<hr>
<div id="se:matadjoint"></div>
<div id="matadjoint"></div>
<h4>matadjoint(M, {<em>flag</em> = 0})</h4>
<p>
adjoint matrix of M, i.e.&nbsp;a matrix N
of cofactors of M, satisfying M*N = det(M)*Id. M must be a
(non-necessarily invertible) square matrix of dimension n.
If <em>flag</em> is 0 or omitted, we try to use Leverrier-Faddeev's algorithm,
which assumes that n! invertible. If it fails or <em>flag</em> = 1,
compute T = <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:charpoly"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">charpoly</a></code>(M) independently first and return
(-1)<sup>n-1</sup> (T(x)-T(0))/x evaluated at M.</p>
<p>
</p><pre class="code">  ? a = [1,2,3;3,4,5;6,7,8] * Mod(1,4);
  %2 =
  [Mod(1, 4) Mod(2, 4) Mod(3, 4)]
  
  [Mod(3, 4) Mod(0, 4) Mod(1, 4)]
  
  [Mod(2, 4) Mod(3, 4) Mod(0, 4)]
</pre><p></p>
<p>
Both algorithms use O(n^4) operations in the base ring, and are usually
slower than computing the characteristic polynomial or the inverse of M
directly.</p>
<p>
The library syntax is <code>GEN <b>matadjoint0</b>(GEN M, long flag)</code>.
Also available are
<code>GEN <b>adj</b>(GEN x)</code> (<em>flag</em> = 0) and
<code>GEN <b>adjsafe</b>(GEN x)</code> (<em>flag</em> = 1).</p>
<p>

<hr>
<div id="se:matcompanion"></div>
<div id="matcompanion"></div>
<h4>matcompanion(x)</h4>
<p>
The left companion matrix to the non-zero polynomial x.</p>
<p>
The library syntax is <code>GEN <b>matcompanion</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:matconcat"></div>
<div id="matconcat"></div>
<h4>matconcat(v)</h4>
<p>
Returns a <code>t_MAT</code> built from the entries of v, which may
be a <code>t_VEC</code> (concatenate horizontally), a <code>t_COL</code> (concatenate
vertically), or a <code>t_MAT</code> (concatenate vertically each column, and
concatenate vertically the resulting matrices). The entries of v are always
considered as matrices: they can themselves be <code>t_VEC</code> (seen as a row
matrix), a <code>t_COL</code> seen as a column matrix), a <code>t_MAT</code>, or a scalar (seen
as an 1  x 1 matrix).</p>
<p>
</p><pre class="code">  ? A=[1,2;3,4]; B=[5,6]~; C=[7,8]; D=9;
  ? matconcat([A, B]) \\ horizontal
  %1 =
  [1 2 5]
  
  [3 4 6]
  ? matconcat([A, C]~) \\ vertical
  %2 =
  [1 2]
  
  [3 4]
  
  [7 8]
  ? matconcat([A, B; C, D]) \\ block matrix
  %3 =
  [1 2 5]
  
  [3 4 6]
  
  [7 8 9]
</pre><p></p>
<p>
If the dimensions of the entries to concatenate do not match up, the above
rules are extended as follows:</p>
<p>
<b>*</b> each entry v<sub>i,j</sub> of v has a natural length and height: 1  x 
1 for a scalar, 1  x n for a <code>t_VEC</code> of length n, n  x 1
for a <code>t_COL</code>, m  x n for an m x n <code>t_MAT</code></p>
<p>
<b>*</b> let H<sub>i</sub> be the maximum over j of the lengths of the v<sub>i,j</sub>,
let L<sub>j</sub> be the maximum over i of the heights of the v<sub>i,j</sub>.
The dimensions of the (i,j)-th block in the concatenated matrix are
H<sub>i</sub>  x L<sub>j</sub>.</p>
<p>
<b>*</b> a scalar s = v<sub>i,j</sub> is considered as s times an identity matrix
of the block dimension min (H<sub>i</sub>,L<sub>j</sub>)</p>
<p>
<b>*</b> blocks are extended by 0 columns on the right and 0 rows at the
bottom, as needed.</p>
<p></p>
<p>
</p><pre class="code">  ? matconcat([1, [2,3]~, [4,5,6]~]) \\ horizontal
  %4 =
  [1 2 4]
  
  [0 3 5]
  
  [0 0 6]
  ? matconcat([1, [2,3], [4,5,6]]~) \\ vertical
  %5 =
  [1 0 0]
  
  [2 3 0]
  
  [4 5 6]
  ? matconcat([B, C; A, D]) \\ block matrix
  %6 =
  [5 0 7 8]
  
  [6 0 0 0]
  
  [1 2 9 0]
  
  [3 4 0 9]
  ? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
  ? matconcat(matdiagonal([U, V])) \\ block diagonal
  %7 =
  [1 2 0 0 0]
  
  [3 4 0 0 0]
  
  [0 0 1 2 3]
  
  [0 0 4 5 6]
  
  [0 0 7 8 9]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>matconcat</b>(GEN v)</code>.</p>
<p>

<hr>
<div id="se:matdet"></div>
<div id="matdet"></div>
<h4>matdet(x, {<em>flag</em> = 0})</h4>
<p>
Determinant of the square matrix x.</p>
<p>
If <em>flag</em> = 0, uses an appropriate algorithm depending on the coefficients:</p>
<p>
<b>*</b> integer entries: modular method due to Dixon, Pernet and Stein.</p>
<p>
<b>*</b> real or p-adic entries: classical Gaussian elimination using maximal
pivot.</p>
<p>
<b>*</b> intmod entries: classical Gaussian elimination using first non-zero
pivot.</p>
<p>
<b>*</b> other cases: Gauss-Bareiss.</p>
<p>
If <em>flag</em> = 1, uses classical Gaussian elimination with appropriate pivoting
strategy (maximal pivot for real or p-adic coefficients). This is usually
worse than the default.</p>
<p>
The library syntax is <code>GEN <b>det0</b>(GEN x, long flag)</code>.
Also available are <code>GEN <b>det</b>(GEN x)</code> (<em>flag</em> = 0),
<code>GEN <b>det2</b>(GEN x)</code> (<em>flag</em> = 1) and <code>GEN <b>ZM_det</b>(GEN x)</code> for integer
entries.</p>
<p>

<hr>
<div id="se:matdetint"></div>
<div id="matdetint"></div>
<h4>matdetint(B)</h4>
<p>
Let B be an m x n matrix with integer coefficients. The
<em>determinant</em> D of the lattice generated by the columns of B is
the square root of det(B^T B) if B has maximal rank m, and 0
otherwise.</p>
<p>
This function uses the Gauss-Bareiss algorithm to compute a positive
<em>multiple</em> of D. When B is square, the function actually returns
D = |det B|.</p>
<p>
This function is useful in conjunction with <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:mathnfmod"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">mathnfmod</a></code>, which needs to
know such a multiple. If the rank is maximal and the matrix non-square,
you can obtain D exactly using</p>
<p>
</p><pre class="code">    matdet( mathnfmod(B, matdetint(B)) )
</pre><p></p>
<p>
Note that as soon as one of the dimensions gets large (m or n is larger
than 20, say), it will often be much faster to use <code>mathnf(B, 1)</code> or
<code>mathnf(B, 4)</code> directly.</p>
<p>
The library syntax is <code>GEN <b>detint</b>(GEN B)</code>.</p>
<p>

<hr>
<div id="se:matdetmod"></div>
<div id="matdetmod"></div>
<h4>matdetmod(x, d)</h4>
<p>
Given a matrix x with <code>t_INT</code> entries and d an arbitrary positive
integer, return the determinant of x modulo d.</p>
<p></p>
<p>
</p><pre class="code">  ? A = [4,2,3; 4,5,6; 7,8,9]
  
  ? matdetmod(A,27)
  %2 = 9
</pre><p>
Note that using the generic function <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matdet"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matdet</a></code> on a matrix with
<code>t_INTMOD</code> entries uses Gaussian reduction and will fail in general when
the modulus is not prime.</p>
<p>
</p><pre class="code">  ? matdet(A * Mod(1,27))
   ***   at top-level: matdet(A*Mod(1,27))
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; 
   *** matdet: impossible inverse in Fl_inv: Mod(3, 27).
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>matdetmod</b>(GEN x, GEN d)</code>.</p>
<p>

<hr>
<div id="se:matdiagonal"></div>
<div id="matdiagonal"></div>
<h4>matdiagonal(x)</h4>
<p>
x being a vector, creates the diagonal matrix
whose diagonal entries are those of x.</p>
<p>
</p><pre class="code">  ? matdiagonal([1,2,3]);
  %1 =
  [1 0 0]
  
  [0 2 0]
  
  [0 0 3]
</pre><p>
Block diagonal matrices are easily created using
<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matconcat"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matconcat</a></code>:</p>
<p>
</p><pre class="code">  ? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
  ? matconcat(matdiagonal([U, V]))
  %1 =
  [1 2 0 0 0]
  
  [3 4 0 0 0]
  
  [0 0 1 2 3]
  
  [0 0 4 5 6]
  
  [0 0 7 8 9]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>diagonal</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:mateigen"></div>
<div id="mateigen"></div>
<h4>mateigen(x, {<em>flag</em> = 0})</h4>
<p>
Returns the (complex) eigenvectors of x as columns of a matrix.
If <em>flag</em> = 1, return [L,H], where L contains the
eigenvalues and H the corresponding eigenvectors; multiple eigenvalues are
repeated according to the eigenspace dimension (which may be less
than the eigenvalue multiplicity in the characteristic polynomial).</p>
<p>
This function first computes the characteristic polynomial of x and
approximates its complex roots (&lambda;<sub>i</sub>), then tries to compute the
eigenspaces as kernels of the x - &lambda;<sub>i</sub>. This algorithm is
ill-conditioned and is likely to miss kernel vectors if some roots of the
characteristic polynomial are close, in particular if it has multiple roots.</p>
<p>
</p><pre class="code">  ? A = [13,2; 10,14]; mateigen(A)
  %1 =
  [-1/2 2/5]
  
  [   1   1]
  ? [L,H] = mateigen(A, 1);
  ? L
  %3 = [9, 18]
  ? H
  %4 =
  [-1/2 2/5]
  
  [   1   1]
</pre><p></p>
<p>
For symmetric matrices, use <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfjacobi"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfjacobi</a></code> instead; for Hermitian matrices,
compute</p>
<p>
</p><pre class="code">   A = real(x);
   B = imag(x);
   y = matconcat([A, -B; B, A]);
</pre><p>
and apply <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfjacobi"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfjacobi</a></code> to y.</p>
<p>
The library syntax is <code>GEN <b>mateigen</b>(GEN x, long flag, long prec)</code>.
Also available is <code>GEN <b>eigen</b>(GEN x, long prec)</code> (<em>flag</em> = 0)</p>
<p>

<hr>
<div id="se:matfrobenius"></div>
<div id="matfrobenius"></div>
<h4>matfrobenius(M, {<em>flag</em>}, {v = 'x})</h4>
<p>
Returns the Frobenius form of
the square matrix <code>M</code>. If <em>flag</em> = 1, returns only the elementary divisors as
a vector of polynomials in the variable <code>v</code>.  If <em>flag</em> = 2, returns a
two-components vector [F,B] where <code>F</code> is the Frobenius form and <code>B</code> is
the basis change so that M = B<sup>-1</sup>FB.</p>
<p>
The library syntax is <code>GEN <b>matfrobenius</b>(GEN M, long flag, long v = -1)</code> where <code>v</code> is a variable number.</p>
<p>

<hr>
<div id="se:mathess"></div>
<div id="mathess"></div>
<h4>mathess(x)</h4>
<p>
Returns a matrix similar to the square matrix x, which is in upper Hessenberg
form (zero entries below the first subdiagonal).</p>
<p>
The library syntax is <code>GEN <b>hess</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:mathilbert"></div>
<div id="mathilbert"></div>
<h4>mathilbert(n)</h4>
<p>
x being a <code>long</code>, creates the
Hilbert matrixof order x, i.e.&nbsp;the matrix whose coefficient
(i,j) is 1/ (i+j-1).</p>
<p>
The library syntax is <code>GEN <b>mathilbert</b>(long n)</code>.</p>
<p>

<hr>
<div id="se:mathnf"></div>
<div id="mathnf"></div>
<h4>mathnf(M, {<em>flag</em> = 0})</h4>
<p>
Let R be a Euclidean ring, equal to &Zopf; or to K[X] for some field
K. If M is a (not necessarily square) matrix with entries in R, this
routine finds the <em>upper triangular</em> Hermite normal form of M.
If the rank of M is equal to its number of rows, this is a square
matrix. In general, the columns of the result form a basis of the R-module
spanned by the columns of M.</p>
<p>
The values of <em>flag</em> are:</p>
<p>
<b>*</b> 0 (default): only return the Hermite normal form H</p>
<p>
<b>*</b> 1 (complete output): return [H,U], where H is the Hermite
normal form of M, and U is a transformation matrix such that MU = [0|H].
The matrix U belongs to GL(R). When M has a large kernel, the
entries of U are in general huge.</p>
<p>
For these two values, we use a naive algorithm, which behaves well
in small dimension only. Larger values correspond to different algorithms,
are restricted to <em>integer</em> matrices, and all output the unimodular
matrix U. From now on all matrices have integral entries.</p>
<p>
<b>*</b> <em>flag</em> = 4, returns [H,U] as in "complete output" above, using a
variant of LLL reduction along the way. The matrix U is provably
small in the L<sub>2</sub> sense, and often close to optimal; but the
reduction is in general slow, although provably polynomial-time.</p>
<p>
If <em>flag</em> = 5, uses Batut's algorithm and output [H,U,P], such that H and
U are as before and P is a permutation of the rows such that P applied
to MU gives H. This is in general faster than <em>flag</em> = 4 but the matrix U
is usually worse; it is heuristically smaller than with the default algorithm.</p>
<p>
When the matrix is dense and the dimension is large (bigger than 100, say),
<em>flag</em> = 4 will be fastest. When M has maximal rank, then</p>
<p>
</p><pre class="code">    H = mathnfmod(M, matdetint(M))
</pre><p>
will be even faster. You can then recover U as M<sup>-1</sup>H.</p>
<p></p>
<p>
</p><pre class="code">  ? M = matrix(3,4,i,j,random([-5,5]))
  %1 =
  [ 0 2  3  0]
  
  [-5 3 -5 -5]
  
  [ 4 3 -5  4]
  
  ? [H,U] = mathnf(M, 1);
  ? U
  %3 =
  [-1 0 -1 0]
  
  [ 0 5  3 2]
  
  [ 0 3  1 1]
  
  [ 1 0  0 0]
  
  ? H
  %5 =
  [19 9 7]
  
  [ 0 9 1]
  
  [ 0 0 1]
  
  ? M*U
  %6 =
  [0 19 9 7]
  
  [0  0 9 1]
  
  [0  0 0 1]
</pre><p></p>
<p></p>
<p>
For convenience, M is allowed to be a <code>t_VEC</code>, which is then
automatically converted to a <code>t_MAT</code>, as per the <code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:Mat"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">Mat</a></code> function.
For instance to solve the generalized extended gcd problem, one may use</p>
<p>
</p><pre class="code">  ? v = [116085838, 181081878, 314252913,10346840];
  ? [H,U] = mathnf(v, 1);
  ? U
  %2 =
  [ 103 -603    15  -88]
  
  [-146   13 -1208  352]
  
  [  58  220   678 -167]
  
  [-362 -144   381 -101]
  ? v*U
  %3 = [0, 0, 0, 1]
</pre><p>
This also allows to input a matrix as a <code>t_VEC</code> of
<code>t_COL</code>s of the same length (which <code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:Mat"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">Mat</a></code> would concatenate to
the <code>t_MAT</code> having those columns):</p>
<p>
</p><pre class="code">  ? v = [[1,0,4]~, [3,3,4]~, [0,-4,-5]~]; mathnf(v)
  %1 =
  [47 32 12]
  
  [ 0  1  0]
  
  [ 0  0  1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>mathnf0</b>(GEN M, long flag)</code>.
Also available are <code>GEN <b>hnf</b>(GEN M)</code> (<em>flag</em> = 0) and
<code>GEN <b>hnfall</b>(GEN M)</code> (<em>flag</em> = 1). To reduce <em>huge</em> relation matrices
(sparse with small entries, say dimension 400 or more), you can use the
pair <code>hnfspec</code> / <code>hnfadd</code>. Since this is quite technical and the
calling interface may change, they are not documented yet. Look at the code
in <code>basemath/hnf_snf.c</code>.</p>
<p>

<hr>
<div id="se:mathnfmod"></div>
<div id="mathnfmod"></div>
<h4>mathnfmod(x, d)</h4>
<p>
If x is a (not necessarily square) matrix of
maximal rank with integer entries, and d is a multiple of the (non-zero)
determinant of the lattice spanned by the columns of x, finds the
<em>upper triangular</em> Hermite normal form of x.</p>
<p>
If the rank of x is equal to its number of rows, the result is a square
matrix. In general, the columns of the result form a basis of the lattice
spanned by the columns of x. Even when d is known, this is in general
slower than <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:mathnf"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">mathnf</a></code> but uses much less memory.</p>
<p>
The library syntax is <code>GEN <b>hnfmod</b>(GEN x, GEN d)</code>.</p>
<p>

<hr>
<div id="se:mathnfmodid"></div>
<div id="mathnfmodid"></div>
<h4>mathnfmodid(x, d)</h4>
<p>
Outputs the (upper triangular)
Hermite normal form of x concatenated with the diagonal
matrix with diagonal d. Assumes that x has integer entries.
Variant: if d is an integer instead of a vector, concatenate d times the
identity matrix.</p>
<p>
</p><pre class="code">  ? m=[0,7;-1,0;-1,-1]
  %1 =
  [ 0  7]
  
  [-1  0]
  
  [-1 -1]
  ? mathnfmodid(m, [6,2,2])
  %2 =
  [2 1 1]
  
  [0 1 0]
  
  [0 0 1]
  ? mathnfmodid(m, 10)
  %3 =
  [10 7 3]
  
  [ 0 1 0]
  
  [ 0 0 1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>hnfmodid</b>(GEN x, GEN d)</code>.</p>
<p>

<hr>
<div id="se:mathouseholder"></div>
<div id="mathouseholder"></div>
<h4>mathouseholder(Q, v)</h4>
<p>
applies a sequence Q of Householder
transforms, as returned by <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matqr"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matqr</a></code>(M,1) to the vector or matrix v.</p>
<p>
The library syntax is <code>GEN <b>mathouseholder</b>(GEN Q, GEN v)</code>.</p>
<p>

<hr>
<div id="se:matid"></div>
<div id="matid"></div>
<h4>matid(n)</h4>
<p>
Creates the n x n identity matrix.</p>
<p>
The library syntax is <code>GEN <b>matid</b>(long n)</code>.</p>
<p>

<hr>
<div id="se:matimage"></div>
<div id="matimage"></div>
<h4>matimage(x, {<em>flag</em> = 0})</h4>
<p>
Gives a basis for the image of the
matrix x as columns of a matrix. A priori the matrix can have entries of
any type. If <em>flag</em> = 0, use standard Gauss pivot. If <em>flag</em> = 1, use
<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matsupplement"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matsupplement</a></code> (much slower: keep the default flag!).</p>
<p>
The library syntax is <code>GEN <b>matimage0</b>(GEN x, long flag)</code>.
Also available is <code>GEN <b>image</b>(GEN x)</code> (<em>flag</em> = 0).</p>
<p>

<hr>
<div id="se:matimagecompl"></div>
<div id="matimagecompl"></div>
<h4>matimagecompl(x)</h4>
<p>
Gives the vector of the column indices which
are not extracted by the function <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matimage"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matimage</a></code>, as a permutation
(<code>t_VECSMALL</code>). Hence the number of
components of <code>matimagecompl(x)</code> plus the number of columns of
<code>matimage(x)</code> is equal to the number of columns of the matrix x.</p>
<p>
The library syntax is <code>GEN <b>imagecompl</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:matimagemod"></div>
<div id="matimagemod"></div>
<h4>matimagemod(x, d, &U)</h4>
<p>
Gives a Howell basis (unique representation for submodules of&nbsp;(&Zopf;/d&Zopf;)^n)
for the image of the matrix x modulo d as columns of a matrix H. The
matrix x must have <code>t_INT</code> entries, and d can be an arbitrary positive
integer. If U is present, set it to a matrix such that&nbsp;AU = H.</p>
<p></p>
<p>
</p><pre class="code">  ? A = [2,1;0,2];
  ? matimagemod(A,6,&U)
  %2 =
  [1 0]
  
  [0 2]
  
  ? U
  %3 =
  [5 1]
  
  [3 4]
  
  ? (A*U)%6
  %4 =
  [1 0]
  
  [0 2]
</pre><p></p>
<p></p>
<p>
<b>Caveat.</b> In general the number of columns of the Howell form is not
the minimal number of generators of the submodule. Example:</p>
<p></p>
<p>
</p><pre class="code">  ? matimagemod([1;2],4)
  %5 =
  [2 1]
  
  [0 2]
</pre><p></p>
<p></p>
<p>
<b>Caveat 2.</b> In general the matrix U is not invertible, even if&nbsp;A
and&nbsp;H have the same size. Example:</p>
<p></p>
<p>
</p><pre class="code">  ? matimagemod([4,1;0,4],8,&U)
  %6 =
  [2 1]
  
  [0 4]
  
  ? U
  %7 =
  [0 0]
  
  [2 1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>matimagemod</b>(GEN x, GEN d, GEN *U = NULL)</code>.</p>
<p>

<hr>
<div id="se:matindexrank"></div>
<div id="matindexrank"></div>
<h4>matindexrank(M)</h4>
<p>
M being a matrix of rank r, returns a vector with two
<code>t_VECSMALL</code> components y and z of length r giving a list of rows
and columns respectively (starting from 1) such that the extracted matrix
obtained from these two vectors using <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:vecextract"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">vecextract</a></code>(M,y,z) is
invertible. The vectors y and z are sorted in increasing order.</p>
<p>
The library syntax is <code>GEN <b>indexrank</b>(GEN M)</code>.</p>
<p>

<hr>
<div id="se:matintersect"></div>
<div id="matintersect"></div>
<h4>matintersect(x, y)</h4>
<p>
x and y being two matrices with the same
number of rows each of whose columns are independent, finds a basis of the
&Qopf;-vector space equal to the intersection of the spaces spanned by the
columns of x and y respectively. The faster function
<code><a href="General_number_fields.html#se:idealintersect"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">idealintersect</a></code> can be used to intersect fractional ideals (projective
&Zopf;<sub>K</sub> modules of rank 1); the slower but much more general function
<code><a href="General_number_fields.html#se:nfhnf"
    onClick="parent.itemFrame.location='cont_General_number_fields.html'">nfhnf</a></code> can be used to intersect general &Zopf;<sub>K</sub>-modules.</p>
<p>
The library syntax is <code>GEN <b>intersect</b>(GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:matinverseimage"></div>
<div id="matinverseimage"></div>
<h4>matinverseimage(x, y)</h4>
<p>
Given a matrix x and
a column vector or matrix y, returns a preimage z of y by x if one
exists (i.e such that x z = y), an empty vector or matrix otherwise. The
complete inverse image is z + Ker x, where a basis of the kernel of
x may be obtained by <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matker"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matker</a></code>.</p>
<p>
</p><pre class="code">  ? M = [1,2;2,4];
  ? matinverseimage(M, [1,2]~)
  %2 = [1, 0]~
  ? matinverseimage(M, [3,4]~)
  %3 = []~    \\  no solution
  ? matinverseimage(M, [1,3,6;2,6,12])
  %4 =
  [1 3 6]
  
  [0 0 0]
  ? matinverseimage(M, [1,2;3,4])
  %5 = [;]    \\  no solution
  ? K = matker(M)
  %6 =
  [-2]
  
  [1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>inverseimage</b>(GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:matinvmod"></div>
<div id="matinvmod"></div>
<h4>matinvmod(x, d)</h4>
<p>
Computes a left inverse of the matrix&nbsp;x modulo&nbsp;d. The matrix x must
have <code>t_INT</code> entries, and d can be an arbitrary positive integer.</p>
<p></p>
<p>
</p><pre class="code">  ? A = [3,1,2;1,2,1;3,1,1];
  ? U = matinvmod(A,6)
  %2 =
  [1 1 3]
  
  [2 3 5]
  
  [1 0 5]
  
  ? (U*A)%6
  %3 =
  [1 0 0]
  
  [0 1 0]
  
  [0 0 1]
  ? matinvmod(A,5)
   ***   at top-level: matinvmod(A,5)
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash; --
   *** matinvmod: impossible inverse in gen_inv: 0.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>matinvmod</b>(GEN x, GEN d)</code>.</p>
<p>

<hr>
<div id="se:matisdiagonal"></div>
<div id="matisdiagonal"></div>
<h4>matisdiagonal(x)</h4>
<p>
Returns true (1) if x is a diagonal matrix, false (0) if not.</p>
<p>
The library syntax is <code>GEN <b>isdiagonal</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:matker"></div>
<div id="matker"></div>
<h4>matker(x, {<em>flag</em> = 0})</h4>
<p>
Gives a basis for the kernel of the matrix x as columns of a matrix.
The matrix can have entries of any type, provided they are compatible with
the generic arithmetic operations (+,  x  and /).</p>
<p>
If x is known to have integral entries, set <em>flag</em> = 1.</p>
<p>
The library syntax is <code>GEN <b>matker0</b>(GEN x, long flag)</code>.
Also available are <code>GEN <b>ker</b>(GEN x)</code> (<em>flag</em> = 0),
<code>GEN <b>ZM_ker</b>(GEN x)</code> (<em>flag</em> = 1).</p>
<p>

<hr>
<div id="se:matkerint"></div>
<div id="matkerint"></div>
<h4>matkerint(x, {<em>flag</em> = 0})</h4>
<p>
Gives an LLL-reduced &Zopf;-basis
for the lattice equal to the kernel of the matrix x with rational entries.</p>
<p>
<em>flag</em> is deprecated, kept for backward compatibility.</p>
<p>
The library syntax is <code>GEN <b>matkerint0</b>(GEN x, long flag)</code>.
Use directly <code>GEN <b>kerint</b>(GEN x)</code> if x is known to have
integer entries, and <code>Q_primpart</code> first otherwise.</p>
<p>

<hr>
<div id="se:matkermod"></div>
<div id="matkermod"></div>
<h4>matkermod(x, d, &<em>im</em>)</h4>
<p>
Gives a Howell basis (unique representation for submodules of&nbsp;(&Zopf;/d&Zopf;)^n,
cf. <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matimagemod"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matimagemod</a></code>) for the kernel of the matrix x modulo d as columns
of a matrix. The matrix x must have <code>t_INT</code> entries, and d can be an
arbitrary positive integer. If im is present, set it to a basis of the image
of&nbsp;x (which is computed on the way).</p>
<p></p>
<p>
</p><pre class="code">  ? A = [1,2,3;5,1,4]
  %1 =
  [1 2 3]
  
  [5 1 4]
  
  ? K = matkermod(A,6)
  %2 =
  [2 1]
  
  [2 1]
  
  [0 3]
  
  ? (A*K)%6
  %3 =
  [0 0]
  
  [0 0]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>matkermod</b>(GEN x, GEN d, GEN *im = NULL)</code>.</p>
<p>

<hr>
<div id="se:matmuldiagonal"></div>
<div id="matmuldiagonal"></div>
<h4>matmuldiagonal(x, d)</h4>
<p>
Product of the matrix x by the diagonal
matrix whose diagonal entries are those of the vector d. Equivalent to,
but much faster than x*<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:matdiagonal"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">matdiagonal</a></code>(d).</p>
<p>
The library syntax is <code>GEN <b>matmuldiagonal</b>(GEN x, GEN d)</code>.</p>
<p>

<hr>
<div id="se:matmultodiagonal"></div>
<div id="matmultodiagonal"></div>
<h4>matmultodiagonal(x, y)</h4>
<p>
Product of the matrices x and y assuming that the result is a
diagonal matrix. Much faster than x*y in that case. The result is
undefined if x*y is not diagonal.</p>
<p>
The library syntax is <code>GEN <b>matmultodiagonal</b>(GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:matpascal"></div>
<div id="matpascal"></div>
<h4>matpascal(n, {q})</h4>
<p>
Creates as a matrix the lower triangular
Pascal triangle of order x+1 (i.e.&nbsp;with binomial coefficients
up to x). If q is given, compute the q-Pascal triangle (i.e.&nbsp;using
q-binomial coefficients).</p>
<p>
The library syntax is <code>GEN <b>matqpascal</b>(long n, GEN q = NULL)</code>.
Also available is <code>GEN <b>matpascal</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:matpermanent"></div>
<div id="matpermanent"></div>
<h4>matpermanent(x)</h4>
<p>
Permanent of the square matrix x using Ryser's formula in Gray code
order.</p>
<p>
</p><pre class="code">  ? n = 20; m = matrix(n,n,i,j, i!=j);
  ? matpermanent(m)
  %2 = 895014631192902121
  ? n! * sum(i=0,n, (-1)^i/i!)
  %3 = 895014631192902121
</pre><p>
This function runs in time O(2^n n) for a matrix of size
n and is not implemented for n large.</p>
<p>
The library syntax is <code>GEN <b>matpermanent</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:matqr"></div>
<div id="matqr"></div>
<h4>matqr(M, {<em>flag</em> = 0})</h4>
<p>
Returns [Q,R], the QR-decomposition of the square invertible
matrix M with real entries: Q is orthogonal and R upper triangular. If
<em>flag</em> = 1, the orthogonal matrix is returned as a sequence of Householder
transforms: applying such a sequence is stabler and faster than
multiplication by the corresponding Q matrix.
More precisely, if</p>
<p>
</p><pre class="code">    [Q,R] = matqr(M);
    [q,r] = matqr(M, 1);
</pre><p>
then r = R and <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:mathouseholder"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">mathouseholder</a></code>(q, M) is
(close to) R; furthermore</p>
<p>
</p><pre class="code">    mathouseholder(q, matid(#M)) == Q~
</pre><p>
the inverse of Q. This function raises an error if the
precision is too low or x is singular.</p>
<p>
The library syntax is <code>GEN <b>matqr</b>(GEN M, long flag, long prec)</code>.</p>
<p>

<hr>
<div id="se:matrank"></div>
<div id="matrank"></div>
<h4>matrank(x)</h4>
<p>
Rank of the matrix x.</p>
<p>
The library syntax is <code>long <b>rank</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:matrix"></div>
<div id="matrix"></div>
<h4>matrix(m, {n = m}, {X}, {Y}, {<em>expr</em> = 0})</h4>
<p>
Creation of the
m x n matrix whose coefficients are given by the expression
<em>expr</em>. There are two formal parameters in <em>expr</em>, the first one
(X) corresponding to the rows, the second (Y) to the columns, and X
goes from 1 to m, Y goes from 1 to n. If one of the last 3 parameters
is omitted, fill the matrix with zeroes. If n is omitted, return a
square m  x m matrix.</p>
<p></p>
<p>

<hr>
<div id="se:matrixqz"></div>
<div id="matrixqz"></div>
<h4>matrixqz(A, {p = 0})</h4>
<p>
A being an m x n matrix in M<sub>m,n</sub>(&Qopf;), let
Im_&Qopf; A (resp.&nbsp;Im_&Zopf; A) the &Qopf;-vector space
(resp.&nbsp;the &Zopf;-module) spanned by the columns of A. This function has
varying behavior depending on the sign of p:</p>
<p>
If p &geq; 0, A is assumed to have maximal rank n &leq; m. The function
returns a matrix B &in;  M<sub>m,n</sub>(&Zopf;), with Im_&Qopf; B = Im_&Qopf; A,
such that the GCD of all its n x n minors is coprime to
p; in particular, if p = 0 (default), this GCD is 1.</p>
<p>
</p><pre class="code">  ? minors(x) = vector(#x[,1], i, matdet(x[^i,]));
  ? A = [3,1/7; 5,3/7; 7,5/7]; minors(A)
  %1 = [4/7, 8/7, 4/7]   \\ determinants of all 2x2 minors
  ? B = matrixqz(A)
  %2 =
  [3 1]
  
  [5 2]
  
  [7 3]
  ? minors(%)
  %3 = [1, 2, 1]   \\ B integral with coprime minors
</pre><p></p>
<p></p>
<p>
If p = -1, returns the HNF basis of the lattice &Zopf;^n &cap; Im_&Zopf; A.</p>
<p>
If p = -2, returns the HNF basis of the lattice &Zopf;^n &cap; Im_&Qopf; A.</p>
<p>
</p><pre class="code">  ? matrixqz(A,-1)
  %4 =
  [8 5]
  
  [4 3]
  
  [0 1]
  
  ? matrixqz(A,-2)
  %5 =
  [2 -1]
  
  [1 0]
  
  [0 1]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>matrixqz0</b>(GEN A, GEN p = NULL)</code>.</p>
<p>

<hr>
<div id="se:matsize"></div>
<div id="matsize"></div>
<h4>matsize(x)</h4>
<p>
x being a vector or matrix, returns a row vector
with two components, the first being the number of rows (1 for a row vector),
the second the number of columns (1 for a column vector).</p>
<p>
The library syntax is <code>GEN <b>matsize</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:matsnf"></div>
<div id="matsnf"></div>
<h4>matsnf(X, {<em>flag</em> = 0})</h4>
<p>
If X is a (singular or non-singular) matrix outputs the vector of
elementary divisors of X, i.e.&nbsp;the diagonal of the
Smith normal form of X, normalized so that d<sub>n</sub> | d<sub>n-1</sub> | 
... | d<sub>1</sub>.</p>
<p>
The binary digits of <em>flag</em> mean:</p>
<p>
1 (complete output): if set, outputs [U,V,D], where U and V are two
unimodular matrices such that UXV is the diagonal matrix D. Otherwise
output only the diagonal of D. If X is not a square matrix, then D
will be a square diagonal matrix padded with zeros on the left or the top.</p>
<p>
2 (generic input): if set, allows polynomial entries, in which case the
input matrix must be square. Otherwise, assume that X has integer
coefficients with arbitrary shape.</p>
<p>
4 (cleanup): if set, cleans up the output. This means that elementary
divisors equal to 1 will be deleted, i.e.&nbsp;outputs a shortened vector D'
instead of D. If complete output was required, returns [U',V',D'] so
that U'XV' = D' holds. If this flag is set, X is allowed to be of the
form `vector of elementary divisors' or [U,V,D] as would normally be output with the cleanup flag
unset.</p>
<p>
The library syntax is <code>GEN <b>matsnf0</b>(GEN X, long flag)</code>.</p>
<p>

<hr>
<div id="se:matsolve"></div>
<div id="matsolve"></div>
<h4>matsolve(M, B)</h4>
<p>
Let M be a left-invertible matrix and B a column vector
such that there exists a solution X to the system of linear equations
MX = B; return the (unique) solution X. This has the same effect as, but
is faster, than M<sup>-1</sup>*B. Uses Dixon p-adic lifting method if M and
B are integral and Gaussian elimination otherwise. When there is no
solution, the function returns an X such that MX - B is non-zero
although it has at least #M zero entries:</p>
<p>
</p><pre class="code">  ? M = [1,2;3,4;5,6];
  ? B = [4,6,8]~; X = matsolve(M, B)
  %2 = [-2, 3]~
  ? M*X == B
  %3 = 1
  ? B = [1,2,4]~; X = matsolve(M, [1,2,4]~)
  %4 = [0, 1/2]~
  ? M*X - B
  %5 = [0, 0, -1]~
</pre><p>
Raises an exception if M is not left-invertible, even if
there is a solution:</p>
<p>
</p><pre class="code">  ? M = [1,1;1,1]; matsolve(M, [1,1]~)
   ***   at top-level: matsolve(M,[1,1]~)
   ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; 
   *** matsolve: impossible inverse in gauss: [1, 1; 1, 1].
</pre><p>
The function also works when B is a matrix and we return
the unique matrix solution X provided it exists.</p>
<p>
The library syntax is <code>GEN <b>gauss</b>(GEN M, GEN B)</code>.
For integral input, the function
<code>GEN <b>ZM_gauss</b>(GEN M,GEN B)</code> is also available.</p>
<p>

<hr>
<div id="se:matsolvemod"></div>
<div id="matsolvemod"></div>
<h4>matsolvemod(M, D, B, {<em>flag</em> = 0})</h4>
<p>
M being any integral matrix,
D a column vector of non-negative integer moduli, and B an integral
column vector, gives an integer solution to the system of congruences
&sum;<sub>i</sub> m<sub>i,j</sub>x<sub>j</sub> = b<sub>i</sub> (mod d<sub>i</sub>) if one exists, otherwise returns
zero. Shorthand notation: B (resp.&nbsp;D) can be given as a single integer,
in which case all the b<sub>i</sub> (resp.&nbsp;d<sub>i</sub>) above are taken to be equal to B
(resp.&nbsp;D).</p>
<p>
</p><pre class="code">  ? M = [1,2;3,4];
  ? matsolvemod(M, [3,4]~, [1,2]~)
  %2 = [10, 0]~
  ? matsolvemod(M, 3, 1) \\ M X = [1,1]~ over F<sub>3</sub>
  %3 = [2, 1]~
  ? matsolvemod(M, [3,0]~, [1,2]~) \\ x + 2y = 1 (mod 3), 3x + 4y = 2 (in Z)
  %4 = [6, -4]~
</pre><p></p>
<p>
If <em>flag</em> = 1, all solutions are returned in the form of a two-component row
vector [x,u], where x is an integer solution to the system of
congruences and u is a matrix whose columns give a basis of the homogeneous
system (so that all solutions can be obtained by adding x to any linear
combination of columns of u). If no solution exists, returns zero.</p>
<p>
The library syntax is <code>GEN <b>matsolvemod</b>(GEN M, GEN D, GEN B, long flag)</code>.
Also available are <code>GEN <b>gaussmodulo</b>(GEN M, GEN D, GEN B)</code>
(<em>flag</em> = 0) and <code>GEN <b>gaussmodulo2</b>(GEN M, GEN D, GEN B)</code> (<em>flag</em> = 1).</p>
<p>

<hr>
<div id="se:matsupplement"></div>
<div id="matsupplement"></div>
<h4>matsupplement(x)</h4>
<p>
Assuming that the columns of the matrix x
are linearly independent (if they are not, an error message is issued), finds
a square invertible matrix whose first columns are the columns of x,
i.e.&nbsp;supplement the columns of x to a basis of the whole space.</p>
<p>
</p><pre class="code">  ? matsupplement([1;2])
  %1 =
  [1 0]
  
  [2 1]
</pre><p></p>
<p>
Raises an error if x has 0 columns, since (due to a long standing design
bug), the dimension of the ambient space (the number of rows) is unknown in
this case:</p>
<p>
</p><pre class="code">  ? matsupplement(matrix(2,0))
    ***   at top-level: matsupplement(matrix
    ***                 ^ &mdash;  &mdash;  &mdash;  &mdash;  &mdash;  &mdash; --
    *** matsupplement: sorry, suppl [empty matrix] is not yet implemented.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>suppl</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:mattranspose"></div>
<div id="mattranspose"></div>
<h4>mattranspose(x)</h4>
<p>
Transpose of x (also x~).
This has an effect only on vectors and matrices.</p>
<p>
The library syntax is <code>GEN <b>gtrans</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:minpoly"></div>
<div id="minpoly"></div>
<h4>minpoly(A, {v = 'x})</h4>
<p>
minimal polynomial
of A with respect to the variable v., i.e. the monic polynomial P
of minimal degree (in the variable v) such that P(A) = 0.</p>
<p>
The library syntax is <code>GEN <b>minpoly</b>(GEN A, long v = -1)</code> where <code>v</code> is a variable number.</p>
<p>

<hr>
<div id="se:norml2"></div>
<div id="norml2"></div>
<h4>norml2(x)</h4>
<p>
Square of the L^2-norm of x. More precisely,
if x is a scalar, <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:norml2"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">norml2</a></code>(x) is defined to be the square
of the complex modulus of x (real <code>t_QUAD</code>s are not supported).
If x is a polynomial, a (row or column) vector or a matrix, <code>norml2(x)</code> is
defined recursively as &sum;<sub>i</sub> <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:norml2"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">norml2</a></code>(x<sub>i</sub>), where (x<sub>i</sub>) run through
the components of x. In particular, this yields the usual &sum; |x<sub>i</sub>|^2
(resp.&nbsp;&sum; |x<sub>i,j</sub>|^2) if x is a polynomial or vector (resp.&nbsp;matrix) with
complex components.</p>
<p></p>
<p>
</p><pre class="code">  ? norml2( [ 1, 2, 3 ] )      \\ vector
  %1 = 14
  ? norml2( [ 1, 2; 3, 4] )   \\ matrix
  %2 = 30
  ? norml2( 2*I + x )
  %3 = 5
  ? norml2( [ [1,2], [3,4], 5, 6 ] )   \\ recursively defined
  %4 = 91
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>gnorml2</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:normlp"></div>
<div id="normlp"></div>
<h4>normlp(x, {p = <em>oo</em>})</h4>
<p>
L^p-norm of x; sup norm if p is omitted or <code>+oo</code>. More precisely,
if x is a scalar, <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:normlp"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">normlp</a></code>(x, p) is defined to be <code><a href="Transcendental_functions.html#se:abs"
    onClick="parent.itemFrame.location='cont_Transcendental_functions.html'">abs</a></code>(x).
If x is a polynomial, a (row or column) vector or a matrix:</p>
<p>
<b>*</b>  if p is omitted or <code>+oo</code>, then <code>normlp(x)</code> is defined
recursively as max<sub>i</sub> <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:normlp"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">normlp</a></code>(x<sub>i</sub>)), where (x<sub>i</sub>) run through the
components of&nbsp;x. In particular, this yields the usual sup norm if x is a
polynomial or vector with complex components.</p>
<p>
<b>*</b> otherwise, <code>normlp(x, p)</code> is defined recursively as (&sum;<sub>i</sub>
<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:normlp"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">normlp</a></code>^p(x<sub>i</sub>,p))<sup>1/p</sup>. In particular, this yields the usual (&sum;
|x<sub>i</sub>|^p)<sup>1/p</sup> if x is a polynomial or vector with complex components.</p>
<p></p>
<p>
</p><pre class="code">  ? v = [1,-2,3]; normlp(v)      \\ vector
  %1 = 3
  ? normlp(v, +oo)               \\ same, more explicit
  %2 = 3
  ? M = [1,-2;-3,4]; normlp(M)   \\ matrix
  %3 = 4
  ? T = (1+I) + I*x^2; normlp(T)
  %4 = 1.4142135623730950488016887242096980786
  ? normlp([[1,2], [3,4], 5, 6])   \\ recursively defined
  %5 = 6
  
  ? normlp(v, 1)
  %6 = 6
  ? normlp(M, 1)
  %7 = 10
  ? normlp(T, 1)
  %8 = 2.4142135623730950488016887242096980786
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>gnormlp</b>(GEN x, GEN p = NULL, long prec)</code>.</p>
<p>

<hr>
<div id="se:qfauto"></div>
<div id="qfauto"></div>
<h4>qfauto(G, {<em>fl</em>})</h4>
<p>
G being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, outputs the automorphism group of the
associate lattice.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows. G can also be given by an
<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfisominit"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfisominit</a></code> structure.
See <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfisominit"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfisominit</a></code> for the meaning of <em>fl</em>.</p>
<p>
The output is a two-components vector [o,g] where o is the group order
and g is the list of generators (as a vector). For each generator H,
the equality G = {^t}H G H holds.</p>
<p>
The interface of this function is experimental and will likely change in the
future.</p>
<p>
This function implements an algorithm of Plesken and Souvignier, following
Souvignier's implementation.</p>
<p>
The library syntax is <code>GEN <b>qfauto0</b>(GEN G, GEN fl = NULL)</code>.
The function <code>GEN <b>qfauto</b>(GEN G, GEN fl)</code> is also available
where G is a vector of <code>zm</code> matrices.</p>
<p>

<hr>
<div id="se:qfautoexport"></div>
<div id="qfautoexport"></div>
<h4>qfautoexport(<em>qfa</em>, {<em>flag</em>})</h4>
<p>
<em>qfa</em> being an automorphism group as output by
<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfauto"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfauto</a></code>, export the underlying matrix group as a string suitable
for (no flags or <em>flag</em> = 0) GAP or (<em>flag</em> = 1) Magma. The following example
computes the size of the matrix group using GAP:</p>
<p>
</p><pre class="code">  ? G = qfauto([2,1;1,2])
  %1 = [12, [[-1, 0; 0, -1], [0, -1; 1, 1], [1, 1; 0, -1]]]
  ? s = qfautoexport(G)
  %2 = "Group([[-1, 0], [0, -1]], [[0, -1], [1, 1]], [[1, 1], [0, -1]])"
  ? extern("echo \"Order("s");\" | gap -q")
  %3 = 12
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>qfautoexport</b>(GEN qfa, long flag)</code>.</p>
<p>

<hr>
<div id="se:qfbil"></div>
<div id="qfbil"></div>
<h4>qfbil(x, y, {q})</h4>
<p>
This function is obsolete, use <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfeval"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfeval</a></code>.</p>
<p>
The library syntax is <code>GEN <b>qfbil</b>(GEN x, GEN y, GEN q = NULL)</code>.</p>
<p>

<hr>
<div id="se:qfeval"></div>
<div id="qfeval"></div>
<h4>qfeval({q}, x, {y})</h4>
<p>
Evaluate the quadratic form q (given by a symmetric matrix)
at the vector x; if y is present, evaluate the polar form at (x,y);
if q omitted, use the standard Euclidean scalar product, corresponding to
the identity matrix.</p>
<p>
Roughly equivalent to <code>x~ * q * y</code>, but a little faster and
more convenient (does not distinguish between column and row vectors):</p>
<p>
</p><pre class="code">  ? x = [1,2,3]~; y = [-1,3,1]~; q = [1,2,3;2,2,-1;3,-1,9];
  ? qfeval(q,x,y)
  %2 = 23
  ? for(i=1,10^6, qfeval(q,x,y))
  time = 661ms
  ? for(i=1,10^6, x~*q*y)
  time = 697ms
</pre><p>
The speedup is noticeable for the quadratic form,
compared to <code>x~ * q * x</code>, since we save almost half the
operations:</p>
<p>
</p><pre class="code">  ? for(i=1,10^6, qfeval(q,x))
  time = 487ms
</pre><p>
The special case q = Id is handled faster if we
omit q altogether:</p>
<p>
</p><pre class="code">  ? qfeval(,x,y)
  %6 = 8
  ? q = matid(#x);
  ? for(i=1,10^6, qfeval(q,x,y))
  time = 529 ms.
  ? for(i=1,10^6, qfeval(,x,y))
  time = 228 ms.
  ? for(i=1,10^6, x~*y)
  time = 274 ms.
</pre><p></p>
<p></p>
<p>
We also allow <code>t_MAT</code>s of compatible dimensions for x,
and return <code>x~ * q * x</code> in this case as well:</p>
<p>
</p><pre class="code">  ? M = [1,2,3;4,5,6;7,8,9]; qfeval(,M) \\ Gram matrix
  %5 =
  [66  78  90]
  
  [78  93 108]
  
  [90 108 126]
  
  ? q = [1,2,3;2,2,-1;3,-1,9];
  ? for(i=1,10^6, qfeval(q,M))
  time = 2,008 ms.
  ? for(i=1,10^6, M~*q*M)
  time = 2,368 ms.
  
  ? for(i=1,10^6, qfeval(,M))
  time = 1,053 ms.
  ? for(i=1,10^6, M~*M)
  time = 1,171 ms.
</pre><p></p>
<p></p>
<p>
If q is a <code>t_QFI</code> or <code>t_QFR</code>, it is implicitly converted to the
attached symmetric <code>t_MAT</code>. This is done more
efficiently than by direct conversion, since we avoid introducing a
denominator 2 and rational arithmetic:</p>
<p>
</p><pre class="code">  ? q = Qfb(2,3,4); x = [2,3];
  ? qfeval(q, x)
  %2 = 62
  ? Q = Mat(q)
  %3 =
   [  2 3/2]
  
   [3/2   4]
  ? qfeval(Q, x)
  %4 = 62
  ? for (i=1, 10^6, qfeval(q,x))
  time = 758 ms.
  ? for (i=1, 10^6, qfeval(Q,x))
  time = 1,110 ms.
</pre><p></p>
<p>
Finally, when x is a <code>t_MAT</code> with <em>integral</em> coefficients, we allow
a <code>t_QFI</code> or <code>t_QFR</code> for q and return the binary
quadratic form q o M. Again, the conversion to <code>t_MAT</code> is less
efficient in this case:</p>
<p>
</p><pre class="code">  ? q = Qfb(2,3,4); Q = Mat(q); x = [1,2;3,4];
  ? qfeval(q, x)
  %2 = Qfb(47, 134, 96)
  ? qfeval(Q,x)
  %3 =
  [47 67]
  
  [67 96]
  ? for (i=1, 10^6, qfeval(q,x))
  time = 701 ms.
  ? for (i=1, 10^6, qfeval(Q,x))
  time = 1,639 ms.
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>qfeval0</b>(GEN q = NULL, GEN x, GEN y = NULL)</code>.</p>
<p>

<hr>
<div id="se:qfgaussred"></div>
<div id="qfgaussred"></div>
<h4>qfgaussred(q)</h4>
<p>
decomposition into squares of the
quadratic form represented by the symmetric matrix q. The result is a
matrix whose diagonal entries are the coefficients of the squares, and the
off-diagonal entries on each line represent the bilinear forms. More
precisely, if (a<sub>ij</sub>) denotes the output, one has
 q(x) = &sum;<sub>i</sub> a<sub>ii</sub> (x<sub>i</sub> + &sum;<sub>j != i</sub> a<sub>ij</sub> x<sub>j</sub>)^2 </p>
<p>
</p><pre class="code">  ? qfgaussred([0,1;1,0])
  %1 =
  [1/2 1]
  
  [-1 -1/2]
</pre><p>
This means that 2xy = (1/2)(x+y)^2 - (1/2)(x-y)^2.
Singular matrices are supported, in which case some diagonal coefficients
will vanish:</p>
<p>
</p><pre class="code">  ? qfgaussred([1,1;1,1])
  %1 =
  [1 1]
  
  [1 0]
</pre><p>
This means that x^2 + 2xy + y^2 = (x+y)^2.</p>
<p>
The library syntax is <code>GEN <b>qfgaussred</b>(GEN q)</code>.
<code>GEN <b>qfgaussred_positive</b>(GEN q)</code> assumes that q is
 positive definite and is a little faster; returns <code>NULL</code> if a vector
 with negative norm occurs (non positive matrix or too many rounding errors).</p>
<p>

<hr>
<div id="se:qfisom"></div>
<div id="qfisom"></div>
<h4>qfisom(G, H, {<em>fl</em>}, {<em>grp</em>})</h4>
<p>
G, H being square and symmetric matrices with integer entries representing
positive definite quadratic forms, return an invertible matrix S such that
G = {^t}S H S. This defines a isomorphism between the corresponding lattices.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows.
See <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfisominit"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfisominit</a></code> for the meaning of <em>fl</em>.
If <em>grp</em> is given it must be the automorphism group of H. It will be used
to speed up the computation.</p>
<p>
G can also be given by an <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfisominit"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfisominit</a></code> structure which is preferable if
several forms H need to be compared to G.</p>
<p>
This function implements an algorithm of Plesken and Souvignier, following
Souvignier's implementation.</p>
<p>
The library syntax is <code>GEN <b>qfisom0</b>(GEN G, GEN H, GEN fl = NULL, GEN grp = NULL)</code>.
Also available is <code>GEN <b>qfisom</b>(GEN G, GEN H, GEN fl, GEN grp)</code>
where G is a vector of <code>zm</code>, and H is a <code>zm</code>, and grp is
either <code>NULL</code> or a vector of <code>zm</code>.</p>
<p>

<hr>
<div id="se:qfisominit"></div>
<div id="qfisominit"></div>
<h4>qfisominit(G, {<em>fl</em>}, {m})</h4>
<p>
G being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, return an <code>isom</code> structure allowing to
compute isomorphisms between G and other quadratic forms faster.</p>
<p>
The interface of this function is experimental and will likely change in future
release.</p>
<p>
If present, the optional parameter <em>fl</em> must be a <code>t_VEC</code> with two
components. It allows to specify the invariants used, which can make the
computation faster or slower. The components are</p>
<p>
<b>*</b> <code>fl[1]</code> Depth of scalar product combination to use.</p>
<p>
<b>*</b> <code>fl[2]</code> Maximum level of Bacher polynomials to use.</p>
<p>
If present, m must be the set of vectors of norm up to the maximal of the
diagonal entry of G, either as a matrix or as given by <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfminim"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfminim</a></code>.
Otherwise this function computes the minimal vectors so it become very
lengthy as the dimension of G grows.</p>
<p>
The library syntax is <code>GEN <b>qfisominit0</b>(GEN G, GEN fl = NULL, GEN m = NULL)</code>.
Also available is
<code>GEN <b>qfisominit</b>(GEN F, GEN fl)</code>
where F is a vector of <code>zm</code>.</p>
<p>

<hr>
<div id="se:qfjacobi"></div>
<div id="qfjacobi"></div>
<h4>qfjacobi(A)</h4>
<p>
Apply Jacobi's eigenvalue algorithm to the real symmetric matrix A.
This returns [L, V], where</p>
<p>
<b>*</b> L is the vector of (real) eigenvalues of A, sorted in increasing
order,</p>
<p>
<b>*</b> V is the corresponding orthogonal matrix of eigenvectors of A.</p>
<p></p>
<p>
</p><pre class="code">  ? \p19
  ? A = [1,2;2,1]; mateigen(A)
  %1 =
  [-1 1]
  
  [ 1 1]
  ? [L, H] = qfjacobi(A);
  ? L
  %3 = [-1.000000000000000000, 3.000000000000000000]~
  ? H
  %4 =
  [ 0.7071067811865475245 0.7071067811865475244]
  
  [-0.7071067811865475244 0.7071067811865475245]
  ? norml2( (A-L[1])*H[,1] )       \\ approximate eigenvector
  %5 = 9.403954806578300064 E-38
  ? norml2(H*H~ - 1)
  %6 = 2.350988701644575016 E-38   \\ close to orthogonal
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>jacobi</b>(GEN A, long prec)</code>.</p>
<p>

<hr>
<div id="se:qflll"></div>
<div id="qflll"></div>
<h4>qflll(x, {<em>flag</em> = 0})</h4>
<p>
LLL algorithm applied to the
<em>columns</em> of the matrix x. The columns of x may be linearly
dependent. The result is a unimodular transformation matrix T such that x
.T is an LLL-reduced basis of the lattice generated by the column
vectors of x. Note that if x is not of maximal rank T will not be
square. The LLL parameters are (0.51,0.99), meaning that the Gram-Schmidt
coefficients for the final basis satisfy |&mu;<sub>i,j</sub>| &leq; 0.51, and the
Lov@[aacute]sz's constant is 0.99.</p>
<p>
If <em>flag</em> = 0 (default), assume that x has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in <em>flag</em> = 1.</p>
<p>
If <em>flag</em> = 1, assume that x is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer's trick,
as generalized by Schnorr). Adapted from Nguyen and Stehl&eacute;'s algorithm
and Stehl&eacute;'s code (<code>fplll-1.3</code>).</p>
<p>
If <em>flag</em> = 2, x should be an integer matrix whose columns are linearly
independent. Returns a partially reduced basis for x, using an unpublished
algorithm by Peter Montgomery: a basis is said to be <em>partially reduced</em>
if |v<sub>i</sub> &#177; v<sub>j</sub>| &geq; |v<sub>i</sub>| for any two distinct basis vectors v<sub>i</sub>, 
v<sub>j</sub>.</p>
<p>
This is faster than <em>flag</em> = 1, esp. when one row is huge compared
to the other rows (knapsack-style), and should quickly produce relatively
short vectors. The resulting basis is <em>not</em> LLL-reduced in general.
If LLL reduction is eventually desired, avoid this partial reduction:
applying LLL to the partially reduced matrix is significantly <em>slower</em>
than starting from a knapsack-type lattice.</p>
<p>
If <em>flag</em> = 4, as <em>flag</em> = 1, returning a vector [K, T] of matrices: the
columns of K represent a basis of the integer kernel of x
(not LLL-reduced in general) and T is the transformation
matrix such that x.T is an LLL-reduced &Zopf;-basis of the image
of the matrix x.</p>
<p>
If <em>flag</em> = 5, case as case 4, but x may have polynomial coefficients.</p>
<p>
If <em>flag</em> = 8, same as case 0, but x may have polynomial coefficients.</p>
<p>
The library syntax is <code>GEN <b>qflll0</b>(GEN x, long flag)</code>.
Also available are <code>GEN <b>lll</b>(GEN x)</code> (<em>flag</em> = 0),
<code>GEN <b>lllint</b>(GEN x)</code> (<em>flag</em> = 1), and <code>GEN <b>lllkerim</b>(GEN x)</code> (<em>flag</em> = 4).</p>
<p>

<hr>
<div id="se:qflllgram"></div>
<div id="qflllgram"></div>
<h4>qflllgram(G, {<em>flag</em> = 0})</h4>
<p>
Same as <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qflll"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qflll</a></code>, except that the
matrix G = <code>x~ * x</code> is the Gram matrix of some lattice vectors x,
and not the coordinates of the vectors themselves. In particular, G must
now be a square symmetric real matrix, corresponding to a positive
quadratic form (not necessarily definite: x needs not have maximal rank).
The result is a unimodular
transformation matrix T such that x.T is an LLL-reduced basis of
the lattice generated by the column vectors of x. See <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qflll"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qflll</a></code> for
further details about the LLL implementation.</p>
<p>
If <em>flag</em> = 0 (default), assume that G has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in <em>flag</em> = 1.</p>
<p>
If <em>flag</em> = 1, assume that G is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer's trick,
as generalized by Schnorr). Adapted from Nguyen and Stehl&eacute;'s algorithm
and Stehl&eacute;'s code (<code>fplll-1.3</code>).</p>
<p>
<em>flag</em> = 4: G has integer entries, gives the kernel and reduced image of x.</p>
<p>
<em>flag</em> = 5: same as 4, but G may have polynomial coefficients.</p>
<p>
The library syntax is <code>GEN <b>qflllgram0</b>(GEN G, long flag)</code>.
Also available are <code>GEN <b>lllgram</b>(GEN G)</code> (<em>flag</em> = 0),
<code>GEN <b>lllgramint</b>(GEN G)</code> (<em>flag</em> = 1), and <code>GEN <b>lllgramkerim</b>(GEN G)</code>
(<em>flag</em> = 4).</p>
<p>

<hr>
<div id="se:qfminim"></div>
<div id="qfminim"></div>
<h4>qfminim(x, {b}, {m}, {<em>flag</em> = 0})</h4>
<p>
x being a square and symmetric matrix representing a positive definite
quadratic form, this function deals with the vectors of x whose norm is
less than or equal to b, enumerated using the Fincke-Pohst algorithm,
storing at most m vectors (no limit if m is omitted). The function
searches for the minimal non-zero vectors if b is omitted. The behavior is
undefined if x is not positive definite (a "precision too low" error is
most likely, although more precise error messages are possible). The precise
behavior depends on <em>flag</em>.</p>
<p>
If <em>flag</em> = 0 (default), returns at most 2m vectors. The result is a
three-component vector, the first component being the number of vectors
enumerated (which may be larger than 2m), the second being the maximum
norm found, and the last vector
is a matrix whose columns are found vectors, only one being given for each
pair &#177; v (at most m such pairs, unless m was omitted). The vectors
are returned in no particular order.</p>
<p>
If <em>flag</em> = 1, ignores m and returns [N,v], where v is a non-zero vector
of length N &leq; b, or [] if no non-zero vector has length  &leq; b.
If no explicit b is provided, return a vector of smallish norm
(smallest vector in an LLL-reduced basis).</p>
<p>
In these two cases, x must have <em>integral</em> entries. The
implementation uses low precision floating point computations for maximal
speed, which gives incorrect result when x has large entries. (The
condition is checked in the code and the routine raises an error if
large rounding errors occur.) A more robust, but much slower,
implementation is chosen if the following flag is used:</p>
<p>
If <em>flag</em> = 2, x can have non integral real entries. In this case, if b
is omitted, the "minimal" vectors only have approximately the same norm.
If b is omitted, m is an upper bound for the number of vectors that
will be stored and returned, but all minimal vectors are nevertheless
enumerated. If m is omitted, all vectors found are stored and returned;
note that this may be a huge vector!</p>
<p></p>
<p>
</p><pre class="code">  ? x = matid(2);
  ? qfminim(x)  \\  4 minimal vectors of norm 1: &#177;[0,1], &#177;[1,0]
  %2 = [4, 1, [0, 1; 1, 0]]
  ? { x =
  [4, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1, 0,-1, 0, 0, 0,-2;
   2, 4,-2,-2, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1, 0, 1,-1,-1;
   0,-2, 4, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 0, 1,-1,-1, 0, 0;
   0,-2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1,-1, 0, 1,-1, 1, 0;
   0, 0,-2, 0, 4, 0, 0, 0, 1,-1, 0, 0, 1, 0, 0, 0,-2, 0, 0,-1, 1, 1, 0, 0;
  -2, -2,0, 0, 0, 4,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,-1, 1, 1;
   0, 0, 0, 0, 0,-2, 4,-2, 0, 0, 0, 0, 0, 1, 0, 0, 0,-1, 0, 0, 0, 1,-1, 0;
   0, 0, 0, 0, 0, 0,-2, 4, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1,-1,-1, 0, 1, 0;
   0, 0, 0, 0, 1,-1, 0, 0, 4, 0,-2, 0, 1, 1, 0,-1, 0, 1, 0, 0, 0, 0, 0, 0;
   0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 0, 0, 1, 1,-1, 1, 0, 0, 0, 1, 0, 0, 1, 0;
   0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 4,-2, 0,-1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0;
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 4,-1, 1, 0, 0,-1, 1, 0, 1, 1, 1,-1, 0;
   1, 0,-1, 1, 1, 0, 0,-1, 1, 1, 0,-1, 4, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1,-1;
  -1,-1, 1,-1, 0, 0, 1, 0, 1, 1,-1, 1, 0, 4, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1;
   0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 1, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0;
   0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 1, 0, 4, 0, 0, 0, 0, 1, 1, 0, 0;
   0, 0, 1, 0,-2, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 1, 1, 1, 0, 0, 1, 1;
   1, 0, 0, 1, 0, 0,-1, 0, 1, 0,-1, 1, 1, 0, 0, 0, 1, 4, 0, 1, 1, 0, 1, 0;
   0, 0, 0,-1, 0, 1, 0,-1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 4, 0, 1, 1, 0, 1;
  -1, -1,1, 0,-1, 1, 0,-1, 0, 1,-1, 1, 0, 1, 0, 0, 1, 1, 0, 4, 0, 0, 1, 1;
   0, 0,-1, 1, 1, 0, 0,-1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 4, 1, 0, 1;
   0, 1,-1,-1, 1,-1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 4, 0, 1;
   0,-1, 0, 1, 0, 1,-1, 1, 0, 1, 0,-1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 4, 1;
  -2,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 4]; }
  ? qfminim(x,,0)  \\ the Leech lattice has 196560 minimal vectors of norm 4
  time = 648 ms.
  %4 = [196560, 4, [;]]
  ? qfminim(x,,0,2); \\ safe algorithm. Slower and unnecessary here.
  time = 18,161 ms.
  %5 = [196560, 4.000061035156250000, [;]]
</pre><p></p>
<p>
In the last example, we store 0 vectors to limit memory use. All minimal
vectors are nevertheless enumerated. Provided <code>parisize</code> is about 50MB,
<code>qfminim(x)</code> succeeds in 2.5 seconds.</p>
<p>
The library syntax is <code>GEN <b>qfminim0</b>(GEN x, GEN b = NULL, GEN m = NULL, long flag, long prec)</code>.
Also available are
<code>GEN <b>minim</b>(GEN x, GEN b = NULL, GEN m = NULL)</code> (<em>flag</em> = 0),
<code>GEN <b>minim2</b>(GEN x, GEN b = NULL, GEN m = NULL)</code> (<em>flag</em> = 1).
<code>GEN <b>minim_raw</b>(GEN x, GEN b = NULL, GEN m = NULL)</code> (do not perform LLL
reduction on x and return <code>NULL</code> on accuracy error).</p>
<p>

<hr>
<div id="se:qfnorm"></div>
<div id="qfnorm"></div>
<h4>qfnorm(x, {q})</h4>
<p>
This function is obsolete, use <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfeval"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfeval</a></code>.</p>
<p>
The library syntax is <code>GEN <b>qfnorm</b>(GEN x, GEN q = NULL)</code>.</p>
<p>

<hr>
<div id="se:qforbits"></div>
<div id="qforbits"></div>
<h4>qforbits(G, V)</h4>
<p>
Return the orbits of V under the action of the group
of linear transformation generated by the set G.
It is assumed that G contains minus identity, and only one vector
in {v, -v} should be given.
If G does not stabilize V, the function return 0.</p>
<p>
In the example below, we compute representatives and lengths of the orbits of
the vectors of norm  &leq; 3 under the automorphisms of the lattice A<sub>1</sub>^6.</p>
<p>
</p><pre class="code">  ?  Q=matid(6); G=qfauto(Q); V=qfminim(Q,3);
  ?  apply(x-&gt;[x[1],#x],qforbits(G,V))
  %2 = [[[0,0,0,0,0,1]~,6],[[0,0,0,0,1,-1]~,30],[[0,0,0,1,-1,-1]~,80]]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>qforbits</b>(GEN G, GEN V)</code>.</p>
<p>

<hr>
<div id="se:qfparam"></div>
<div id="qfparam"></div>
<h4>qfparam(G, <em>sol</em>, {<em>flag</em> = 0})</h4>
<p>
Coefficients of binary quadratic forms that parametrize the
solutions of the ternary quadratic form G, using the particular
solution&nbsp;<em>sol</em>.
<em>flag</em> is optional and can be 1, 2, or 3, in which case the <em>flag</em>-th form is
reduced. The default is <em>flag</em> = 0 (no reduction).</p>
<p>
</p><pre class="code">  ? G = [1,0,0;0,1,0;0,0,-34];
  ? M = qfparam(G, qfsolve(G))
  %2 =
  [ 3 -10 -3]
  
  [-5  -6  5]
  
  [ 1   0  1]
</pre><p></p>
<p>
Indeed, the solutions can be parametrized as
(3x^2 - 10xy - 3y^2)^2  + (-5x^2 - 6xy + 5y^2)^2 -34(x^2 + y^2)^2 = 0.</p>
<p>
</p><pre class="code">  ? v = y^2 * M*[1,x/y,(x/y)^2]~
  %3 = [3*x^2 - 10*y*x - 3*y^2, -5*x^2 - 6*y*x + 5*y^2, -x^2 - y^2]~
  ? v~*G*v
  %4 = 0
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>qfparam</b>(GEN G, GEN sol, long flag)</code>.</p>
<p>

<hr>
<div id="se:qfperfection"></div>
<div id="qfperfection"></div>
<h4>qfperfection(G)</h4>
<p>
G being a square and symmetric matrix with
integer entries representing a positive definite quadratic form, outputs the
perfection rank of the form. That is, gives the rank of the family of the s
symmetric matrices v_iv<sub>i</sub>^t, where s is half the number of minimal
vectors and the v<sub>i</sub> (1 &leq; i &leq; s) are the minimal vectors.</p>
<p>
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension of x grows.</p>
<p>
The library syntax is <code>GEN <b>perf</b>(GEN G)</code>.</p>
<p>

<hr>
<div id="se:qfrep"></div>
<div id="qfrep"></div>
<h4>qfrep(q, B, {<em>flag</em> = 0})</h4>
<p>
q being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, count the vectors representing successive
integers.</p>
<p>
<b>*</b> If <em>flag</em> = 0, count all vectors. Outputs the vector whose i-th
entry, 1 &leq; i &leq; B is half the number of vectors v such that q(v) = i.</p>
<p>
<b>*</b> If <em>flag</em> = 1, count vectors of even norm. Outputs the vector
whose i-th entry, 1 &leq; i &leq; B is half the number of vectors such
that q(v) = 2i.</p>
<p></p>
<p>
</p><pre class="code">  ? q = [2, 1; 1, 3];
  ? qfrep(q, 5)
  %2 = Vecsmall([0, 1, 2, 0, 0]) \\ 1 vector of norm 2, 2 of norm 3, etc.
  ? qfrep(q, 5, 1)
  %3 = Vecsmall([1, 0, 0, 1, 0]) \\ 1 vector of norm 2, 0 of norm 4, etc.
</pre><p></p>
<p>
This routine uses a naive algorithm based on <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:qfminim"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">qfminim</a></code>, and
will fail if any entry becomes larger than 2<sup>31</sup> (or 2<sup>63</sup>).</p>
<p>
The library syntax is <code>GEN <b>qfrep0</b>(GEN q, GEN B, long flag)</code>.</p>
<p>

<hr>
<div id="se:qfsign"></div>
<div id="qfsign"></div>
<h4>qfsign(x)</h4>
<p>
Returns [p,m] the signature of the quadratic form represented by the
symmetric matrix x. Namely, p (resp.&nbsp;m) is the number of positive
(resp.&nbsp;negative) eigenvalues of x. The result is computed using Gaussian
reduction.</p>
<p>
The library syntax is <code>GEN <b>qfsign</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:qfsolve"></div>
<div id="qfsolve"></div>
<h4>qfsolve(G)</h4>
<p>
Given a square symmetric matrix G of dimension n &geq; 1, solve over
&Qopf; the quadratic equation X^tGX = 0. The matrix G must have rational
coefficients. The solution might be a single non-zero vector (vectorv) or a
matrix (whose columns generate a totally isotropic subspace).</p>
<p>
If no solution exists, returns an integer, that can be a prime p such that
there is no local solution at p, or -1 if there is no real solution,
or -2 if n = 2 and -det G is positive but not a square (which implies
there is a real solution, but no local solution at some p dividing det G).</p>
<p>
</p><pre class="code">  ? G = [1,0,0;0,1,0;0,0,-34];
  ? qfsolve(G)
  %1 = [-3, -5, 1]~
  ? qfsolve([1,0; 0,2])
  %2 = -1   \\ no real solution
  ? qfsolve([1,0,0;0,3,0; 0,0,-2])
  %3 = 3    \\ no solution in Q<sub>3</sub>
  ? qfsolve([1,0; 0,-2])
  %4 = -2   \\ no solution, n = 2
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>qfsolve</b>(GEN G)</code>.</p>
<p>

<hr>
<div id="se:seralgdep"></div>
<div id="seralgdep"></div>
<h4>seralgdep(s, p, r)</h4>
<p>
 finds a linear relation between powers (1,s,
..., s^p) of the series s, with polynomial coefficients of degree
 &leq; r. In case no relation is found, return 0.</p>
<p>
</p><pre class="code">  ? s = 1 + 10*y - 46*y^2 + 460*y^3 - 5658*y^4 + 77740*y^5 + O(y^6);
  ? seralgdep(s, 2, 2)
  %2 = -x^2 + (8*y^2 + 20*y + 1)
  ? subst(%, x, s)
  %3 = O(y^6)
  ? seralgdep(s, 1, 3)
  %4 = (-77*y^2 - 20*y - 1)*x + (310*y^3 + 231*y^2 + 30*y + 1)
  ? seralgdep(s, 1, 2)
  %5 = 0
</pre><p>
The series main variable must not be x, so as to be able
to express the result as a polynomial in x.</p>
<p>
The library syntax is <code>GEN <b>seralgdep</b>(GEN s, long p, long r)</code>.</p>
<p>

<hr>
<div id="se:setbinop"></div>
<div id="setbinop"></div>
<h4>setbinop(f, X, {Y})</h4>
<p>
The set whose elements are the f(x,y), where x,y run through X,Y.
respectively. If Y is omitted, assume that X = Y and that f is symmetric:
f(x,y) = f(y,x) for all x,y in X.</p>
<p>
</p><pre class="code">  ? X = [1,2,3]; Y = [2,3,4];
  ? setbinop((x,y)-&gt;x+y, X,Y) \\ set X + Y
  %2 = [3, 4, 5, 6, 7]
  ? setbinop((x,y)-&gt;x-y, X,Y) \\ set X - Y
  %3 = [-3, -2, -1, 0, 1]
  ? setbinop((x,y)-&gt;x+y, X)   \\ set 2X = X + X
  %2 = [2, 3, 4, 5, 6]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>setbinop</b>(GEN f, GEN X, GEN Y = NULL)</code>.</p>
<p>

<hr>
<div id="se:setintersect"></div>
<div id="setintersect"></div>
<h4>setintersect(x, y)</h4>
<p>
Intersection of the two sets x and y (see <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:setisset"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">setisset</a></code>).
If x or y is not a set, the result is undefined.</p>
<p>
The library syntax is <code>GEN <b>setintersect</b>(GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:setisset"></div>
<div id="setisset"></div>
<h4>setisset(x)</h4>
<p>
Returns true (1) if x is a set, false (0) if
not. In PARI, a set is a row vector whose entries are strictly
increasing with respect to a (somewhat arbitrary) universal comparison
function. To convert any object into a set (this is most useful for
vectors, of course), use the function <code><a href="Conversions_and_similar_elementary_functions_or_commands.html#se:Set"
    onClick="parent.itemFrame.location='cont_Conversions_and_similar_elementary_functions_or_commands.html'">Set</a></code>.</p>
<p>
</p><pre class="code">  ? a = [3, 1, 1, 2];
  ? setisset(a)
  %2 = 0
  ? Set(a)
  %3 = [1, 2, 3]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>setisset</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:setminus"></div>
<div id="setminus"></div>
<h4>setminus(x, y)</h4>
<p>
Difference of the two sets x and y (see <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:setisset"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">setisset</a></code>),
i.e.&nbsp;set of elements of x which do not belong to y.
If x or y is not a set, the result is undefined.</p>
<p>
The library syntax is <code>GEN <b>setminus</b>(GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:setsearch"></div>
<div id="setsearch"></div>
<h4>setsearch(S, x, {<em>flag</em> = 0})</h4>
<p>
Determines whether x belongs to the set S (see <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:setisset"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">setisset</a></code>).</p>
<p>
We first describe the default behavior, when <em>flag</em> is zero or omitted. If x
belongs to the set S, returns the index j such that S[j] = x, otherwise
returns 0.</p>
<p>
</p><pre class="code">  ? T = [7,2,3,5]; S = Set(T);
  ? setsearch(S, 2)
  %2 = 1
  ? setsearch(S, 4)      \\ not found
  %3 = 0
  ? setsearch(T, 7)      \\ search in a randomly sorted vector
  %4 = 0 \\ WRONG !
</pre><p></p>
<p>
If S is not a set, we also allow sorted lists with
respect to the <code><a href="Standard_monadic_or_dyadic_operators.html#se:cmp"
    onClick="parent.itemFrame.location='cont_Standard_monadic_or_dyadic_operators.html'">cmp</a></code> sorting function, without repeated entries,
as per <code><a href="Programming_in_GP__other_specific_functions.html#se:listsort"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__other_specific_functions.html'">listsort</a></code>(L,1); otherwise the result is undefined.</p>
<p>
</p><pre class="code">  ? L = List([1,4,2,3,2]); setsearch(L, 4)
  %1 = 0 \\ WRONG !
  ? listsort(L, 1); L    \\ sort L first
  %2 = List([1, 2, 3, 4])
  ? setsearch(L, 4)
  %3 = 4                 \\ now correct
</pre><p></p>
<p>
If <em>flag</em> is non-zero, this function returns the index j where x should be
inserted, and 0 if it already belongs to S. This is meant to be used for
dynamically growing (sorted) lists, in conjunction with <code><a href="Programming_in_GP__other_specific_functions.html#se:listinsert"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__other_specific_functions.html'">listinsert</a></code>.</p>
<p>
</p><pre class="code">  ? L = List([1,5,2,3,2]); listsort(L,1); L
  %1 = List([1,2,3,5])
  ? j = setsearch(L, 4, 1)  \\ 4 should have been inserted at index j
  %2 = 4
  ? listinsert(L, 4, j); L
  %3 = List([1, 2, 3, 4, 5])
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>setsearch</b>(GEN S, GEN x, long flag)</code>.</p>
<p>

<hr>
<div id="se:setunion"></div>
<div id="setunion"></div>
<h4>setunion(x, y)</h4>
<p>
Union of the two sets x and y (see <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:setisset"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">setisset</a></code>).
If x or y is not a set, the result is undefined.</p>
<p>
The library syntax is <code>GEN <b>setunion</b>(GEN x, GEN y)</code>.</p>
<p>

<hr>
<div id="se:trace"></div>
<div id="trace"></div>
<h4>trace(x)</h4>
<p>
This applies to quite general x. If x is not a
matrix, it is equal to the sum of x and its conjugate, except for polmods
where it is the trace as an algebraic number.</p>
<p>
For x a square matrix, it is the ordinary trace. If x is a
non-square matrix (but not a vector), an error occurs.</p>
<p>
The library syntax is <code>GEN <b>gtrace</b>(GEN x)</code>.</p>
<p>

<hr>
<div id="se:vecextract"></div>
<div id="vecextract"></div>
<h4>vecextract(x, y, {z})</h4>
<p>
Extraction of components of the vector or matrix x according to y.
In case x is a matrix, its components are the <em>columns</em> of x. The
parameter y is a component specifier, which is either an integer, a string
describing a range, or a vector.</p>
<p>
If y is an integer, it is considered as a mask: the binary bits of y are
read from right to left, but correspond to taking the components from left to
right. For example, if y = 13 = (1101)<sub>2</sub> then the components 1,3 and 4 are
extracted.</p>
<p>
If y is a vector (<code>t_VEC</code>, <code>t_COL</code> or <code>t_VECSMALL</code>), which must have
integer entries, these entries correspond to the component numbers to be
extracted, in the order specified.</p>
<p>
If y is a string, it can be</p>
<p>
<b>*</b> a single (non-zero) index giving a component number (a negative
index means we start counting from the end).</p>
<p>
<b>*</b> a range of the form <code>"a..b"</code>, where a and b are
indexes as above. Any of a and b can be omitted; in this case, we take
as default values a = 1 and b = -1, i.e.&nbsp;the first and last components
respectively. We then extract all components in the interval [a,b], in
reverse order if b &lt; a.</p>
<p>
In addition, if the first character in the string is <code>^</code>, the
complement of the given set of indices is taken.</p>
<p>
If z is not omitted, x must be a matrix. y is then the <em>row</em>
specifier, and z the <em>column</em> specifier, where the component specifier
is as explained above.</p>
<p></p>
<p>
</p><pre class="code">  ? v = [a, b, c, d, e];
  ? vecextract(v, 5)         \\  mask
  %1 = [a, c]
  ? vecextract(v, [4, 2, 1]) \\  component list
  %2 = [d, b, a]
  ? vecextract(v, "2..4")    \\  interval
  %3 = [b, c, d]
  ? vecextract(v, "-1..-3")  \\  interval + reverse order
  %4 = [e, d, c]
  ? vecextract(v, "^2")      \\  complement
  %5 = [a, c, d, e]
  ? vecextract(matid(3), "2..", "..")
  %6 =
  [0 1 0]
  
  [0 0 1]
</pre><p></p>
<p>
The range notations <code>v[i..j]</code> and <code>v[^i]</code> (for <code>t_VEC</code> or
<code>t_COL</code>) and <code>M[i..j, k..l]</code> and friends (for <code>t_MAT</code>) implement a
subset of the above, in a simpler and <em>faster</em> way, hence should be
preferred in most common situations. The following features are not
implemented in the range notation:</p>
<p>
<b>*</b> reverse order,</p>
<p>
<b>*</b> omitting either a or b in <code>a..b</code>.</p>
<p>
The library syntax is <code>GEN <b>extract0</b>(GEN x, GEN y, GEN z = NULL)</code>.</p>
<p>

<hr>
<div id="se:vecprod"></div>
<div id="vecprod"></div>
<h4>vecprod(v)</h4>
<p>
Return the product of the components of the vector v. Return 1 on an
empty vector.</p>
<p>
</p><pre class="code">  ? vecprod([1,2,3])
  %1 = 6
  ? vecprod([])
  %2 = 1
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>vecprod</b>(GEN v)</code>.</p>
<p>

<hr>
<div id="se:vecsearch"></div>
<div id="vecsearch"></div>
<h4>vecsearch(v, x, {<em>cmpf</em>})</h4>
<p>
Determines whether x belongs to the sorted vector or list v: return
the (positive) index where x was found, or 0 if it does not belong to
v.</p>
<p>
If the comparison function cmpf is omitted, we assume that v is sorted in
increasing order, according to the standard comparison function <code><a href="Standard_monadic_or_dyadic_operators.html#se:lex"
    onClick="parent.itemFrame.location='cont_Standard_monadic_or_dyadic_operators.html'">lex</a></code>,
thereby restricting the possible types for x and the elements of v
(integers, fractions, reals, and vectors of such). We also transparently
allow a <code>t_VECSMALL</code> x in this case, for the natural ordering of the
integers.</p>
<p>
If <code>cmpf</code> is present, it is understood as a comparison function and we
assume that v is sorted according to it, see <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:vecsort"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">vecsort</a></code> for how to
encode comparison functions.</p>
<p>
</p><pre class="code">  ? v = [1,3,4,5,7];
  ? vecsearch(v, 3)
  %2 = 2
  ? vecsearch(v, 6)
  %3 = 0 \\ not in the list
  ? vecsearch([7,6,5], 5) \\ unsorted vector: result undefined
  %4 = 0
</pre><p>
Note that if we are sorting with respect to a key
which is expensive to compute (e.g. a discriminant), one should rather
precompute all keys, sort that vector and search in the vector of keys,
rather than searching in the original vector with respect to a comparison
function.</p>
<p>
By abuse of notation, x is also allowed to be a matrix, seen as a vector
of its columns; again by abuse of notation, a <code>t_VEC</code> is considered
as part of the matrix, if its transpose is one of the matrix columns.</p>
<p>
</p><pre class="code">  ? v = vecsort([3,0,2; 1,0,2]) \\ sort matrix columns according to lex order
  %1 =
  [0 2 3]
  
  [0 2 1]
  ? vecsearch(v, [3,1]~)
  %2 = 3
  ? vecsearch(v, [3,1])  \\ can search for x or x~
  %3 = 3
  ? vecsearch(v, [1,2])
  %4 = 0 \\ not in the list
</pre><p></p>
<p></p>
<p>
The library syntax is <code>long <b>vecsearch</b>(GEN v, GEN x, GEN cmpf = NULL)</code>.</p>
<p>

<hr>
<div id="se:vecsort"></div>
<div id="vecsort"></div>
<h4>vecsort(x, {<em>cmpf</em>}, {<em>flag</em> = 0})</h4>
<p>
Sorts the vector x in ascending order, using a mergesort method.
x must be a list, vector or matrix (seen as a vector of its columns).
Note that mergesort is stable, hence the initial ordering of "equal"
entries (with respect to the sorting criterion) is not changed.</p>
<p>
If <code>cmpf</code> is omitted, we use the standard comparison function
<code><a href="Standard_monadic_or_dyadic_operators.html#se:lex"
    onClick="parent.itemFrame.location='cont_Standard_monadic_or_dyadic_operators.html'">lex</a></code>, thereby restricting the possible types for the elements of x
(integers, fractions or reals and vectors of those). We also transparently
allow a <code>t_VECSMALL</code> x in this case, for the standard ordering on the
integers.</p>
<p>
If <code>cmpf</code> is present, it is understood as a comparison function and we
sort according to it. The following possibilities exist:</p>
<p>
<b>*</b> an integer k: sort according to the value of the k-th
subcomponents of the components of&nbsp;x.</p>
<p>
<b>*</b> a vector: sort lexicographically according to the components listed in
the vector. For example, if <code>cmpf</code> = <code>[2,1,3]</code>, sort with respect to
the second component, and when these are equal, with respect to the first,
and when these are equal, with respect to the third.</p>
<p>
<b>*</b> a comparison function: <code>t_CLOSURE</code> with two arguments x and y,
and returning a real number which is  &lt; 0,  &gt; 0 or  = 0 if x &lt; y, x &gt; y or
x = y respectively.</p>
<p>
<b>*</b> a key: <code>t_CLOSURE</code> with one argument x and returning
the value f(x) with respect to which we sort.</p>
<p></p>
<p>
</p><pre class="code">  ? vecsort([3,0,2; 1,0,2]) \\ sort columns according to lex order
  %1 =
  [0 2 3]
  
  [0 2 1]
  ? vecsort(v, (x,y)-&gt;y-x)            \\  reverse sort
  ? vecsort(v, (x,y)-&gt;abs(x)-abs(y))  \\  sort by increasing absolute value
  ? vecsort(v, abs)  \\  sort by increasing absolute value, using key
  ? cmpf(x,y) = my(dx = poldisc(x), dy = poldisc(y)); abs(dx) - abs(dy);
  ? v = [x^2+1, x^3-2, x^4+5*x+1] vecsort(v, cmpf) \\  comparison function
  ? vecsort(v, x-&gt;abs(poldisc(x)))  \\  key
</pre><p></p>
<p>
The <code><a href="Transcendental_functions.html#se:abs"
    onClick="parent.itemFrame.location='cont_Transcendental_functions.html'">abs</a></code> and <code>cmpf</code> examples show how to use a named function
instead of an anonymous function. It is preferable to use a <em>key</em>
whenever possible rather than include it in the comparison function as above
since the key is evaluated O(n) times instead of O(nlog n),
where n is the number of entries.</p>
<p>
A direct approach is also possible and equivalent to using a sorting key:</p>
<p>
</p><pre class="code">  ? T = [abs(poldisc(x)) | x&lt;-v];
  ? perm = vecsort(T,,1); \\  indirect sort
  ? vecextract(v, perm)
</pre><p>
This also provides the vector T of all keys, which is
interesting for instance in later <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:vecsearch"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">vecsearch</a></code> calls: it is more
efficient to sort T (<code>T = vecextract(T, perm)</code>) then search for a key
in T rather than to search in v using a comparison function or a key.
Note also that <code><a href="Programming_in_GP__other_specific_functions.html#se:mapisdefined"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__other_specific_functions.html'">mapisdefined</a></code> is often easier to use and faster than
<code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:vecsearch"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">vecsearch</a></code>.</p>
<p>
The binary digits of <em>flag</em> mean:</p>
<p>
<b>*</b> 1: indirect sorting of the vector x, i.e.&nbsp;if x is an
n-component vector, returns a permutation of [1,2,...,n] which
applied to the components of x sorts x in increasing order.
For example, <code>vecextract(x, vecsort(x,,1))</code> is equivalent to
<code>vecsort(x)</code>.</p>
<p>
<b>*</b> 4: use descending instead of ascending order.</p>
<p>
<b>*</b> 8: remove "duplicate" entries with respect to the sorting function
(keep the first occurring entry).  For example:</p>
<p>
</p><pre class="code">    ? vecsort([Pi,Mod(1,2),z], (x,y)-&gt;0, 8)   \\  make everything compare equal
    %1 = [3.141592653589793238462643383]
    ? vecsort([[2,3],[0,1],[0,3]], 2, 8)
    %2 = [[0, 1], [2, 3]]
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>vecsort0</b>(GEN x, GEN cmpf = NULL, long flag)</code>.</p>
<p>

<hr>
<div id="se:vecsum"></div>
<div id="vecsum"></div>
<h4>vecsum(v)</h4>
<p>
Return the sum of the components of the vector v. Return 0 on an
empty vector.</p>
<p>
</p><pre class="code">  ? vecsum([1,2,3])
  %1 = 6
  ? vecsum([])
  %2 = 0
</pre><p></p>
<p></p>
<p>
The library syntax is <code>GEN <b>vecsum</b>(GEN v)</code>.</p>
<p>

<hr>
<div id="se:vector"></div>
<div id="vector"></div>
<h4>vector(n, {X}, {<em>expr</em> = 0})</h4>
<p>
Creates a row vector (type
<code>t_VEC</code>) with n components whose components are the expression
<em>expr</em> evaluated at the integer points between 1 and n. If one of the
last two arguments is omitted, fill the vector with zeroes.</p>
<p>
</p><pre class="code">  ? vector(3,i, 5*i)
  %1 = [5, 10, 15]
  ? vector(3)
  %2 = [0, 0, 0]
</pre><p></p>
<p></p>
<p>
The variable X is lexically scoped to each evaluation of <em>expr</em>.  Any
change to X within <em>expr</em> does not affect subsequent evaluations, it
still runs 1 to n.  A local change allows for example different indexing:</p>
<p>
</p><pre class="code">  vector(10, i, i=i-1; f(i)) \\ i = 0, ..., 9
  vector(10, i, i=2*i; f(i)) \\ i = 2, 4, ..., 20
</pre><p></p>
<p>
This per-element scope for X differs from <code><a href="Programming_in_GP__control_statements.html#se:for"
    onClick="parent.itemFrame.location='cont_Programming_in_GP__control_statements.html'">for</a></code> loop evaluations,
as the following example shows:</p>
<p>
</p><pre class="code">  n = 3
  v = vector(n); vector(n, i, i++)             &mdash; -&gt; [2, 3, 4]
  v = vector(n); for (i = 1, n, v[i] = i++)    &mdash; -&gt; [2, 0, 4]
</pre><p></p>
<p></p>
<p></p>
<p>

<hr>
<div id="se:vectorsmall"></div>
<div id="vectorsmall"></div>
<h4>vectorsmall(n, {X}, {<em>expr</em> = 0})</h4>
<p>
Creates a row vector of small integers (type
<code>t_VECSMALL</code>) with n components whose components are the expression
<em>expr</em> evaluated at the integer points between 1 and n. If one of the
last two arguments is omitted, fill the vector with zeroes.</p>
<p></p>
<p>

<hr>
<div id="se:vectorv"></div>
<div id="vectorv"></div>
<h4>vectorv(n, {X}, {<em>expr</em> = 0})</h4>
<p>
As <code><a href="Vectors__matrices__linear_algebra_and_sets.html#se:vector"
    onClick="parent.itemFrame.location='cont_Vectors__matrices__linear_algebra_and_sets.html'">vector</a></code>, but returns a column vector (type <code>t_COL</code>).</p>
<p></p>
<p>

<hr>
</body>
